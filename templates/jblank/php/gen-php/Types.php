<?php
/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * Report content type.
 * Demands from report generation function one of allowed format options.
 * - HTML (тип данных результирующего отчета будет mime_html)
 * - PDF  (в результате получим mime_pdf)
 * - IMAGE (в результате mime_img = mime_png)
 * - CSV (в результате text/csv)
 */
final class ReportFormatType {
  /**
   * Result data will have MIME_HTML content type
   */
  const HTML = 1;
  /**
   * Result data will have MIME_PDF content type
   */
  const PDF = 2;
  /**
   * Result data will have MIME_PNG content type
   */
  const IMAGE = 3;
  /**
   * Result data will have MIME_TXT (text/csv) content type
   */
  const CSV = 4;
  /**
   * Demands custom format described in other parameters (see ReportOptions)
   */
  const CUSTOM = 99;
  static public $__names = array(
    1 => 'HTML',
    2 => 'PDF',
    3 => 'IMAGE',
    4 => 'CSV',
    99 => 'CUSTOM',
  );
}

/**
 * Card status
 */
final class CardStatus {
  /**
   * Card is active. Operations are allowed with this card.
   */
  const ACTIVE = 1;
  /**
   * Card is not active. Any operation will fail for this card except unlocking card
   */
  const INACTIVE = 0;
  static public $__names = array(
    1 => 'ACTIVE',
    0 => 'INACTIVE',
  );
}

/**
 * Term type for describing some time interval measure: day, month, year, week, quarter, and the empty period "INSTANT".
 */
final class TermType {
  const DAY = 1;
  const MONTH = 2;
  const YEAR = 3;
  const WEEK = 4;
  const QUARTER = 5;
  /**
   * No period. Used e.g. for describing period what should be applied for aggregation of operations in this period (e.g. making limiting by total amount).
   * If term is INSTANT, that means "onnly this current operation should be aggregated".
   */
  const INSTANT = 0;
  static public $__names = array(
    1 => 'DAY',
    2 => 'MONTH',
    3 => 'YEAR',
    4 => 'WEEK',
    5 => 'QUARTER',
    0 => 'INSTANT',
  );
}

/**
 * Contract type.
 */
final class ContractType {
  /**
   * Credit contract (loan contract)
   */
  const CREDIT = 1;
  /**
   * Account contract
   */
  const ACCOUNT = 2;
  /**
   * Deposit (saving) contract
   */
  const DEPOSIT = 3;
  /**
   * Card contract
   */
  const CARD = 4;
  /**
   * Prepaid card/wallet/account/voucher
   */
  const PREPAID = 5;
  static public $__names = array(
    1 => 'CREDIT',
    2 => 'ACCOUNT',
    3 => 'DEPOSIT',
    4 => 'CARD',
    5 => 'PREPAID',
  );
}

/**
 * Card payment system.
 */
final class CardPaymentSystem {
  const MASTERCARD = 5;
  const VISA = 4;
  static public $__names = array(
    5 => 'MASTERCARD',
    4 => 'VISA',
  );
}

/**
 * Limit type defines the kind of limit, e.g. total limit, ATM operations limit, point o sale terminal operations limit, etc.
 * OTHER limit type allows extend limit types, but usually listed types are enough for most cases.
 * 
 */
final class LimitType {
  /**
   * Total limit for all operation types. May be applied to CARD, ACCOUNT contracts.
   */
  const TOTAL = 1;
  /**
   * Limit for ATM operations. May be applied to cards
   */
  const ATM = 2;
  /**
   * Limit for POS (Point of Sales) terminals operations. May be applied to cards
   */
  const POS = 3;
  /**
   * Limit for e-commerce operations. May be applied to cards
   */
  const INTERNET = 4;
  /**
   * Other, more specific limit, e.g. "limit for cash in in ATM" or "limit for PIN-code attempts"
   */
  const OTHER = 5;
  static public $__names = array(
    1 => 'TOTAL',
    2 => 'ATM',
    3 => 'POS',
    4 => 'INTERNET',
    5 => 'OTHER',
  );
}

/**
 * Значение для фильтрации булевских (да / нет) параметров.
 * 
 */
final class BooleanFilter {
  /**
   * В искомом объекте значение должно быть true
   */
  const MUST_TRUE = 1;
  /**
   * В искомом объекте значение должно быть false
   */
  const MUST_FALSE = 0;
  /**
   * В искомом объекте значение может быть любым
   */
  const DOES_NOT_MATTER = 2;
  static public $__names = array(
    1 => 'MUST_TRUE',
    0 => 'MUST_FALSE',
    2 => 'DOES_NOT_MATTER',
  );
}

final class AuthCredentialsType {
  const LOGINPASSWORD = 1;
  const OTP = 2;
  const DEVICE = 3;
  const TOKEN = 4;
  static public $__names = array(
    1 => 'LOGINPASSWORD',
    2 => 'OTP',
    3 => 'DEVICE',
    4 => 'TOKEN',
  );
}

final class ChallengeType {
  const NULL = 0;
  const OTP = 1;
  static public $__names = array(
    0 => 'NULL',
    1 => 'OTP',
  );
}

final class AuthExceptionType {
  const WRONGCREDS = 1;
  const WRONGMETHOD = 2;
  const TECHNICAL_ISSUE = 3;
  static public $__names = array(
    1 => 'WRONGCREDS',
    2 => 'WRONGMETHOD',
    3 => 'TECHNICAL_ISSUE',
  );
}

/**
 * Communication channel type defines which channel will be used (e.g. for content delivery for offers or password delivery).
 */
final class ChannelType {
  const OTHER = 0;
  const SMS = 1;
  const EMAIL = 2;
  /**
   * Web channel means the most rich content, e.g. graphic, HTML, etc.
   */
  const WEB = 3;
  /**
   * Mobile channel means delivering content adopted to smaller client's screens
   */
  const MOBILE = 4;
  /**
   * Used when the channel is not specified or does not matter
   */
  const ANY = 99;
  static public $__names = array(
    0 => 'OTHER',
    1 => 'SMS',
    2 => 'EMAIL',
    3 => 'WEB',
    4 => 'MOBILE',
    99 => 'ANY',
  );
}

/**
 * Уровень аутентификации, который имеет сессий клиента.
 * Сейчас SIMPLE соответствует аутентификации по логину и паролю,
 * а EXTENDED после успешного вызова requestExtendedAuthentication():challenge + authenticate(challenge, otp).
 * 
 * 
 */
final class AuthenticationLevel {
  const SIMPLE = 0;
  const EXTENDED = 1;
  const DEVICE = -1;
  static public $__names = array(
    0 => 'SIMPLE',
    1 => 'EXTENDED',
    -1 => 'DEVICE',
  );
}

final class ClientIdentificationType {
  /**
   * Any string depend on bank contract numeration system
   */
  const DEAL_NUMBER = 1;
  /**
   * Usually 8-14 digits
   */
  const ACCOUNT_NUMBER = 2;
  /**
   * Usually (almost always) 16 digits
   */
  const CARD_NUMBER = 3;
  static public $__names = array(
    1 => 'DEAL_NUMBER',
    2 => 'ACCOUNT_NUMBER',
    3 => 'CARD_NUMBER',
  );
}

final class UserOperationStatus {
  const SUCCESS = 0;
  const FAIL = 1;
  const CREATED = 2;
  const WAIT_FOR_PROCESSING = 3;
  static public $__names = array(
    0 => 'SUCCESS',
    1 => 'FAIL',
    2 => 'CREATED',
    3 => 'WAIT_FOR_PROCESSING',
  );
}

final class ProfileOperationType {
  const LOGIN = 1;
  const CHANGE_PASSWORD = 2;
  const RESET_PASSWORD = 3;
  static public $__names = array(
    1 => 'LOGIN',
    2 => 'CHANGE_PASSWORD',
    3 => 'RESET_PASSWORD',
  );
}

/**
 * Тип финансовой операции.
 * Используется для эмуляции наследования в структуре FinancialOperation
 * 
 */
final class FinancialOperationType {
  /**
   * Операция между своими договорами клиента
   */
  const CONTRACT_TO_CONTRACT = 1;
  /**
   * перевод через национальную межбанковскую систему электронных платежей (платеж по произвольным реквизитам)
   */
  const SEP_TRANSFER = 2;
  /**
   * оплата услуг провайдера услуг (биллера)
   */
  const BILLER_PAYMENT = 3;
  /**
   * SWIFT-перевод (Society for Worldwide Interbank Financial Telecommunication) http://ru.wikipedia.org/wiki/SWIFT
   */
  const SWIFT_TRANSFER = 4;
  /**
   * перевод между клиентами Ibank
   */
  const P2P_IBANK = 5;
  /**
   * наличные расходы или доходы
   */
  const CASH_TRANSFER = 6;
  /**
   * открытие депозита*
   */
  const MAKE_DEPOSIT = 7;
  /**
   * intrabank transfer
   */
  const INTRABANK_TRANSFER = 8;
  /**
   * card to card operation
   */
  const CARD_TO_CARD = 9;
  /**
   * card to contract operation
   */
  const CARD_TO_CONTRACT = 10;
  /**
   * close contract operation
   */
  const CLOSE_CONTRACT = 11;
  /**
   * custom operation (must be extended by customType in CustomOperationSubject)
   */
  const CUSTOM = 99;
  static public $__names = array(
    1 => 'CONTRACT_TO_CONTRACT',
    2 => 'SEP_TRANSFER',
    3 => 'BILLER_PAYMENT',
    4 => 'SWIFT_TRANSFER',
    5 => 'P2P_IBANK',
    6 => 'CASH_TRANSFER',
    7 => 'MAKE_DEPOSIT',
    8 => 'INTRABANK_TRANSFER',
    9 => 'CARD_TO_CARD',
    10 => 'CARD_TO_CONTRACT',
    11 => 'CLOSE_CONTRACT',
    99 => 'CUSTOM',
  );
}

final class PurposeFilterType {
  const CONTAINS = 1;
  const EXCLUDE = 2;
  const NONE = 3;
  static public $__names = array(
    1 => 'CONTAINS',
    2 => 'EXCLUDE',
    3 => 'NONE',
  );
}

final class OperationAmountType {
  const RECOMMENDED = 0;
  const MINIMAL = 1;
  const MAXIMAL = 2;
  const DEFAULT = 3;
  static public $__names = array(
    0 => 'RECOMMENDED',
    1 => 'MINIMAL',
    2 => 'MAXIMAL',
    3 => 'DEFAULT',
  );
}

final class OperationTemplateOrigin {
  const SYSTEM = 0;
  const USER = 1;
  static public $__names = array(
    0 => 'SYSTEM',
    1 => 'USER',
  );
}

final class ExtendedAuthScope {
  const OPERATION = 0;
  const PERIOD = 1;
  static public $__names = array(
    0 => 'OPERATION',
    1 => 'PERIOD',
  );
}

final class ParameterType {
  const STRING = 1;
  const NUMERIC = 2;
  const DATE = 3;
  const DATETIME = 4;
  const PHONE = 5;
  const CARDNUM = 6;
  static public $__names = array(
    1 => 'STRING',
    2 => 'NUMERIC',
    3 => 'DATE',
    4 => 'DATETIME',
    5 => 'PHONE',
    6 => 'CARDNUM',
  );
}

/**
 * Тип операции. Предназначен для использования для всех остальных операций,
 * кроме финансовых (FinancialOperation) и операций, связанных с профилем (ProfileOperationHistoryItem)
 * 
 */
final class CommonOperationType {
  /**
   * Операция блокировки карты, выполняемая методом lockCard()
   */
  const LOCK_CARD = 201;
  /**
   * Операция разблокировки карты, выполняемая методом unlockCard()
   */
  const UNLOCK_CARD = 202;
  /**
   * Изменение лимита на счет или карту
   */
  const CHANGE_LIMIT = 101;
  /**
   * Изменение лимитов на счет или карту
   */
  const CHANGE_LIMITS = 104;
  /**
   * Изменение карточных настроек
   */
  const CHANGE_CARD_SETTINGS = 102;
  /**
   * Изменение настроек депозита
   */
  const CHANGE_DEPOSIT_SETTINGS = 103;
  /**
   * Start of device registration process
   */
  const DEVICE_REGISTRATION_START = 301;
  /**
   * Finish of device registration process
   */
  const DEVICE_REGISTRATION_FINISH = 302;
  /**
   * Start of card digitalization process
   */
  const DIGITALIZATION_CARD_START = 401;
  /**
   * Finish of card digitalization process
   */
  const DIGITALIZATION_CARD_FINISH = 402;
  static public $__names = array(
    201 => 'LOCK_CARD',
    202 => 'UNLOCK_CARD',
    101 => 'CHANGE_LIMIT',
    104 => 'CHANGE_LIMITS',
    102 => 'CHANGE_CARD_SETTINGS',
    103 => 'CHANGE_DEPOSIT_SETTINGS',
    301 => 'DEVICE_REGISTRATION_START',
    302 => 'DEVICE_REGISTRATION_FINISH',
    401 => 'DIGITALIZATION_CARD_START',
    402 => 'DIGITALIZATION_CARD_FINISH',
  );
}

/**
 * Offer status.
 */
final class OfferStatus {
  /**
   * Offer is active and should be presented to Client
   */
  const ACTIVE = 1;
  /**
   * Offer was accepted by customer (if offer means callToAction, the operation must be set as well)
   */
  const ACCEPTED = 2;
  /**
   * Offer is rejected
   */
  const REJECTED = 3;
  /**
   * Offer is viewed but there is no decision about it
   */
  const POSTPONED = 4;
  /**
   * Offer is expired
   */
  const EXPIRED = 5;
  static public $__names = array(
    1 => 'ACTIVE',
    2 => 'ACCEPTED',
    3 => 'REJECTED',
    4 => 'POSTPONED',
    5 => 'EXPIRED',
  );
}

/**
 * Offer response type is the kind of decision which client made about some offer.
 */
final class OfferResponseType {
  /**
   * Offer was successfully accepted
   */
  const ACCEPT = 2;
  /**
   * Offer was rejected
   */
  const REJECT = 3;
  /**
   * Offer was viewed but postponed to future decision. Should not be viewed till postponeDate come
   */
  const POSTPONE = 4;
  static public $__names = array(
    2 => 'ACCEPT',
    3 => 'REJECT',
    4 => 'POSTPONE',
  );
}

/**
 * Additional attributes to extend some parameters set, method call or unpredictable data structure.
 * Usually used as quick solution to extend functionality.
 * Just set ot "name"-"value" string pairs.
 */
class Attributes {
  static $_TSPEC;

  /**
   * @var array
   */
  public $attrs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'attrs',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['attrs'])) {
        $this->attrs = $vals['attrs'];
      }
    }
  }

  public function getName() {
    return 'Attributes';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->attrs = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = '';
              $val6 = '';
              $xfer += $input->readString($key5);
              $xfer += $input->readString($val6);
              $this->attrs[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Attributes');
    if ($this->attrs !== null) {
      if (!is_array($this->attrs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attrs', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->attrs));
        {
          foreach ($this->attrs as $kiter7 => $viter8)
          {
            $xfer += $output->writeString($kiter7);
            $xfer += $output->writeString($viter8);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Binary data. Base64-encoded.
 * (http://en.wikipedia.org/wiki/Base64).
 * Has the content type, fileName and charset, describing the data for helping to represent on client side.
 * See MYME types (http://en.wikipedia.org/wiki/MIME_type)
 */
class Base64BinaryData {
  static $_TSPEC;

  /**
   * Content type by MIME, e.g. "image/png"
   * 
   * @var string
   */
  public $contentType = null;
  /**
   * Base64 encoded data itself
   * 
   * @var string
   */
  public $body = null;
  /**
   * File name if data should be (could be) considered as file
   * 
   * @var string
   */
  public $fileName = null;
  /**
   * If binary data is text, the text encoding. In most cases means "UTF-8"
   * 
   * @var string
   */
  public $charset = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'contentType',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'body',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'fileName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'charset',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['contentType'])) {
        $this->contentType = $vals['contentType'];
      }
      if (isset($vals['body'])) {
        $this->body = $vals['body'];
      }
      if (isset($vals['fileName'])) {
        $this->fileName = $vals['fileName'];
      }
      if (isset($vals['charset'])) {
        $this->charset = $vals['charset'];
      }
    }
  }

  public function getName() {
    return 'Base64BinaryData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contentType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->body);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fileName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->charset);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Base64BinaryData');
    if ($this->contentType !== null) {
      $xfer += $output->writeFieldBegin('contentType', TType::STRING, 1);
      $xfer += $output->writeString($this->contentType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->body !== null) {
      $xfer += $output->writeFieldBegin('body', TType::STRING, 2);
      $xfer += $output->writeString($this->body);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fileName !== null) {
      $xfer += $output->writeFieldBegin('fileName', TType::STRING, 3);
      $xfer += $output->writeString($this->fileName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->charset !== null) {
      $xfer += $output->writeFieldBegin('charset', TType::STRING, 4);
      $xfer += $output->writeString($this->charset);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Requested report options.
 * First of all it's content format.
 * If given format is CUSTOM, optional parameter customFormatName is mandatory and
 * in fact means the XSLT template (configured on server).
 * XSLT template itself defines the contentType and charset for custom format it represents.
 */
class ReportOptions {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var string
   */
  public $customFormatName = null;
  /**
   * @var \Attributes
   */
  public $parameters = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'customFormatName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'parameters',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['customFormatName'])) {
        $this->customFormatName = $vals['customFormatName'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
    }
  }

  public function getName() {
    return 'ReportOptions';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->customFormatName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->parameters = new \Attributes();
            $xfer += $this->parameters->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ReportOptions');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->customFormatName !== null) {
      $xfer += $output->writeFieldBegin('customFormatName', TType::STRING, 2);
      $xfer += $output->writeString($this->customFormatName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_object($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::STRUCT, 3);
      $xfer += $this->parameters->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Contract term.
 * E.g. the term of deposit contract: 12 MONTH.
 */
class ContractTerm {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var int
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'value',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'ContractTerm';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ContractTerm');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::I64, 2);
      $xfer += $output->writeI64($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Term value allows define the "12th week of year 2013", e.g. for report items (how many operations have been processed in 12th week of year 2013, etc.)
 * Other examples: {day:1, month:12, year:2013}, {day:2, month:12, year:2013}, {day:1, month:12, year:2013}.
 * {quarter:1, year:2015}, {quarter:2, year:2015}, etc..
 * TermValue usually used with to TermType.
 * For TermValue {day:1, year:2015} the TermType is 'DAY', for {quarter:2, year:2015} it's QUARTER.
 */
class TermValue {
  static $_TSPEC;

  /**
   * 1-12, mandatory for TermType:MONTH, TermType:DAY
   * 
   * @var int
   */
  public $month = null;
  /**
   * full year value (2014 or 1978), mandatory for TermType:QUARTER,TermType:YEAR,TermType:MONTH,TermType:WEEK,TermType:DAY
   * 
   * @var int
   */
  public $year = null;
  /**
   * week of year, mandatory for TermType:QUARTER
   * 
   * @var int
   */
  public $week = null;
  /**
   * day of month, mandatory for TermType:DAY
   * 
   * @var int
   */
  public $day = null;
  /**
   * quarter, mandatory for TermType:QUARTER
   * 
   * @var int
   */
  public $quarter = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'month',
          'type' => TType::BYTE,
          ),
        2 => array(
          'var' => 'year',
          'type' => TType::I16,
          ),
        3 => array(
          'var' => 'week',
          'type' => TType::BYTE,
          ),
        4 => array(
          'var' => 'day',
          'type' => TType::BYTE,
          ),
        5 => array(
          'var' => 'quarter',
          'type' => TType::BYTE,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['month'])) {
        $this->month = $vals['month'];
      }
      if (isset($vals['year'])) {
        $this->year = $vals['year'];
      }
      if (isset($vals['week'])) {
        $this->week = $vals['week'];
      }
      if (isset($vals['day'])) {
        $this->day = $vals['day'];
      }
      if (isset($vals['quarter'])) {
        $this->quarter = $vals['quarter'];
      }
    }
  }

  public function getName() {
    return 'TermValue';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->month);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->year);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->week);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->day);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->quarter);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('TermValue');
    if ($this->month !== null) {
      $xfer += $output->writeFieldBegin('month', TType::BYTE, 1);
      $xfer += $output->writeByte($this->month);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->year !== null) {
      $xfer += $output->writeFieldBegin('year', TType::I16, 2);
      $xfer += $output->writeI16($this->year);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->week !== null) {
      $xfer += $output->writeFieldBegin('week', TType::BYTE, 3);
      $xfer += $output->writeByte($this->week);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->day !== null) {
      $xfer += $output->writeFieldBegin('day', TType::BYTE, 4);
      $xfer += $output->writeByte($this->day);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->quarter !== null) {
      $xfer += $output->writeFieldBegin('quarter', TType::BYTE, 5);
      $xfer += $output->writeByte($this->quarter);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Reference to contract (type and ID).
 * 
 */
class ContractReference {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var int
   */
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'ContractReference';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ContractReference');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 2);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Common and for-all-purpose data container for referencing any card (internal or external).
 * All fields are optional but must be present
 * contractReference & cardId (if it means) or cardNumber (if it means external card).
 * If there is external card used as sender (source) card, expMonth, expYear and secureCode should be present.
 */
class CardReference {
  static $_TSPEC;

  /**
   * Reference to user's contract, containing card with cardId
   * 
   * @var \ContractReference
   */
  public $contractReference = null;
  /**
   * Card id of user's card
   * 
   * @var string
   */
  public $cardId = null;
  /**
   * Full card number (PAN): used for external cards
   * 
   * @var string
   */
  public $cardNumber = null;
  /**
   * External card's expiry date month: 1-12
   * 
   * @var int
   */
  public $expMonth = null;
  /**
   * External card's expiry date year: full like 2021
   * 
   * @var int
   */
  public $expYear = null;
  /**
   * Card secure code: usually 3 digits (CVV/CVC)
   * 
   * @var string
   */
  public $secureCode = null;
  /**
   * Masked card number (PAN)
   * 
   * @var string
   */
  public $cardNumberMask = null;
  /**
   * Extended attributes for custom card referencing (e.g. if some operations demand owner name, etc.)
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'contractReference',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        2 => array(
          'var' => 'cardId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'cardNumber',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'expMonth',
          'type' => TType::BYTE,
          ),
        5 => array(
          'var' => 'expYear',
          'type' => TType::I16,
          ),
        6 => array(
          'var' => 'secureCode',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'cardNumberMask',
          'type' => TType::STRING,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['contractReference'])) {
        $this->contractReference = $vals['contractReference'];
      }
      if (isset($vals['cardId'])) {
        $this->cardId = $vals['cardId'];
      }
      if (isset($vals['cardNumber'])) {
        $this->cardNumber = $vals['cardNumber'];
      }
      if (isset($vals['expMonth'])) {
        $this->expMonth = $vals['expMonth'];
      }
      if (isset($vals['expYear'])) {
        $this->expYear = $vals['expYear'];
      }
      if (isset($vals['secureCode'])) {
        $this->secureCode = $vals['secureCode'];
      }
      if (isset($vals['cardNumberMask'])) {
        $this->cardNumberMask = $vals['cardNumberMask'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'CardReference';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->contractReference = new \ContractReference();
            $xfer += $this->contractReference->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->cardId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->cardNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->expMonth);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->expYear);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->secureCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->cardNumberMask);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CardReference');
    if ($this->contractReference !== null) {
      if (!is_object($this->contractReference)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('contractReference', TType::STRUCT, 1);
      $xfer += $this->contractReference->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cardId !== null) {
      $xfer += $output->writeFieldBegin('cardId', TType::STRING, 2);
      $xfer += $output->writeString($this->cardId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cardNumber !== null) {
      $xfer += $output->writeFieldBegin('cardNumber', TType::STRING, 3);
      $xfer += $output->writeString($this->cardNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expMonth !== null) {
      $xfer += $output->writeFieldBegin('expMonth', TType::BYTE, 4);
      $xfer += $output->writeByte($this->expMonth);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expYear !== null) {
      $xfer += $output->writeFieldBegin('expYear', TType::I16, 5);
      $xfer += $output->writeI16($this->expYear);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->secureCode !== null) {
      $xfer += $output->writeFieldBegin('secureCode', TType::STRING, 6);
      $xfer += $output->writeString($this->secureCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cardNumberMask !== null) {
      $xfer += $output->writeFieldBegin('cardNumberMask', TType::STRING, 7);
      $xfer += $output->writeString($this->cardNumberMask);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Data of 3D Secure request.
 * Should be used for any operation where the sender is card (CardReference).
 * Good reference is here: http://docs.3dsecure.io/
 */
class Secure3DRequest {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $enrolled = null;
  /**
   * @var string
   */
  public $acsUrl = null;
  /**
   * @var string
   */
  public $termUrl = null;
  /**
   * @var string
   */
  public $paReq = null;
  /**
   * @var string
   */
  public $md = null;
  /**
   * @var string
   */
  public $xid = null;
  /**
   * @var string
   */
  public $error = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'enrolled',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'acsUrl',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'termUrl',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'paReq',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'md',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'xid',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'error',
          'type' => TType::STRING,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['enrolled'])) {
        $this->enrolled = $vals['enrolled'];
      }
      if (isset($vals['acsUrl'])) {
        $this->acsUrl = $vals['acsUrl'];
      }
      if (isset($vals['termUrl'])) {
        $this->termUrl = $vals['termUrl'];
      }
      if (isset($vals['paReq'])) {
        $this->paReq = $vals['paReq'];
      }
      if (isset($vals['md'])) {
        $this->md = $vals['md'];
      }
      if (isset($vals['xid'])) {
        $this->xid = $vals['xid'];
      }
      if (isset($vals['error'])) {
        $this->error = $vals['error'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'Secure3DRequest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->enrolled);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->acsUrl);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->termUrl);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->paReq);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->md);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->xid);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->error);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Secure3DRequest');
    if ($this->enrolled !== null) {
      $xfer += $output->writeFieldBegin('enrolled', TType::BOOL, 1);
      $xfer += $output->writeBool($this->enrolled);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->acsUrl !== null) {
      $xfer += $output->writeFieldBegin('acsUrl', TType::STRING, 2);
      $xfer += $output->writeString($this->acsUrl);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->termUrl !== null) {
      $xfer += $output->writeFieldBegin('termUrl', TType::STRING, 3);
      $xfer += $output->writeString($this->termUrl);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->paReq !== null) {
      $xfer += $output->writeFieldBegin('paReq', TType::STRING, 4);
      $xfer += $output->writeString($this->paReq);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->md !== null) {
      $xfer += $output->writeFieldBegin('md', TType::STRING, 5);
      $xfer += $output->writeString($this->md);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->xid !== null) {
      $xfer += $output->writeFieldBegin('xid', TType::STRING, 6);
      $xfer += $output->writeString($this->xid);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->error !== null) {
      $xfer += $output->writeFieldBegin('error', TType::STRING, 7);
      $xfer += $output->writeString($this->error);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Account contract. Represents contract of maintaining standard banking account.
 */
class AccountContract {
  static $_TSPEC;

  /**
   * Unique  contract ID (usually originating system primary key for contract record)
   * 
   * @var string
   */
  public $id = null;
  /**
   * Contract number printed on client's contract copy
   * 
   * @var string
   */
  public $legalNumber = null;
  /**
   * Subproduct code from originating system. Different from productSystemKey which is given by iBank product mapping configuration. E.g. it could be many sub-products with minor differences mapped to one productSystemKey
   * 
   * @var string
   */
  public $subproductCode = null;
  /**
   * Main account number, usually it corresponds to mask "2620XZZZZZZZZZ", where "2620" is account class X is CRC digit, ZZZ.. is the account number. Example: "26207123456789"
   * 
   * @var string
   */
  public $mainAccountNumber = null;
  /**
   * Main account currency. Multy-currency contracts may be represented by set of different AccountContract having same mainAccountNumber but different currencyId (and, of course, different balances)
   * 
   * @var string
   */
  public $mainAccountCurrency = null;
  /**
   * Total summary balance for this account
   * 
   * @var int
   */
  public $balance = null;
  /**
   * Contract start date
   * 
   * @var string
   */
  public $startDate = null;
  /**
   * Contract end date. Optional, cause contracts may have "unlimited" term
   * 
   * @var string
   */
  public $endDate = null;
  /**
   * If there is "interest" contract conditions.
   * 
   * @var double
   */
  public $currentInterestRate = null;
  /**
   * Specific attributes for extending
   * 
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * iBank product catalog title
   * 
   * @var string
   */
  public $productTitle = null;
  /**
   * iBank product catalog key
   * 
   * @var string
   */
  public $productSystemKey = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'legalNumber',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'subproductCode',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'mainAccountNumber',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'mainAccountCurrency',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'balance',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'startDate',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'endDate',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'currentInterestRate',
          'type' => TType::DOUBLE,
          ),
        10 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        11 => array(
          'var' => 'productTitle',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'productSystemKey',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['legalNumber'])) {
        $this->legalNumber = $vals['legalNumber'];
      }
      if (isset($vals['subproductCode'])) {
        $this->subproductCode = $vals['subproductCode'];
      }
      if (isset($vals['mainAccountNumber'])) {
        $this->mainAccountNumber = $vals['mainAccountNumber'];
      }
      if (isset($vals['mainAccountCurrency'])) {
        $this->mainAccountCurrency = $vals['mainAccountCurrency'];
      }
      if (isset($vals['balance'])) {
        $this->balance = $vals['balance'];
      }
      if (isset($vals['startDate'])) {
        $this->startDate = $vals['startDate'];
      }
      if (isset($vals['endDate'])) {
        $this->endDate = $vals['endDate'];
      }
      if (isset($vals['currentInterestRate'])) {
        $this->currentInterestRate = $vals['currentInterestRate'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['productTitle'])) {
        $this->productTitle = $vals['productTitle'];
      }
      if (isset($vals['productSystemKey'])) {
        $this->productSystemKey = $vals['productSystemKey'];
      }
    }
  }

  public function getName() {
    return 'AccountContract';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->legalNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->subproductCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->mainAccountNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->mainAccountCurrency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->balance);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->endDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->currentInterestRate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->productTitle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->productSystemKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AccountContract');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->legalNumber !== null) {
      $xfer += $output->writeFieldBegin('legalNumber', TType::STRING, 2);
      $xfer += $output->writeString($this->legalNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subproductCode !== null) {
      $xfer += $output->writeFieldBegin('subproductCode', TType::STRING, 3);
      $xfer += $output->writeString($this->subproductCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mainAccountNumber !== null) {
      $xfer += $output->writeFieldBegin('mainAccountNumber', TType::STRING, 4);
      $xfer += $output->writeString($this->mainAccountNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mainAccountCurrency !== null) {
      $xfer += $output->writeFieldBegin('mainAccountCurrency', TType::STRING, 5);
      $xfer += $output->writeString($this->mainAccountCurrency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->balance !== null) {
      $xfer += $output->writeFieldBegin('balance', TType::I64, 6);
      $xfer += $output->writeI64($this->balance);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startDate !== null) {
      $xfer += $output->writeFieldBegin('startDate', TType::STRING, 7);
      $xfer += $output->writeString($this->startDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endDate !== null) {
      $xfer += $output->writeFieldBegin('endDate', TType::STRING, 8);
      $xfer += $output->writeString($this->endDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currentInterestRate !== null) {
      $xfer += $output->writeFieldBegin('currentInterestRate', TType::DOUBLE, 9);
      $xfer += $output->writeDouble($this->currentInterestRate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 10);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->productTitle !== null) {
      $xfer += $output->writeFieldBegin('productTitle', TType::STRING, 11);
      $xfer += $output->writeString($this->productTitle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->productSystemKey !== null) {
      $xfer += $output->writeFieldBegin('productSystemKey', TType::STRING, 12);
      $xfer += $output->writeString($this->productSystemKey);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Limit defines some rule, not allowing violating quantity or amount for some operation types for some term.
 * E.g. Limit "no more than 10 ATM withdrawals for no more than 1000 USD per day"
 */
class Limit {
  static $_TSPEC;

  /**
   * Defines operations type for this limit
   * 
   * @var int
   */
  public $type = null;
  /**
   * Specific limit name if limit type is OTHER
   * 
   * @var string
   */
  public $otherType = null;
  /**
   * Limiting (non-violating) operations amount value (money). If empty, means "no limitation" or this limit type not supported amount-limiting (e.g. PIN attempts limits).
   * 
   * @var int
   */
  public $amount = null;
  /**
   * Limiting (non-violating) operations quantity value (how many operations allowed). If empty, means "no limitation" or this limit type is not supported (e.g. amount limit for one operation)
   * 
   * @var int
   */
  public $quantity = null;
  /**
   * Term for limit. termType=INSTANT limit for one (current) operation. In INSTANT case, no quantity value makes sense
   * 
   * @var int
   */
  public $termType = null;
  /**
   * Term value. In most cases value is 1 (1 day or 1 month)
   * 
   * @var int
   */
  public $termValue = null;
  /**
   * The date from which the limit comes into operate
   * 
   * @var int
   */
  public $dateFrom = null;
  /**
   * Date till which the limit is operate
   * 
   * @var int
   */
  public $dateTill = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'otherType',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'amount',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'quantity',
          'type' => TType::I16,
          ),
        5 => array(
          'var' => 'termType',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'termValue',
          'type' => TType::I16,
          ),
        7 => array(
          'var' => 'dateFrom',
          'type' => TType::I64,
          ),
        8 => array(
          'var' => 'dateTill',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['otherType'])) {
        $this->otherType = $vals['otherType'];
      }
      if (isset($vals['amount'])) {
        $this->amount = $vals['amount'];
      }
      if (isset($vals['quantity'])) {
        $this->quantity = $vals['quantity'];
      }
      if (isset($vals['termType'])) {
        $this->termType = $vals['termType'];
      }
      if (isset($vals['termValue'])) {
        $this->termValue = $vals['termValue'];
      }
      if (isset($vals['dateFrom'])) {
        $this->dateFrom = $vals['dateFrom'];
      }
      if (isset($vals['dateTill'])) {
        $this->dateTill = $vals['dateTill'];
      }
    }
  }

  public function getName() {
    return 'Limit';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->otherType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->amount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->quantity);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->termType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->termValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->dateFrom);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->dateTill);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Limit');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->otherType !== null) {
      $xfer += $output->writeFieldBegin('otherType', TType::STRING, 2);
      $xfer += $output->writeString($this->otherType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->amount !== null) {
      $xfer += $output->writeFieldBegin('amount', TType::I64, 3);
      $xfer += $output->writeI64($this->amount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->quantity !== null) {
      $xfer += $output->writeFieldBegin('quantity', TType::I16, 4);
      $xfer += $output->writeI16($this->quantity);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->termType !== null) {
      $xfer += $output->writeFieldBegin('termType', TType::I32, 5);
      $xfer += $output->writeI32($this->termType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->termValue !== null) {
      $xfer += $output->writeFieldBegin('termValue', TType::I16, 6);
      $xfer += $output->writeI16($this->termValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dateFrom !== null) {
      $xfer += $output->writeFieldBegin('dateFrom', TType::I64, 7);
      $xfer += $output->writeI64($this->dateFrom);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dateTill !== null) {
      $xfer += $output->writeFieldBegin('dateTill', TType::I64, 8);
      $xfer += $output->writeI64($this->dateTill);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Card settings.
 * First of all there are security settings for card.
 * 
 */
class CardSettings {
  static $_TSPEC;

  /**
   * Are MOTO (Mail Order / Telephone Order) transactions allowed (usually it has same value with ecommerceOperationsEnabled)
   * 
   * @var bool
   */
  public $motoOperationsEnabled = null;
  /**
   * Are e-commerce transactions allowed
   * 
   * @var bool
   */
  public $ecommerceOperationsEnabled = null;
  /**
   * В операциях "card not present" (это e-commerce (интернет) операции, MO/TO (Mail order/Telephone order) операции)
   * используется специальный доп-код, именуемый CVC2 (mastercard) или CVV2 (visa).
   * Проверка этого кода является опциональной. Если значение поля true, то сервер банка требует для операции этот код,
   * если false, то торговец может его не передавать, и тогда банк пропустит операцию (однако, если
   * cardNotPresentCodeVerificationEnabled=false, а торговец передает этот код, то он будет проверен)
   * 
   * 
   * @var bool
   */
  public $cardNotPresentCodeVerificationEnabled = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'motoOperationsEnabled',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'ecommerceOperationsEnabled',
          'type' => TType::BOOL,
          ),
        3 => array(
          'var' => 'cardNotPresentCodeVerificationEnabled',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['motoOperationsEnabled'])) {
        $this->motoOperationsEnabled = $vals['motoOperationsEnabled'];
      }
      if (isset($vals['ecommerceOperationsEnabled'])) {
        $this->ecommerceOperationsEnabled = $vals['ecommerceOperationsEnabled'];
      }
      if (isset($vals['cardNotPresentCodeVerificationEnabled'])) {
        $this->cardNotPresentCodeVerificationEnabled = $vals['cardNotPresentCodeVerificationEnabled'];
      }
    }
  }

  public function getName() {
    return 'CardSettings';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->motoOperationsEnabled);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->ecommerceOperationsEnabled);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->cardNotPresentCodeVerificationEnabled);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CardSettings');
    if ($this->motoOperationsEnabled !== null) {
      $xfer += $output->writeFieldBegin('motoOperationsEnabled', TType::BOOL, 1);
      $xfer += $output->writeBool($this->motoOperationsEnabled);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ecommerceOperationsEnabled !== null) {
      $xfer += $output->writeFieldBegin('ecommerceOperationsEnabled', TType::BOOL, 2);
      $xfer += $output->writeBool($this->ecommerceOperationsEnabled);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cardNotPresentCodeVerificationEnabled !== null) {
      $xfer += $output->writeFieldBegin('cardNotPresentCodeVerificationEnabled', TType::BOOL, 3);
      $xfer += $output->writeBool($this->cardNotPresentCodeVerificationEnabled);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Карта (пластиковая или виртуальная), выпущенная в рамках карточного договора <CardContract>
 */
class Card {
  static $_TSPEC;

  /**
   * Маска номера карты, может отображаться клиенту в UI, всегда строго 4 цифры, 8 "звездочек" и 4 цифры: "5574********0233"
   * 
   * @var string
   */
  public $cardNumberMask = null;
  /**
   * Do not save! And do not display at UI.
   * Need only make a payment or to display the generated virtual card, if necessary.
   * When sending to external systems often this field is blank
   * 
   * @var string
   */
  public $cardNumber = null;
  /**
   * Месяц завершения действия карты. Две цифры, например "01" или "12", но не может быть меньше "01" или больше "12"
   * 
   * @var string
   */
  public $expiryMonth = null;
  /**
   * Год завершения действия карты. Четыре цифры, например "2013" или "2017"
   * 
   * @var string
   */
  public $expiryYear = null;
  /**
   * 20-26 больших латинских букв или пробелов, точек, дефисов, например "FEDOR LEBED-KUMACH"
   * 
   * @var string
   */
  public $ownerName = null;
  /**
   * Статус карты, в первую очередь следует отображать активна или нет
   * 
   * @var int
   */
  public $status = null;
  /**
   * Текст, описывающий статус, например "stop-list" или "expired"
   * 
   * @var string
   */
  public $statusName = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * список лимитов, действующих для этой карты
   * 
   * @var \Limit[]
   */
  public $limits = null;
  /**
   * @var \CardSettings
   */
  public $settings = null;
  /**
   * Unique identifier of the card at the BANK
   * 
   * @var string
   */
  public $id = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cardNumberMask',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'cardNumber',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'expiryMonth',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'expiryYear',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'ownerName',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'status',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'statusName',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        9 => array(
          'var' => 'limits',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Limit',
            ),
          ),
        10 => array(
          'var' => 'settings',
          'type' => TType::STRUCT,
          'class' => '\CardSettings',
          ),
        11 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['cardNumberMask'])) {
        $this->cardNumberMask = $vals['cardNumberMask'];
      }
      if (isset($vals['cardNumber'])) {
        $this->cardNumber = $vals['cardNumber'];
      }
      if (isset($vals['expiryMonth'])) {
        $this->expiryMonth = $vals['expiryMonth'];
      }
      if (isset($vals['expiryYear'])) {
        $this->expiryYear = $vals['expiryYear'];
      }
      if (isset($vals['ownerName'])) {
        $this->ownerName = $vals['ownerName'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['statusName'])) {
        $this->statusName = $vals['statusName'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['limits'])) {
        $this->limits = $vals['limits'];
      }
      if (isset($vals['settings'])) {
        $this->settings = $vals['settings'];
      }
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
    }
  }

  public function getName() {
    return 'Card';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->cardNumberMask);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->cardNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expiryMonth);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expiryYear);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->ownerName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->statusName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::LST) {
            $this->limits = array();
            $_size9 = 0;
            $_etype12 = 0;
            $xfer += $input->readListBegin($_etype12, $_size9);
            for ($_i13 = 0; $_i13 < $_size9; ++$_i13)
            {
              $elem14 = null;
              $elem14 = new \Limit();
              $xfer += $elem14->read($input);
              $this->limits []= $elem14;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->settings = new \CardSettings();
            $xfer += $this->settings->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Card');
    if ($this->cardNumberMask !== null) {
      $xfer += $output->writeFieldBegin('cardNumberMask', TType::STRING, 1);
      $xfer += $output->writeString($this->cardNumberMask);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cardNumber !== null) {
      $xfer += $output->writeFieldBegin('cardNumber', TType::STRING, 2);
      $xfer += $output->writeString($this->cardNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expiryMonth !== null) {
      $xfer += $output->writeFieldBegin('expiryMonth', TType::STRING, 3);
      $xfer += $output->writeString($this->expiryMonth);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expiryYear !== null) {
      $xfer += $output->writeFieldBegin('expiryYear', TType::STRING, 4);
      $xfer += $output->writeString($this->expiryYear);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ownerName !== null) {
      $xfer += $output->writeFieldBegin('ownerName', TType::STRING, 5);
      $xfer += $output->writeString($this->ownerName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::I32, 6);
      $xfer += $output->writeI32($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->statusName !== null) {
      $xfer += $output->writeFieldBegin('statusName', TType::STRING, 7);
      $xfer += $output->writeString($this->statusName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 8);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->limits !== null) {
      if (!is_array($this->limits)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('limits', TType::LST, 9);
      {
        $output->writeListBegin(TType::STRUCT, count($this->limits));
        {
          foreach ($this->limits as $iter15)
          {
            $xfer += $iter15->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->settings !== null) {
      if (!is_object($this->settings)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('settings', TType::STRUCT, 10);
      $xfer += $this->settings->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 11);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Набор атрибутов договора клиента на обслуживание карточного счета
 */
class CardContract {
  static $_TSPEC;

  /**
   * Уникальный в банке идентификатор договора (legalNumber в общем случае не уникален)
   * 
   * @var string
   */
  public $id = null;
  /**
   * Юридический номер договор Банка с Клиентом на обслуживание карточного счета, карт и связанных с ними доп-услуг (кредитные линии и т.п.)
   * 
   * @var string
   */
  public $legalNumber = null;
  /**
   * Код продукта/субпродукта, присваиваемый банковской учетной системой. Отличается от productSystemKey тем, что последний присваивается каталогом продуктов Ibank, а не банком
   * 
   * @var string
   */
  public $subproductCode = null;
  /**
   * @var string
   */
  public $mainAccountNumber = null;
  /**
   * @var string
   */
  public $mainAccountCurrency = null;
  /**
   * Баланс средств на основном счете. Это не то, что называется "доступно средств", т.к. не включает кредитный лимит. Если есть несанкционированный овердрафт, то баланс должен быть отрицательным.
   * 
   * @var int
   */
  public $balance = null;
  /**
   * Дата начала действия договора
   * 
   * @var string
   */
  public $startDate = null;
  /**
   * @var string
   */
  public $endDate = null;
  /**
   * @var int
   */
  public $creditLimit = null;
  /**
   * @var int
   */
  public $usedCreditLimit = null;
  /**
   * @var \Card[]
   */
  public $cards = null;
  /**
   * Номер тарифа в тарифном сборнике
   * 
   * @var string
   */
  public $rateId = null;
  /**
   * @var string
   */
  public $savingAccountNumber = null;
  /**
   * @var int
   */
  public $savingAccountBalance = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * Присвоенное каталогом продуктов Ibank имя этого продукта
   * 
   * @var string
   */
  public $productTitle = null;
  /**
   * Присвоенное каталогом продуктов Ibank системное имя этого продукта, которое может использоваться в rules.xml для определения правил операций с этим контрактом этого типа продукта
   * 
   * @var string
   */
  public $productSystemKey = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'legalNumber',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'subproductCode',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'mainAccountNumber',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'mainAccountCurrency',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'balance',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'startDate',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'endDate',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'creditLimit',
          'type' => TType::I64,
          ),
        10 => array(
          'var' => 'usedCreditLimit',
          'type' => TType::I64,
          ),
        11 => array(
          'var' => 'cards',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Card',
            ),
          ),
        12 => array(
          'var' => 'rateId',
          'type' => TType::STRING,
          ),
        13 => array(
          'var' => 'savingAccountNumber',
          'type' => TType::STRING,
          ),
        14 => array(
          'var' => 'savingAccountBalance',
          'type' => TType::I64,
          ),
        15 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        16 => array(
          'var' => 'productTitle',
          'type' => TType::STRING,
          ),
        17 => array(
          'var' => 'productSystemKey',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['legalNumber'])) {
        $this->legalNumber = $vals['legalNumber'];
      }
      if (isset($vals['subproductCode'])) {
        $this->subproductCode = $vals['subproductCode'];
      }
      if (isset($vals['mainAccountNumber'])) {
        $this->mainAccountNumber = $vals['mainAccountNumber'];
      }
      if (isset($vals['mainAccountCurrency'])) {
        $this->mainAccountCurrency = $vals['mainAccountCurrency'];
      }
      if (isset($vals['balance'])) {
        $this->balance = $vals['balance'];
      }
      if (isset($vals['startDate'])) {
        $this->startDate = $vals['startDate'];
      }
      if (isset($vals['endDate'])) {
        $this->endDate = $vals['endDate'];
      }
      if (isset($vals['creditLimit'])) {
        $this->creditLimit = $vals['creditLimit'];
      }
      if (isset($vals['usedCreditLimit'])) {
        $this->usedCreditLimit = $vals['usedCreditLimit'];
      }
      if (isset($vals['cards'])) {
        $this->cards = $vals['cards'];
      }
      if (isset($vals['rateId'])) {
        $this->rateId = $vals['rateId'];
      }
      if (isset($vals['savingAccountNumber'])) {
        $this->savingAccountNumber = $vals['savingAccountNumber'];
      }
      if (isset($vals['savingAccountBalance'])) {
        $this->savingAccountBalance = $vals['savingAccountBalance'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['productTitle'])) {
        $this->productTitle = $vals['productTitle'];
      }
      if (isset($vals['productSystemKey'])) {
        $this->productSystemKey = $vals['productSystemKey'];
      }
    }
  }

  public function getName() {
    return 'CardContract';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->legalNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->subproductCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->mainAccountNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->mainAccountCurrency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->balance);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->endDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->creditLimit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->usedCreditLimit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::LST) {
            $this->cards = array();
            $_size16 = 0;
            $_etype19 = 0;
            $xfer += $input->readListBegin($_etype19, $_size16);
            for ($_i20 = 0; $_i20 < $_size16; ++$_i20)
            {
              $elem21 = null;
              $elem21 = new \Card();
              $xfer += $elem21->read($input);
              $this->cards []= $elem21;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->rateId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->savingAccountNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->savingAccountBalance);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->productTitle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 17:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->productSystemKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CardContract');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->legalNumber !== null) {
      $xfer += $output->writeFieldBegin('legalNumber', TType::STRING, 2);
      $xfer += $output->writeString($this->legalNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subproductCode !== null) {
      $xfer += $output->writeFieldBegin('subproductCode', TType::STRING, 3);
      $xfer += $output->writeString($this->subproductCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mainAccountNumber !== null) {
      $xfer += $output->writeFieldBegin('mainAccountNumber', TType::STRING, 4);
      $xfer += $output->writeString($this->mainAccountNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mainAccountCurrency !== null) {
      $xfer += $output->writeFieldBegin('mainAccountCurrency', TType::STRING, 5);
      $xfer += $output->writeString($this->mainAccountCurrency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->balance !== null) {
      $xfer += $output->writeFieldBegin('balance', TType::I64, 6);
      $xfer += $output->writeI64($this->balance);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startDate !== null) {
      $xfer += $output->writeFieldBegin('startDate', TType::STRING, 7);
      $xfer += $output->writeString($this->startDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endDate !== null) {
      $xfer += $output->writeFieldBegin('endDate', TType::STRING, 8);
      $xfer += $output->writeString($this->endDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->creditLimit !== null) {
      $xfer += $output->writeFieldBegin('creditLimit', TType::I64, 9);
      $xfer += $output->writeI64($this->creditLimit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->usedCreditLimit !== null) {
      $xfer += $output->writeFieldBegin('usedCreditLimit', TType::I64, 10);
      $xfer += $output->writeI64($this->usedCreditLimit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cards !== null) {
      if (!is_array($this->cards)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('cards', TType::LST, 11);
      {
        $output->writeListBegin(TType::STRUCT, count($this->cards));
        {
          foreach ($this->cards as $iter22)
          {
            $xfer += $iter22->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rateId !== null) {
      $xfer += $output->writeFieldBegin('rateId', TType::STRING, 12);
      $xfer += $output->writeString($this->rateId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->savingAccountNumber !== null) {
      $xfer += $output->writeFieldBegin('savingAccountNumber', TType::STRING, 13);
      $xfer += $output->writeString($this->savingAccountNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->savingAccountBalance !== null) {
      $xfer += $output->writeFieldBegin('savingAccountBalance', TType::I64, 14);
      $xfer += $output->writeI64($this->savingAccountBalance);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 15);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->productTitle !== null) {
      $xfer += $output->writeFieldBegin('productTitle', TType::STRING, 16);
      $xfer += $output->writeString($this->productTitle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->productSystemKey !== null) {
      $xfer += $output->writeFieldBegin('productSystemKey', TType::STRING, 17);
      $xfer += $output->writeString($this->productSystemKey);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Набор атрибутов договора клиента на обслуживание карточного счета
 */
class DepositContract {
  static $_TSPEC;

  /**
   * Уникальный в банке идентификатор договора (legalNumber в общем случае не уникален)
   * 
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $legalNumber = null;
  /**
   * Код продукта/субпродукта, присваиваемый банковской учетной системой. Отличается от productSystemKey тем, что последний присваивается каталогом продуктов Ibank, а не банком
   * 
   * @var string
   */
  public $subproductCode = null;
  /**
   * @var string
   */
  public $mainAccountNumber = null;
  /**
   * @var string
   */
  public $mainAccountCurrency = null;
  /**
   * @var int
   */
  public $balance = null;
  /**
   * Дата начала действия договора
   * 
   * @var string
   */
  public $startDate = null;
  /**
   * Дата окончания действия договора. Если дата в прошлом, договор считается закрытым.
   * 
   * @var string
   */
  public $endDate = null;
  /**
   * Текущая процентная ставка
   * 
   * @var double
   */
  public $currentInterestRate = null;
  /**
   * Срок депозитной сделки
   * 
   * @var \ContractTerm
   */
  public $term = null;
  /**
   * Сумма начиленных процентов
   * 
   * @var int
   */
  public $accruedInterest = null;
  /**
   * Разрешено ли пополнение депозита
   * 
   * @var bool
   */
  public $refillAllowed = null;
  /**
   * Минимальное возможное пополнение депозита
   * 
   * @var int
   */
  public $minRefillAmount = null;
  /**
   * Минимальное возможное пополнение депозита
   * 
   * @var int
   */
  public $maxRefillAmount = null;
  /**
   * Разрешено ли досрочное снятие средств
   * 
   * @var bool
   */
  public $earlyWithdrawlAllowed = null;
  /**
   * Лимит средств, разрешенных к досрочному снятию в валюте основного счета
   * 
   * @var int
   */
  public $earlyWithdrawlLimit = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * Присвоенное каталогом продуктов Ibank имя этого продукта
   * 
   * @var string
   */
  public $productTitle = null;
  /**
   * Присвоенное каталогом продуктов Ibank системное имя этого продукта, которое может использоваться в rules.xml для определения правил операций с этим контрактом этого типа продукта
   * 
   * @var string
   */
  public $productSystemKey = null;
  /**
   * Если предполагается ежемесячная (или "еже-периодная") выплата процентов
   * 
   * @var bool
   */
  public $regularInterestPayment = null;
  /**
   * Если в договоре включена опция капитализации: начисленные проценты сразу прибавляются к телу депозита и в следующий период проценты начисляются с учетом процентов, начисленных за прошлый период
   * 
   * @var bool
   */
  public $capitalization = null;
  /**
   * Включена ли авто-пролонгация (опция при которой депозитная сделка автоматически продляется)
   * 
   * @var bool
   */
  public $autoProlongationEnabled = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'legalNumber',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'subproductCode',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'mainAccountNumber',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'mainAccountCurrency',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'balance',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'startDate',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'endDate',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'currentInterestRate',
          'type' => TType::DOUBLE,
          ),
        10 => array(
          'var' => 'term',
          'type' => TType::STRUCT,
          'class' => '\ContractTerm',
          ),
        11 => array(
          'var' => 'accruedInterest',
          'type' => TType::I64,
          ),
        12 => array(
          'var' => 'refillAllowed',
          'type' => TType::BOOL,
          ),
        13 => array(
          'var' => 'minRefillAmount',
          'type' => TType::I64,
          ),
        14 => array(
          'var' => 'maxRefillAmount',
          'type' => TType::I64,
          ),
        15 => array(
          'var' => 'earlyWithdrawlAllowed',
          'type' => TType::BOOL,
          ),
        16 => array(
          'var' => 'earlyWithdrawlLimit',
          'type' => TType::I64,
          ),
        17 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        18 => array(
          'var' => 'productTitle',
          'type' => TType::STRING,
          ),
        19 => array(
          'var' => 'productSystemKey',
          'type' => TType::STRING,
          ),
        20 => array(
          'var' => 'regularInterestPayment',
          'type' => TType::BOOL,
          ),
        21 => array(
          'var' => 'capitalization',
          'type' => TType::BOOL,
          ),
        22 => array(
          'var' => 'autoProlongationEnabled',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['legalNumber'])) {
        $this->legalNumber = $vals['legalNumber'];
      }
      if (isset($vals['subproductCode'])) {
        $this->subproductCode = $vals['subproductCode'];
      }
      if (isset($vals['mainAccountNumber'])) {
        $this->mainAccountNumber = $vals['mainAccountNumber'];
      }
      if (isset($vals['mainAccountCurrency'])) {
        $this->mainAccountCurrency = $vals['mainAccountCurrency'];
      }
      if (isset($vals['balance'])) {
        $this->balance = $vals['balance'];
      }
      if (isset($vals['startDate'])) {
        $this->startDate = $vals['startDate'];
      }
      if (isset($vals['endDate'])) {
        $this->endDate = $vals['endDate'];
      }
      if (isset($vals['currentInterestRate'])) {
        $this->currentInterestRate = $vals['currentInterestRate'];
      }
      if (isset($vals['term'])) {
        $this->term = $vals['term'];
      }
      if (isset($vals['accruedInterest'])) {
        $this->accruedInterest = $vals['accruedInterest'];
      }
      if (isset($vals['refillAllowed'])) {
        $this->refillAllowed = $vals['refillAllowed'];
      }
      if (isset($vals['minRefillAmount'])) {
        $this->minRefillAmount = $vals['minRefillAmount'];
      }
      if (isset($vals['maxRefillAmount'])) {
        $this->maxRefillAmount = $vals['maxRefillAmount'];
      }
      if (isset($vals['earlyWithdrawlAllowed'])) {
        $this->earlyWithdrawlAllowed = $vals['earlyWithdrawlAllowed'];
      }
      if (isset($vals['earlyWithdrawlLimit'])) {
        $this->earlyWithdrawlLimit = $vals['earlyWithdrawlLimit'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['productTitle'])) {
        $this->productTitle = $vals['productTitle'];
      }
      if (isset($vals['productSystemKey'])) {
        $this->productSystemKey = $vals['productSystemKey'];
      }
      if (isset($vals['regularInterestPayment'])) {
        $this->regularInterestPayment = $vals['regularInterestPayment'];
      }
      if (isset($vals['capitalization'])) {
        $this->capitalization = $vals['capitalization'];
      }
      if (isset($vals['autoProlongationEnabled'])) {
        $this->autoProlongationEnabled = $vals['autoProlongationEnabled'];
      }
    }
  }

  public function getName() {
    return 'DepositContract';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->legalNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->subproductCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->mainAccountNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->mainAccountCurrency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->balance);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->endDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->currentInterestRate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->term = new \ContractTerm();
            $xfer += $this->term->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->accruedInterest);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->refillAllowed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->minRefillAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxRefillAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->earlyWithdrawlAllowed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->earlyWithdrawlLimit);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 17:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 18:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->productTitle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 19:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->productSystemKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 20:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->regularInterestPayment);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 21:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->capitalization);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 22:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->autoProlongationEnabled);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DepositContract');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->legalNumber !== null) {
      $xfer += $output->writeFieldBegin('legalNumber', TType::STRING, 2);
      $xfer += $output->writeString($this->legalNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subproductCode !== null) {
      $xfer += $output->writeFieldBegin('subproductCode', TType::STRING, 3);
      $xfer += $output->writeString($this->subproductCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mainAccountNumber !== null) {
      $xfer += $output->writeFieldBegin('mainAccountNumber', TType::STRING, 4);
      $xfer += $output->writeString($this->mainAccountNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mainAccountCurrency !== null) {
      $xfer += $output->writeFieldBegin('mainAccountCurrency', TType::STRING, 5);
      $xfer += $output->writeString($this->mainAccountCurrency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->balance !== null) {
      $xfer += $output->writeFieldBegin('balance', TType::I64, 6);
      $xfer += $output->writeI64($this->balance);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startDate !== null) {
      $xfer += $output->writeFieldBegin('startDate', TType::STRING, 7);
      $xfer += $output->writeString($this->startDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endDate !== null) {
      $xfer += $output->writeFieldBegin('endDate', TType::STRING, 8);
      $xfer += $output->writeString($this->endDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currentInterestRate !== null) {
      $xfer += $output->writeFieldBegin('currentInterestRate', TType::DOUBLE, 9);
      $xfer += $output->writeDouble($this->currentInterestRate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->term !== null) {
      if (!is_object($this->term)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('term', TType::STRUCT, 10);
      $xfer += $this->term->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accruedInterest !== null) {
      $xfer += $output->writeFieldBegin('accruedInterest', TType::I64, 11);
      $xfer += $output->writeI64($this->accruedInterest);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->refillAllowed !== null) {
      $xfer += $output->writeFieldBegin('refillAllowed', TType::BOOL, 12);
      $xfer += $output->writeBool($this->refillAllowed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minRefillAmount !== null) {
      $xfer += $output->writeFieldBegin('minRefillAmount', TType::I64, 13);
      $xfer += $output->writeI64($this->minRefillAmount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxRefillAmount !== null) {
      $xfer += $output->writeFieldBegin('maxRefillAmount', TType::I64, 14);
      $xfer += $output->writeI64($this->maxRefillAmount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->earlyWithdrawlAllowed !== null) {
      $xfer += $output->writeFieldBegin('earlyWithdrawlAllowed', TType::BOOL, 15);
      $xfer += $output->writeBool($this->earlyWithdrawlAllowed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->earlyWithdrawlLimit !== null) {
      $xfer += $output->writeFieldBegin('earlyWithdrawlLimit', TType::I64, 16);
      $xfer += $output->writeI64($this->earlyWithdrawlLimit);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 17);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->productTitle !== null) {
      $xfer += $output->writeFieldBegin('productTitle', TType::STRING, 18);
      $xfer += $output->writeString($this->productTitle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->productSystemKey !== null) {
      $xfer += $output->writeFieldBegin('productSystemKey', TType::STRING, 19);
      $xfer += $output->writeString($this->productSystemKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->regularInterestPayment !== null) {
      $xfer += $output->writeFieldBegin('regularInterestPayment', TType::BOOL, 20);
      $xfer += $output->writeBool($this->regularInterestPayment);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->capitalization !== null) {
      $xfer += $output->writeFieldBegin('capitalization', TType::BOOL, 21);
      $xfer += $output->writeBool($this->capitalization);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->autoProlongationEnabled !== null) {
      $xfer += $output->writeFieldBegin('autoProlongationEnabled', TType::BOOL, 22);
      $xfer += $output->writeBool($this->autoProlongationEnabled);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Настройки и опции депозитного договора, которые можно изменить / настроить.
 * 
 */
class DepositSettings {
  static $_TSPEC;

  /**
   * Включить или отключить пролонгацию.
   * 
   * @var bool
   */
  public $autoProlongationEnabled = null;
  /**
   * Атрибуты для реализации специализированных настроек действий интеграционного слоя
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'autoProlongationEnabled',
          'type' => TType::BOOL,
          ),
        20 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['autoProlongationEnabled'])) {
        $this->autoProlongationEnabled = $vals['autoProlongationEnabled'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'DepositSettings';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->autoProlongationEnabled);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 20:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DepositSettings');
    if ($this->autoProlongationEnabled !== null) {
      $xfer += $output->writeFieldBegin('autoProlongationEnabled', TType::BOOL, 1);
      $xfer += $output->writeBool($this->autoProlongationEnabled);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 20);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Набор параметров для фильтрации выбираемых условий депозитных продуктов.
 * Другими словами, фильтр поиска в каталоге депозитов. Используется в методе fetchDepositConditions()
 * 
 */
class DepositConditionsFilter {
  static $_TSPEC;

  /**
   * Валюта, если пустая, может быть любая валюта
   * 
   * @var string
   */
  public $currency = null;
  /**
   * Минимальный срок
   * 
   * @var \ContractTerm
   */
  public $minTerm = null;
  /**
   * Максимальный срок. Если сроки имеют разный тип,
   * и сравнивается, например min=365 дней, max=1 год, то логика остается на усмотрение
   * реализации интеграционного слоя банка. Проверка по умолчанию сравнивает в количестве дней
   * исходя из того что в году 365, в месяце 30, а неделе 7, в квартале 3*30 = 90 дней
   * 
   * 
   * @var \ContractTerm
   */
  public $maxTerm = null;
  /**
   * Фильтр на то, разрешео ли пополнение (да/нет/неважно)
   * 
   * @var int
   */
  public $refillAllowed = null;
  /**
   * Фильтр на то, разрешео ли досрочное снятие без штрафных санкций (да/нет/неважно)
   * 
   * @var int
   */
  public $earlyWithdrawlAllowed = null;
  /**
   * Фильтр на то, выплачиваются ли проценты регулярно, а не в конце (да/нет/неважно)
   * 
   * @var int
   */
  public $regularInterestPayment = null;
  /**
   * Фильтр на то, осуществляется ли выплата процентов в счет основной суммы сделки с последующим перерасчетом ("капитализация процентов") (да/нет/неважно)
   * 
   * @var int
   */
  public $capitalization = null;
  /**
   * Для расширения параметров поиска для случаев конкретной реализации интеграционного слоя
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'minTerm',
          'type' => TType::STRUCT,
          'class' => '\ContractTerm',
          ),
        3 => array(
          'var' => 'maxTerm',
          'type' => TType::STRUCT,
          'class' => '\ContractTerm',
          ),
        4 => array(
          'var' => 'refillAllowed',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'earlyWithdrawlAllowed',
          'type' => TType::I32,
          ),
        6 => array(
          'var' => 'regularInterestPayment',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'capitalization',
          'type' => TType::I32,
          ),
        20 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['minTerm'])) {
        $this->minTerm = $vals['minTerm'];
      }
      if (isset($vals['maxTerm'])) {
        $this->maxTerm = $vals['maxTerm'];
      }
      if (isset($vals['refillAllowed'])) {
        $this->refillAllowed = $vals['refillAllowed'];
      }
      if (isset($vals['earlyWithdrawlAllowed'])) {
        $this->earlyWithdrawlAllowed = $vals['earlyWithdrawlAllowed'];
      }
      if (isset($vals['regularInterestPayment'])) {
        $this->regularInterestPayment = $vals['regularInterestPayment'];
      }
      if (isset($vals['capitalization'])) {
        $this->capitalization = $vals['capitalization'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'DepositConditionsFilter';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->minTerm = new \ContractTerm();
            $xfer += $this->minTerm->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->maxTerm = new \ContractTerm();
            $xfer += $this->maxTerm->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->refillAllowed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->earlyWithdrawlAllowed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->regularInterestPayment);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->capitalization);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 20:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DepositConditionsFilter');
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 1);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minTerm !== null) {
      if (!is_object($this->minTerm)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('minTerm', TType::STRUCT, 2);
      $xfer += $this->minTerm->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxTerm !== null) {
      if (!is_object($this->maxTerm)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('maxTerm', TType::STRUCT, 3);
      $xfer += $this->maxTerm->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->refillAllowed !== null) {
      $xfer += $output->writeFieldBegin('refillAllowed', TType::I32, 4);
      $xfer += $output->writeI32($this->refillAllowed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->earlyWithdrawlAllowed !== null) {
      $xfer += $output->writeFieldBegin('earlyWithdrawlAllowed', TType::I32, 5);
      $xfer += $output->writeI32($this->earlyWithdrawlAllowed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->regularInterestPayment !== null) {
      $xfer += $output->writeFieldBegin('regularInterestPayment', TType::I32, 6);
      $xfer += $output->writeI32($this->regularInterestPayment);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->capitalization !== null) {
      $xfer += $output->writeFieldBegin('capitalization', TType::I32, 7);
      $xfer += $output->writeI32($this->capitalization);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 20);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Условия депозита, который предполагается открыть.
 * Содержит ссылку на идентификатор, который определяет желаемый к отркытию депозитный продукт,
 * а также опциональные продуктовые условия, которые, в зависимости от способа реализации интеграционного слоя,
 * дополняют (параметризируют) этот выбранный в productId продукт.
 * 
 */
class DepositConditions {
  static $_TSPEC;

  /**
   * * Идентификатор депозитного продукта, который будет открыт.
   *  * В некоторых случаях (если в банке этот идентификатор жестко определяет срок,
   *  * ставку и прочие условия) это единственный обязательный параметр.
   * *
   * 
   * @var string
   */
  public $productId = null;
  /**
   * Счет/договор, на который будут перечислены проценты и куда будет возвращено "тело"
   * * при закрытии депозита. Опциональный, т.к. по умолчанию это счет, с которого была
   *  * списана сумма на открытие депозита.
   * *
   * 
   * @var \ContractReference
   */
  public $destinationContract = null;
  /**
   * Валюта открываемого депозита. Может быть опущена, тогда подразумевается валюта счета / контракта
   * с которого списывается основная сумма при открытии депозита.
   * 
   * 
   * @var string
   */
  public $currency = null;
  /**
   * Дата, с которой депозитная сделка должна быть открыта. По умолчанию ближайший день. Формат dd.MM.yyyy
   * 
   * @var string
   */
  public $startDate = null;
  /**
   *  * Процентная ставка.
   * * Этот параметр и все ниже -- определяют наиболее типовые условия депозита, которые могут быть либо
   * * "включены" в productId, либо, если указаны, то они уточняют условия в рамках productId.
   * *
   * 
   * @var double
   */
  public $interestRate = null;
  /**
   * Срок депозита
   * 
   * @var \ContractTerm
   */
  public $term = null;
  /**
   * Разрешено ли пополнение депозита
   * 
   * @var bool
   */
  public $refillAllowed = null;
  /**
   * Разрешено ли досрочное снятие средств
   * 
   * @var bool
   */
  public $earlyWithdrawlAllowed = null;
  /**
   * Если предполагается ежемесячная (или "еже-периодная") выплата процентов
   * 
   * @var bool
   */
  public $regularInterestPayment = null;
  /**
   * Если в договоре включена опция капитализации: начисленные проценты сразу прибавляются к телу депозита и в следующий период проценты начисляются с учетом процентов, начисленных за прошлый период
   * 
   * @var bool
   */
  public $capitalization = null;
  /**
   * Прочие аттрибуты, которые могут варьироваться в зависимости от реализации интеграционого слоя с банком
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'productId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'destinationContract',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        3 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'startDate',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'interestRate',
          'type' => TType::DOUBLE,
          ),
        6 => array(
          'var' => 'term',
          'type' => TType::STRUCT,
          'class' => '\ContractTerm',
          ),
        7 => array(
          'var' => 'refillAllowed',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'earlyWithdrawlAllowed',
          'type' => TType::BOOL,
          ),
        9 => array(
          'var' => 'regularInterestPayment',
          'type' => TType::BOOL,
          ),
        10 => array(
          'var' => 'capitalization',
          'type' => TType::BOOL,
          ),
        11 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['productId'])) {
        $this->productId = $vals['productId'];
      }
      if (isset($vals['destinationContract'])) {
        $this->destinationContract = $vals['destinationContract'];
      }
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['startDate'])) {
        $this->startDate = $vals['startDate'];
      }
      if (isset($vals['interestRate'])) {
        $this->interestRate = $vals['interestRate'];
      }
      if (isset($vals['term'])) {
        $this->term = $vals['term'];
      }
      if (isset($vals['refillAllowed'])) {
        $this->refillAllowed = $vals['refillAllowed'];
      }
      if (isset($vals['earlyWithdrawlAllowed'])) {
        $this->earlyWithdrawlAllowed = $vals['earlyWithdrawlAllowed'];
      }
      if (isset($vals['regularInterestPayment'])) {
        $this->regularInterestPayment = $vals['regularInterestPayment'];
      }
      if (isset($vals['capitalization'])) {
        $this->capitalization = $vals['capitalization'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'DepositConditions';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->productId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->destinationContract = new \ContractReference();
            $xfer += $this->destinationContract->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->interestRate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->term = new \ContractTerm();
            $xfer += $this->term->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->refillAllowed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->earlyWithdrawlAllowed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->regularInterestPayment);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->capitalization);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DepositConditions');
    if ($this->productId !== null) {
      $xfer += $output->writeFieldBegin('productId', TType::STRING, 1);
      $xfer += $output->writeString($this->productId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->destinationContract !== null) {
      if (!is_object($this->destinationContract)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('destinationContract', TType::STRUCT, 2);
      $xfer += $this->destinationContract->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 3);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startDate !== null) {
      $xfer += $output->writeFieldBegin('startDate', TType::STRING, 4);
      $xfer += $output->writeString($this->startDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->interestRate !== null) {
      $xfer += $output->writeFieldBegin('interestRate', TType::DOUBLE, 5);
      $xfer += $output->writeDouble($this->interestRate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->term !== null) {
      if (!is_object($this->term)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('term', TType::STRUCT, 6);
      $xfer += $this->term->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->refillAllowed !== null) {
      $xfer += $output->writeFieldBegin('refillAllowed', TType::BOOL, 7);
      $xfer += $output->writeBool($this->refillAllowed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->earlyWithdrawlAllowed !== null) {
      $xfer += $output->writeFieldBegin('earlyWithdrawlAllowed', TType::BOOL, 8);
      $xfer += $output->writeBool($this->earlyWithdrawlAllowed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->regularInterestPayment !== null) {
      $xfer += $output->writeFieldBegin('regularInterestPayment', TType::BOOL, 9);
      $xfer += $output->writeBool($this->regularInterestPayment);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->capitalization !== null) {
      $xfer += $output->writeFieldBegin('capitalization', TType::BOOL, 10);
      $xfer += $output->writeBool($this->capitalization);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 11);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Структура платежа по кредиту, содержащая либо просто общую сумму и опционально дату, в которую платеж должен быть совершен, либо также детализацию: проценты, тело, коммиссия
 */
class CreditPaymentInfo {
  static $_TSPEC;

  /**
   * Общая сумма к погашению, если указаны все остальные поля, то должна быть равна сумме interestAmount + bodyAmount + comissionAmount
   * 
   * @var int
   */
  public $totalAmount = null;
  /**
   * Сумма по процентам
   * 
   * @var int
   */
  public $interestAmount = null;
  /**
   * Сумма по "телу"
   * 
   * @var int
   */
  public $bodyAmount = null;
  /**
   * Сумма всех дополнительных коммиссий
   * 
   * @var int
   */
  public $comissionAmount = null;
  /**
   * Дата, в которую платеж должен быть совершен
   * 
   * @var string
   */
  public $paymentDate = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'totalAmount',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'interestAmount',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'bodyAmount',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'comissionAmount',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'paymentDate',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['totalAmount'])) {
        $this->totalAmount = $vals['totalAmount'];
      }
      if (isset($vals['interestAmount'])) {
        $this->interestAmount = $vals['interestAmount'];
      }
      if (isset($vals['bodyAmount'])) {
        $this->bodyAmount = $vals['bodyAmount'];
      }
      if (isset($vals['comissionAmount'])) {
        $this->comissionAmount = $vals['comissionAmount'];
      }
      if (isset($vals['paymentDate'])) {
        $this->paymentDate = $vals['paymentDate'];
      }
    }
  }

  public function getName() {
    return 'CreditPaymentInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->totalAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->interestAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->bodyAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->comissionAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->paymentDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreditPaymentInfo');
    if ($this->totalAmount !== null) {
      $xfer += $output->writeFieldBegin('totalAmount', TType::I64, 1);
      $xfer += $output->writeI64($this->totalAmount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->interestAmount !== null) {
      $xfer += $output->writeFieldBegin('interestAmount', TType::I64, 2);
      $xfer += $output->writeI64($this->interestAmount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bodyAmount !== null) {
      $xfer += $output->writeFieldBegin('bodyAmount', TType::I64, 3);
      $xfer += $output->writeI64($this->bodyAmount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->comissionAmount !== null) {
      $xfer += $output->writeFieldBegin('comissionAmount', TType::I64, 4);
      $xfer += $output->writeI64($this->comissionAmount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->paymentDate !== null) {
      $xfer += $output->writeFieldBegin('paymentDate', TType::STRING, 5);
      $xfer += $output->writeString($this->paymentDate);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreditContract {
  static $_TSPEC;

  /**
   * Уникальный в банке идентификатор договора (legalNumber в общем случае не уникален)
   * 
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $legalNumber = null;
  /**
   * Код продукта/субпродукта, присваиваемый банковской учетной системой. Отличается от productSystemKey тем, что последний присваивается каталогом продуктов Ibank, а не банком
   * 
   * @var string
   */
  public $subproductCode = null;
  /**
   * @var string
   */
  public $mainAccountNumber = null;
  /**
   * @var string
   */
  public $mainAccountCurrency = null;
  /**
   * Отрицательное число: остаток кредита по "телу", т.е. без процентов
   * 
   * @var int
   */
  public $balance = null;
  /**
   * Дата начала действия договора
   * 
   * @var string
   */
  public $startDate = null;
  /**
   * @var string
   */
  public $endDate = null;
  /**
   * @var double
   */
  public $currentInterestRate = null;
  /**
   * @var \CreditPaymentInfo
   */
  public $nextPaymentAmount = null;
  /**
   * Размер штрафных санкций. Например, если клиент не оплатил, то он должен оплатить unauthorizedDebt + penalty
   * 
   * @var int
   */
  public $penalty = null;
  /**
   * Размер несанкционированной задолженности
   * 
   * @var \CreditPaymentInfo
   */
  public $unauthorizedDept = null;
  /**
   * Сколько я должен принести чтобы закрыть кредит завтра
   * 
   * @var int
   */
  public $totalDept = null;
  /**
   * Номер тарифа в тарифном сборнике
   * 
   * @var string
   */
  public $rateId = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * Присвоенное каталогом продуктов Ibank имя этого продукта
   * 
   * @var string
   */
  public $productTitle = null;
  /**
   * Присвоенное каталогом продуктов Ibank системное имя этого продукта, которое может использоваться в rules.xml для определения правил операций с этим контрактом этого типа продукта
   * 
   * @var string
   */
  public $productSystemKey = null;
  /**
   * Баланс на счете погашения, который может использоваться банком для накопления средств от клиента до момента ежемесячного распределения
   * 
   * @var int
   */
  public $tempBalance = null;
  /**
   * Первоначальный размер сделки (положительное число)
   * 
   * @var int
   */
  public $dealAmount = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'legalNumber',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'subproductCode',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'mainAccountNumber',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'mainAccountCurrency',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'balance',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'startDate',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'endDate',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'currentInterestRate',
          'type' => TType::DOUBLE,
          ),
        10 => array(
          'var' => 'nextPaymentAmount',
          'type' => TType::STRUCT,
          'class' => '\CreditPaymentInfo',
          ),
        11 => array(
          'var' => 'penalty',
          'type' => TType::I64,
          ),
        12 => array(
          'var' => 'unauthorizedDept',
          'type' => TType::STRUCT,
          'class' => '\CreditPaymentInfo',
          ),
        13 => array(
          'var' => 'totalDept',
          'type' => TType::I64,
          ),
        14 => array(
          'var' => 'rateId',
          'type' => TType::STRING,
          ),
        15 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        16 => array(
          'var' => 'productTitle',
          'type' => TType::STRING,
          ),
        17 => array(
          'var' => 'productSystemKey',
          'type' => TType::STRING,
          ),
        18 => array(
          'var' => 'tempBalance',
          'type' => TType::I64,
          ),
        19 => array(
          'var' => 'dealAmount',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['legalNumber'])) {
        $this->legalNumber = $vals['legalNumber'];
      }
      if (isset($vals['subproductCode'])) {
        $this->subproductCode = $vals['subproductCode'];
      }
      if (isset($vals['mainAccountNumber'])) {
        $this->mainAccountNumber = $vals['mainAccountNumber'];
      }
      if (isset($vals['mainAccountCurrency'])) {
        $this->mainAccountCurrency = $vals['mainAccountCurrency'];
      }
      if (isset($vals['balance'])) {
        $this->balance = $vals['balance'];
      }
      if (isset($vals['startDate'])) {
        $this->startDate = $vals['startDate'];
      }
      if (isset($vals['endDate'])) {
        $this->endDate = $vals['endDate'];
      }
      if (isset($vals['currentInterestRate'])) {
        $this->currentInterestRate = $vals['currentInterestRate'];
      }
      if (isset($vals['nextPaymentAmount'])) {
        $this->nextPaymentAmount = $vals['nextPaymentAmount'];
      }
      if (isset($vals['penalty'])) {
        $this->penalty = $vals['penalty'];
      }
      if (isset($vals['unauthorizedDept'])) {
        $this->unauthorizedDept = $vals['unauthorizedDept'];
      }
      if (isset($vals['totalDept'])) {
        $this->totalDept = $vals['totalDept'];
      }
      if (isset($vals['rateId'])) {
        $this->rateId = $vals['rateId'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['productTitle'])) {
        $this->productTitle = $vals['productTitle'];
      }
      if (isset($vals['productSystemKey'])) {
        $this->productSystemKey = $vals['productSystemKey'];
      }
      if (isset($vals['tempBalance'])) {
        $this->tempBalance = $vals['tempBalance'];
      }
      if (isset($vals['dealAmount'])) {
        $this->dealAmount = $vals['dealAmount'];
      }
    }
  }

  public function getName() {
    return 'CreditContract';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->legalNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->subproductCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->mainAccountNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->mainAccountCurrency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->balance);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->startDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->endDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->currentInterestRate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->nextPaymentAmount = new \CreditPaymentInfo();
            $xfer += $this->nextPaymentAmount->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->penalty);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRUCT) {
            $this->unauthorizedDept = new \CreditPaymentInfo();
            $xfer += $this->unauthorizedDept->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->totalDept);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->rateId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->productTitle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 17:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->productSystemKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 18:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->tempBalance);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 19:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->dealAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreditContract');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->legalNumber !== null) {
      $xfer += $output->writeFieldBegin('legalNumber', TType::STRING, 2);
      $xfer += $output->writeString($this->legalNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subproductCode !== null) {
      $xfer += $output->writeFieldBegin('subproductCode', TType::STRING, 3);
      $xfer += $output->writeString($this->subproductCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mainAccountNumber !== null) {
      $xfer += $output->writeFieldBegin('mainAccountNumber', TType::STRING, 4);
      $xfer += $output->writeString($this->mainAccountNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mainAccountCurrency !== null) {
      $xfer += $output->writeFieldBegin('mainAccountCurrency', TType::STRING, 5);
      $xfer += $output->writeString($this->mainAccountCurrency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->balance !== null) {
      $xfer += $output->writeFieldBegin('balance', TType::I64, 6);
      $xfer += $output->writeI64($this->balance);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startDate !== null) {
      $xfer += $output->writeFieldBegin('startDate', TType::STRING, 7);
      $xfer += $output->writeString($this->startDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endDate !== null) {
      $xfer += $output->writeFieldBegin('endDate', TType::STRING, 8);
      $xfer += $output->writeString($this->endDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currentInterestRate !== null) {
      $xfer += $output->writeFieldBegin('currentInterestRate', TType::DOUBLE, 9);
      $xfer += $output->writeDouble($this->currentInterestRate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nextPaymentAmount !== null) {
      if (!is_object($this->nextPaymentAmount)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('nextPaymentAmount', TType::STRUCT, 10);
      $xfer += $this->nextPaymentAmount->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->penalty !== null) {
      $xfer += $output->writeFieldBegin('penalty', TType::I64, 11);
      $xfer += $output->writeI64($this->penalty);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->unauthorizedDept !== null) {
      if (!is_object($this->unauthorizedDept)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('unauthorizedDept', TType::STRUCT, 12);
      $xfer += $this->unauthorizedDept->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->totalDept !== null) {
      $xfer += $output->writeFieldBegin('totalDept', TType::I64, 13);
      $xfer += $output->writeI64($this->totalDept);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rateId !== null) {
      $xfer += $output->writeFieldBegin('rateId', TType::STRING, 14);
      $xfer += $output->writeString($this->rateId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 15);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->productTitle !== null) {
      $xfer += $output->writeFieldBegin('productTitle', TType::STRING, 16);
      $xfer += $output->writeString($this->productTitle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->productSystemKey !== null) {
      $xfer += $output->writeFieldBegin('productSystemKey', TType::STRING, 17);
      $xfer += $output->writeString($this->productSystemKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tempBalance !== null) {
      $xfer += $output->writeFieldBegin('tempBalance', TType::I64, 18);
      $xfer += $output->writeI64($this->tempBalance);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dealAmount !== null) {
      $xfer += $output->writeFieldBegin('dealAmount', TType::I64, 19);
      $xfer += $output->writeI64($this->dealAmount);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Тег: метка, которая может быть прикреплена к сущностям Ibank, в частности к операциям и другим.
 */
class Tag {
  static $_TSPEC;

  /**
   * @var string
   */
  public $tagName = null;
  /**
   * @var string
   */
  public $parentTagName = null;
  /**
   * @var string
   */
  public $title = null;
  /**
   * @var string
   */
  public $iconRef = null;
  /**
   * @var string
   */
  public $color = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tagName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'parentTagName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'title',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'iconRef',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'color',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tagName'])) {
        $this->tagName = $vals['tagName'];
      }
      if (isset($vals['parentTagName'])) {
        $this->parentTagName = $vals['parentTagName'];
      }
      if (isset($vals['title'])) {
        $this->title = $vals['title'];
      }
      if (isset($vals['iconRef'])) {
        $this->iconRef = $vals['iconRef'];
      }
      if (isset($vals['color'])) {
        $this->color = $vals['color'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'Tag';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->parentTagName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->title);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->iconRef);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->color);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Tag');
    if ($this->tagName !== null) {
      $xfer += $output->writeFieldBegin('tagName', TType::STRING, 1);
      $xfer += $output->writeString($this->tagName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parentTagName !== null) {
      $xfer += $output->writeFieldBegin('parentTagName', TType::STRING, 2);
      $xfer += $output->writeString($this->parentTagName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->title !== null) {
      $xfer += $output->writeFieldBegin('title', TType::STRING, 3);
      $xfer += $output->writeString($this->title);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->iconRef !== null) {
      $xfer += $output->writeFieldBegin('iconRef', TType::STRING, 4);
      $xfer += $output->writeString($this->iconRef);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->color !== null) {
      $xfer += $output->writeFieldBegin('color', TType::STRING, 5);
      $xfer += $output->writeString($this->color);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 6);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Значение курса валюты. Валюта определяется запросом, эта структура определяет только его значение, а также уточняет в какой интервал времени оно было актуально.
 */
class CurrencyExchangeRate {
  static $_TSPEC;

  /**
   * код валюты
   * 
   * @var string
   */
  public $currency = null;
  /**
   * значение величины курса “покупка”
   * 
   * @var double
   */
  public $buyRate = null;
  /**
   * значение величины курса “продажа”
   * 
   * @var double
   */
  public $sellRate = null;
  /**
   * дата и время установки (опционально)
   * 
   * @var int
   */
  public $startDate = null;
  /**
   * дата и время завершения действия (оционально)
   * 
   * @var int
   */
  public $endDate = null;
  /**
   * аттрибуты (велика вероятность что для разных случаев понадобятся "приросты" и т.п.)
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'buyRate',
          'type' => TType::DOUBLE,
          ),
        3 => array(
          'var' => 'sellRate',
          'type' => TType::DOUBLE,
          ),
        4 => array(
          'var' => 'startDate',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'endDate',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['buyRate'])) {
        $this->buyRate = $vals['buyRate'];
      }
      if (isset($vals['sellRate'])) {
        $this->sellRate = $vals['sellRate'];
      }
      if (isset($vals['startDate'])) {
        $this->startDate = $vals['startDate'];
      }
      if (isset($vals['endDate'])) {
        $this->endDate = $vals['endDate'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'CurrencyExchangeRate';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->buyRate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->sellRate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->startDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->endDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CurrencyExchangeRate');
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 1);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->buyRate !== null) {
      $xfer += $output->writeFieldBegin('buyRate', TType::DOUBLE, 2);
      $xfer += $output->writeDouble($this->buyRate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sellRate !== null) {
      $xfer += $output->writeFieldBegin('sellRate', TType::DOUBLE, 3);
      $xfer += $output->writeDouble($this->sellRate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->startDate !== null) {
      $xfer += $output->writeFieldBegin('startDate', TType::I64, 4);
      $xfer += $output->writeI64($this->startDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->endDate !== null) {
      $xfer += $output->writeFieldBegin('endDate', TType::I64, 5);
      $xfer += $output->writeI64($this->endDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 6);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Элемент, используемый для инкапсуляции типичных агрегированных данных отчетов
 */
class AgregatedReportItem {
  static $_TSPEC;

  /**
   * sum() в случае если это финансовые данные, сумма денег
   * 
   * @var int
   */
  public $totalMoney = null;
  /**
   * count() чего бы то ни было
   * 
   * @var int
   */
  public $quantity = null;
  /**
   * среднее значение, будь то финансовые данные (в копейках!) или другие
   * 
   * @var double
   */
  public $average = null;
  /**
   * sum() если данные не финансовые (не деньги в копейках, а например проценты или что-то еще), то используется это поле
   * 
   * @var double
   */
  public $totalAmount = null;
  /**
   * full tag information
   * 
   * @var \Tag
   */
  public $tag = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'totalMoney',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'quantity',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'average',
          'type' => TType::DOUBLE,
          ),
        4 => array(
          'var' => 'totalAmount',
          'type' => TType::DOUBLE,
          ),
        5 => array(
          'var' => 'tag',
          'type' => TType::STRUCT,
          'class' => '\Tag',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['totalMoney'])) {
        $this->totalMoney = $vals['totalMoney'];
      }
      if (isset($vals['quantity'])) {
        $this->quantity = $vals['quantity'];
      }
      if (isset($vals['average'])) {
        $this->average = $vals['average'];
      }
      if (isset($vals['totalAmount'])) {
        $this->totalAmount = $vals['totalAmount'];
      }
      if (isset($vals['tag'])) {
        $this->tag = $vals['tag'];
      }
    }
  }

  public function getName() {
    return 'AgregatedReportItem';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->totalMoney);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->quantity);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->average);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->totalAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->tag = new \Tag();
            $xfer += $this->tag->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AgregatedReportItem');
    if ($this->totalMoney !== null) {
      $xfer += $output->writeFieldBegin('totalMoney', TType::I64, 1);
      $xfer += $output->writeI64($this->totalMoney);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->quantity !== null) {
      $xfer += $output->writeFieldBegin('quantity', TType::I64, 2);
      $xfer += $output->writeI64($this->quantity);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->average !== null) {
      $xfer += $output->writeFieldBegin('average', TType::DOUBLE, 3);
      $xfer += $output->writeDouble($this->average);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->totalAmount !== null) {
      $xfer += $output->writeFieldBegin('totalAmount', TType::DOUBLE, 4);
      $xfer += $output->writeDouble($this->totalAmount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tag !== null) {
      if (!is_object($this->tag)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tag', TType::STRUCT, 5);
      $xfer += $this->tag->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Служебный элемент для отчетности, определяет простейший отчет
 * об операциях.
 * Предоставляет возможность давать общие данные или разбитые по категориям
 */
class CategorizedReportItem {
  static $_TSPEC;

  /**
   * @var array
   */
  public $categories = null;
  /**
   * @var \AgregatedReportItem
   */
  public $totals = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'categories',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\AgregatedReportItem',
            ),
          ),
        2 => array(
          'var' => 'totals',
          'type' => TType::STRUCT,
          'class' => '\AgregatedReportItem',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['categories'])) {
        $this->categories = $vals['categories'];
      }
      if (isset($vals['totals'])) {
        $this->totals = $vals['totals'];
      }
    }
  }

  public function getName() {
    return 'CategorizedReportItem';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->categories = array();
            $_size23 = 0;
            $_ktype24 = 0;
            $_vtype25 = 0;
            $xfer += $input->readMapBegin($_ktype24, $_vtype25, $_size23);
            for ($_i27 = 0; $_i27 < $_size23; ++$_i27)
            {
              $key28 = '';
              $val29 = new \AgregatedReportItem();
              $xfer += $input->readString($key28);
              $val29 = new \AgregatedReportItem();
              $xfer += $val29->read($input);
              $this->categories[$key28] = $val29;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->totals = new \AgregatedReportItem();
            $xfer += $this->totals->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CategorizedReportItem');
    if ($this->categories !== null) {
      if (!is_array($this->categories)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('categories', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->categories));
        {
          foreach ($this->categories as $kiter30 => $viter31)
          {
            $xfer += $output->writeString($kiter30);
            $xfer += $viter31->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->totals !== null) {
      if (!is_object($this->totals)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('totals', TType::STRUCT, 2);
      $xfer += $this->totals->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Отчет за указанный период.
 * Описывает тип, и значение периода (январь 2014 или 1й квартал 2012) и сам отчет, включающий категории и агрегированные значения по ним (в типе periodReport)
 */
class FinancialFlowPeriodReport {
  static $_TSPEC;

  /**
   * @var int
   */
  public $periodType = null;
  /**
   * @var \TermValue
   */
  public $periodValue = null;
  /**
   * @var array
   */
  public $reportData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'periodType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'periodValue',
          'type' => TType::STRUCT,
          'class' => '\TermValue',
          ),
        3 => array(
          'var' => 'reportData',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\CategorizedReportItem',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['periodType'])) {
        $this->periodType = $vals['periodType'];
      }
      if (isset($vals['periodValue'])) {
        $this->periodValue = $vals['periodValue'];
      }
      if (isset($vals['reportData'])) {
        $this->reportData = $vals['reportData'];
      }
    }
  }

  public function getName() {
    return 'FinancialFlowPeriodReport';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->periodType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->periodValue = new \TermValue();
            $xfer += $this->periodValue->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::MAP) {
            $this->reportData = array();
            $_size32 = 0;
            $_ktype33 = 0;
            $_vtype34 = 0;
            $xfer += $input->readMapBegin($_ktype33, $_vtype34, $_size32);
            for ($_i36 = 0; $_i36 < $_size32; ++$_i36)
            {
              $key37 = '';
              $val38 = new \CategorizedReportItem();
              $xfer += $input->readString($key37);
              $val38 = new \CategorizedReportItem();
              $xfer += $val38->read($input);
              $this->reportData[$key37] = $val38;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FinancialFlowPeriodReport');
    if ($this->periodType !== null) {
      $xfer += $output->writeFieldBegin('periodType', TType::I32, 1);
      $xfer += $output->writeI32($this->periodType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->periodValue !== null) {
      if (!is_object($this->periodValue)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('periodValue', TType::STRUCT, 2);
      $xfer += $this->periodValue->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->reportData !== null) {
      if (!is_array($this->reportData)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('reportData', TType::MAP, 3);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->reportData));
        {
          foreach ($this->reportData as $kiter39 => $viter40)
          {
            $xfer += $output->writeString($kiter39);
            $xfer += $viter40->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Отчет о финансовом потоке (cash flow, financial flow), предоставляет массив периодов, для каждого из которых есть отчет по периоду (см. FinancialFlowPeriod -- агрегированные данные (сумма, количество, пр.) может включать разбивку по категориям).
 */
class FinancialFlowReport {
  static $_TSPEC;

  /**
   * @var \FinancialFlowPeriodReport[]
   */
  public $flow = null;
  /**
   * @var int
   */
  public $periodsType = null;
  /**
   * @var int
   */
  public $actualOnDate = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'flow',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\FinancialFlowPeriodReport',
            ),
          ),
        2 => array(
          'var' => 'periodsType',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'actualOnDate',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['flow'])) {
        $this->flow = $vals['flow'];
      }
      if (isset($vals['periodsType'])) {
        $this->periodsType = $vals['periodsType'];
      }
      if (isset($vals['actualOnDate'])) {
        $this->actualOnDate = $vals['actualOnDate'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'FinancialFlowReport';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->flow = array();
            $_size41 = 0;
            $_etype44 = 0;
            $xfer += $input->readListBegin($_etype44, $_size41);
            for ($_i45 = 0; $_i45 < $_size41; ++$_i45)
            {
              $elem46 = null;
              $elem46 = new \FinancialFlowPeriodReport();
              $xfer += $elem46->read($input);
              $this->flow []= $elem46;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->periodsType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->actualOnDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FinancialFlowReport');
    if ($this->flow !== null) {
      if (!is_array($this->flow)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('flow', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->flow));
        {
          foreach ($this->flow as $iter47)
          {
            $xfer += $iter47->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->periodsType !== null) {
      $xfer += $output->writeFieldBegin('periodsType', TType::I32, 2);
      $xfer += $output->writeI32($this->periodsType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->actualOnDate !== null) {
      $xfer += $output->writeFieldBegin('actualOnDate', TType::I64, 3);
      $xfer += $output->writeI64($this->actualOnDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 4);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Данные клиента, передаваемые для того чтобы получить разные виды аутентификации. <br>
 * В данный момент поддерживаются типы наборов данных, описанные в AuthCredentialsType. В зависимости от того какой тип выбирает клиент, обязательность передаваемых полей меняется: <br>
 * LOGINPASSWORD: обязательны логин и пароль, остальные игнорируются <br>
 * OTP: обязателен только OTP <br>
 * DEVICE: обязательны только логин и пароль, device может передаваться или нет в зависимости от реализации сервера аутентификации
 */
class AuthCredentials {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var string
   */
  public $login = null;
  /**
   * @var string
   */
  public $password = null;
  /**
   * @var string
   */
  public $otp = null;
  /**
   * @var string
   */
  public $device = null;
  /**
   * @var string
   */
  public $token = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'login',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'password',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'otp',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'device',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'token',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['login'])) {
        $this->login = $vals['login'];
      }
      if (isset($vals['password'])) {
        $this->password = $vals['password'];
      }
      if (isset($vals['otp'])) {
        $this->otp = $vals['otp'];
      }
      if (isset($vals['device'])) {
        $this->device = $vals['device'];
      }
      if (isset($vals['token'])) {
        $this->token = $vals['token'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'AuthCredentials';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->login);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->password);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->otp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->device);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->token);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AuthCredentials');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->login !== null) {
      $xfer += $output->writeFieldBegin('login', TType::STRING, 2);
      $xfer += $output->writeString($this->login);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->password !== null) {
      $xfer += $output->writeFieldBegin('password', TType::STRING, 3);
      $xfer += $output->writeString($this->password);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->otp !== null) {
      $xfer += $output->writeFieldBegin('otp', TType::STRING, 4);
      $xfer += $output->writeString($this->otp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->device !== null) {
      $xfer += $output->writeFieldBegin('device', TType::STRING, 5);
      $xfer += $output->writeString($this->device);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->token !== null) {
      $xfer += $output->writeFieldBegin('token', TType::STRING, 6);
      $xfer += $output->writeString($this->token);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 7);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Challenge {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var string
   */
  public $message = null;
  /**
   * @var string
   */
  public $challengeId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'challengeId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
      if (isset($vals['challengeId'])) {
        $this->challengeId = $vals['challengeId'];
      }
    }
  }

  public function getName() {
    return 'Challenge';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->challengeId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Challenge');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 2);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->challengeId !== null) {
      $xfer += $output->writeFieldBegin('challengeId', TType::STRING, 3);
      $xfer += $output->writeString($this->challengeId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Role {
  static $_TSPEC;

  /**
   * @var string
   */
  public $code = null;
  /**
   * @var string
   */
  public $description = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'code',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['code'])) {
        $this->code = $vals['code'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
    }
  }

  public function getName() {
    return 'Role';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->code);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Role');
    if ($this->code !== null) {
      $xfer += $output->writeFieldBegin('code', TType::STRING, 1);
      $xfer += $output->writeString($this->code);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 2);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * TODO: вернуть имя ваучера, а также добавить способ активации и
 * маску телефона или e-mail-а: клиент должен видеть что-то в духе
 * "Вы хотите активировать услугу $suretyrecord_name, чтобы активировать
 *  вам необходимо получить SMS на телефон $phone_mask
 * 
 */
class SuretyRecord {
  static $_TSPEC;

  /**
   * @var \Role[]
   */
  public $roles = null;
  /**
   * @var int
   */
  public $activationChannelType = null;
  /**
   * @var string
   */
  public $activatoinAddressMask = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'roles',
          'type' => TType::SET,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Role',
            ),
          ),
        2 => array(
          'var' => 'activationChannelType',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'activatoinAddressMask',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['roles'])) {
        $this->roles = $vals['roles'];
      }
      if (isset($vals['activationChannelType'])) {
        $this->activationChannelType = $vals['activationChannelType'];
      }
      if (isset($vals['activatoinAddressMask'])) {
        $this->activatoinAddressMask = $vals['activatoinAddressMask'];
      }
    }
  }

  public function getName() {
    return 'SuretyRecord';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::SET) {
            $this->roles = array();
            $_size48 = 0;
            $_etype51 = 0;
            $xfer += $input->readSetBegin($_etype51, $_size48);
            for ($_i52 = 0; $_i52 < $_size48; ++$_i52)
            {
              $elem53 = null;
              $elem53 = new \Role();
              $xfer += $elem53->read($input);
              if (is_scalar($elem53)) {
                $this->roles[$elem53] = true;
              } else {
                $this->roles []= $elem53;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->activationChannelType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->activatoinAddressMask);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SuretyRecord');
    if ($this->roles !== null) {
      if (!is_array($this->roles)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('roles', TType::SET, 1);
      {
        $output->writeSetBegin(TType::STRUCT, count($this->roles));
        {
          foreach ($this->roles as $iter54 => $iter55)
          {
            if (is_scalar($iter55)) {
            $xfer += $iter54->write($output);
            } else {
            $xfer += $iter55->write($output);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->activationChannelType !== null) {
      $xfer += $output->writeFieldBegin('activationChannelType', TType::I32, 2);
      $xfer += $output->writeI32($this->activationChannelType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->activatoinAddressMask !== null) {
      $xfer += $output->writeFieldBegin('activatoinAddressMask', TType::STRING, 3);
      $xfer += $output->writeString($this->activatoinAddressMask);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Информация о клиенте, как правило владельце сессии.
 */
class UserInfo {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var string
   */
  public $fullName = null;
  /**
   * @var string
   */
  public $email = null;
  /**
   * @var string
   */
  public $phone = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'fullName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'email',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'phone',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['fullName'])) {
        $this->fullName = $vals['fullName'];
      }
      if (isset($vals['email'])) {
        $this->email = $vals['email'];
      }
      if (isset($vals['phone'])) {
        $this->phone = $vals['phone'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'UserInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->fullName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->email);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->phone);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UserInfo');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->fullName !== null) {
      $xfer += $output->writeFieldBegin('fullName', TType::STRING, 2);
      $xfer += $output->writeString($this->fullName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->email !== null) {
      $xfer += $output->writeFieldBegin('email', TType::STRING, 3);
      $xfer += $output->writeString($this->email);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->phone !== null) {
      $xfer += $output->writeFieldBegin('phone', TType::STRING, 4);
      $xfer += $output->writeString($this->phone);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 5);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Данные сессии, которая создается в результате регистрации или аутентификации.
 * Также данные сессии можно получить (без продления даты expireDate) методом getAuthSession() или методом refreshAuthSession() (с продлением даты expireDate)
 */
class AuthSession {
  static $_TSPEC;

  /**
   * @var string
   */
  public $token = null;
  /**
   * @var int
   */
  public $expireDate = null;
  /**
   * @var int
   */
  public $creationDate = null;
  /**
   * @var int
   */
  public $updateDate = null;
  /**
   * @var \Role[]
   */
  public $roles = null;
  /**
   * @var \UserInfo
   */
  public $userInfo = null;
  /**
   * Информирует о текущем уровне аутентификации с учетом возможной просрочки времени действия расширенных уровней аутентификации (расширенных -- отличных от SIMPLE)
   * 
   * @var int
   */
  public $level = null;
  /**
   * Срок действия текущего уровня аутентификации. Если level=SIMPLE, то совпадает с датой expireDate, если нет, то может отличаться от нее в меньшую сторону (дата expireDate всегда расширяется при операциях или refreshAuthSession()
   * 
   * @var int
   */
  public $levelExpireDate = null;
  /**
   * @var \Attributes
   */
  public $sessionAttributes = null;
  /**
   * @var \Attributes
   */
  public $profileAttributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'token',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'expireDate',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'creationDate',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'updateDate',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'roles',
          'type' => TType::SET,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Role',
            ),
          ),
        6 => array(
          'var' => 'userInfo',
          'type' => TType::STRUCT,
          'class' => '\UserInfo',
          ),
        7 => array(
          'var' => 'level',
          'type' => TType::I32,
          ),
        8 => array(
          'var' => 'levelExpireDate',
          'type' => TType::I64,
          ),
        9 => array(
          'var' => 'sessionAttributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        10 => array(
          'var' => 'profileAttributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['token'])) {
        $this->token = $vals['token'];
      }
      if (isset($vals['expireDate'])) {
        $this->expireDate = $vals['expireDate'];
      }
      if (isset($vals['creationDate'])) {
        $this->creationDate = $vals['creationDate'];
      }
      if (isset($vals['updateDate'])) {
        $this->updateDate = $vals['updateDate'];
      }
      if (isset($vals['roles'])) {
        $this->roles = $vals['roles'];
      }
      if (isset($vals['userInfo'])) {
        $this->userInfo = $vals['userInfo'];
      }
      if (isset($vals['level'])) {
        $this->level = $vals['level'];
      }
      if (isset($vals['levelExpireDate'])) {
        $this->levelExpireDate = $vals['levelExpireDate'];
      }
      if (isset($vals['sessionAttributes'])) {
        $this->sessionAttributes = $vals['sessionAttributes'];
      }
      if (isset($vals['profileAttributes'])) {
        $this->profileAttributes = $vals['profileAttributes'];
      }
    }
  }

  public function getName() {
    return 'AuthSession';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->token);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->expireDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->creationDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->updateDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::SET) {
            $this->roles = array();
            $_size56 = 0;
            $_etype59 = 0;
            $xfer += $input->readSetBegin($_etype59, $_size56);
            for ($_i60 = 0; $_i60 < $_size56; ++$_i60)
            {
              $elem61 = null;
              $elem61 = new \Role();
              $xfer += $elem61->read($input);
              if (is_scalar($elem61)) {
                $this->roles[$elem61] = true;
              } else {
                $this->roles []= $elem61;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->userInfo = new \UserInfo();
            $xfer += $this->userInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->level);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->levelExpireDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRUCT) {
            $this->sessionAttributes = new \Attributes();
            $xfer += $this->sessionAttributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->profileAttributes = new \Attributes();
            $xfer += $this->profileAttributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AuthSession');
    if ($this->token !== null) {
      $xfer += $output->writeFieldBegin('token', TType::STRING, 1);
      $xfer += $output->writeString($this->token);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expireDate !== null) {
      $xfer += $output->writeFieldBegin('expireDate', TType::I64, 2);
      $xfer += $output->writeI64($this->expireDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->creationDate !== null) {
      $xfer += $output->writeFieldBegin('creationDate', TType::I64, 3);
      $xfer += $output->writeI64($this->creationDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->updateDate !== null) {
      $xfer += $output->writeFieldBegin('updateDate', TType::I64, 4);
      $xfer += $output->writeI64($this->updateDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->roles !== null) {
      if (!is_array($this->roles)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('roles', TType::SET, 5);
      {
        $output->writeSetBegin(TType::STRUCT, count($this->roles));
        {
          foreach ($this->roles as $iter62 => $iter63)
          {
            if (is_scalar($iter63)) {
            $xfer += $iter62->write($output);
            } else {
            $xfer += $iter63->write($output);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->userInfo !== null) {
      if (!is_object($this->userInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userInfo', TType::STRUCT, 6);
      $xfer += $this->userInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->level !== null) {
      $xfer += $output->writeFieldBegin('level', TType::I32, 7);
      $xfer += $output->writeI32($this->level);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->levelExpireDate !== null) {
      $xfer += $output->writeFieldBegin('levelExpireDate', TType::I64, 8);
      $xfer += $output->writeI64($this->levelExpireDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sessionAttributes !== null) {
      if (!is_object($this->sessionAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('sessionAttributes', TType::STRUCT, 9);
      $xfer += $this->sessionAttributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->profileAttributes !== null) {
      if (!is_object($this->profileAttributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('profileAttributes', TType::STRUCT, 10);
      $xfer += $this->profileAttributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Fields for user registration.
 */
class UserRegistrationForm {
  static $_TSPEC;

  /**
   * Login which user want to use
   * 
   * @var string
   */
  public $login = null;
  /**
   * Password which user want to use. 'Repeat Password' confirmation validation is part of frontend-client logic. Here expected validated final password.
   * 
   * @var string
   */
  public $password = null;
  /**
   * First name, e.g. Johann
   * 
   * @var string
   */
  public $firstName = null;
  /**
   * Last name, e.g. Bach
   * 
   * @var string
   */
  public $lastName = null;
  /**
   * Middle name, e.g. Sebastian
   * 
   * @var string
   */
  public $middleName = null;
  /**
   * E-mail
   * 
   * @var string
   */
  public $email = null;
  /**
   * Mobile phone
   * 
   * @var string
   */
  public $phone = null;
  /**
   * Extenstion attributes: name-value pairs; will be forwarded to Integration Layer auth server when creating user credentials; will NOT be stored in user profile(!)
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'login',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'password',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'firstName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'lastName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'middleName',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'email',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'phone',
          'type' => TType::STRING,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['login'])) {
        $this->login = $vals['login'];
      }
      if (isset($vals['password'])) {
        $this->password = $vals['password'];
      }
      if (isset($vals['firstName'])) {
        $this->firstName = $vals['firstName'];
      }
      if (isset($vals['lastName'])) {
        $this->lastName = $vals['lastName'];
      }
      if (isset($vals['middleName'])) {
        $this->middleName = $vals['middleName'];
      }
      if (isset($vals['email'])) {
        $this->email = $vals['email'];
      }
      if (isset($vals['phone'])) {
        $this->phone = $vals['phone'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'UserRegistrationForm';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->login);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->password);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->firstName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->lastName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->middleName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->email);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->phone);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UserRegistrationForm');
    if ($this->login !== null) {
      $xfer += $output->writeFieldBegin('login', TType::STRING, 1);
      $xfer += $output->writeString($this->login);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->password !== null) {
      $xfer += $output->writeFieldBegin('password', TType::STRING, 2);
      $xfer += $output->writeString($this->password);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->firstName !== null) {
      $xfer += $output->writeFieldBegin('firstName', TType::STRING, 3);
      $xfer += $output->writeString($this->firstName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastName !== null) {
      $xfer += $output->writeFieldBegin('lastName', TType::STRING, 4);
      $xfer += $output->writeString($this->lastName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->middleName !== null) {
      $xfer += $output->writeFieldBegin('middleName', TType::STRING, 5);
      $xfer += $output->writeString($this->middleName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->email !== null) {
      $xfer += $output->writeFieldBegin('email', TType::STRING, 6);
      $xfer += $output->writeString($this->email);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->phone !== null) {
      $xfer += $output->writeFieldBegin('phone', TType::STRING, 7);
      $xfer += $output->writeString($this->phone);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Fields for binding back-end contragent to current user.
 * Used in UserRegistration service
 */
class ContragentToUserBindingForm {
  static $_TSPEC;

  /**
   * Contragent identifier type, e.g. DEAL_NUMBER or ACCOUNT_NUMBER
   * 
   * @var int
   */
  public $identifierType = null;
  /**
   * Contragent identifier
   * 
   * @var string
   */
  public $identifier = null;
  /**
   * Contragent birth date: if given, integration layer must check it as extended validation (because customer can easyly give wrong contract number by typo)
   * 
   * @var int
   */
  public $birthday = null;
  /**
   * Extenstion attributes: name-value pairs; will be forwarded to Integration Layer auth server when creating user credentials; will NOT be stored in user profile(!)
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'identifierType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'identifier',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'birthday',
          'type' => TType::I64,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['identifierType'])) {
        $this->identifierType = $vals['identifierType'];
      }
      if (isset($vals['identifier'])) {
        $this->identifier = $vals['identifier'];
      }
      if (isset($vals['birthday'])) {
        $this->birthday = $vals['birthday'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'ContragentToUserBindingForm';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->identifierType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->identifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->birthday);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ContragentToUserBindingForm');
    if ($this->identifierType !== null) {
      $xfer += $output->writeFieldBegin('identifierType', TType::I32, 1);
      $xfer += $output->writeI32($this->identifierType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->identifier !== null) {
      $xfer += $output->writeFieldBegin('identifier', TType::STRING, 2);
      $xfer += $output->writeString($this->identifier);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->birthday !== null) {
      $xfer += $output->writeFieldBegin('birthday', TType::I64, 3);
      $xfer += $output->writeI64($this->birthday);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class PasswordResetForm {
  static $_TSPEC;

  /**
   * @var string
   */
  public $clientIdentifier = null;
  /**
   * @var int
   */
  public $birthday = null;
  /**
   * @var int
   */
  public $identifierType = null;
  /**
   * @var string
   */
  public $login = null;
  /**
   * @var string
   */
  public $email = null;
  /**
   * @var string
   */
  public $phone = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'clientIdentifier',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'birthday',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'identifierType',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'login',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'email',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'phone',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['clientIdentifier'])) {
        $this->clientIdentifier = $vals['clientIdentifier'];
      }
      if (isset($vals['birthday'])) {
        $this->birthday = $vals['birthday'];
      }
      if (isset($vals['identifierType'])) {
        $this->identifierType = $vals['identifierType'];
      }
      if (isset($vals['login'])) {
        $this->login = $vals['login'];
      }
      if (isset($vals['email'])) {
        $this->email = $vals['email'];
      }
      if (isset($vals['phone'])) {
        $this->phone = $vals['phone'];
      }
    }
  }

  public function getName() {
    return 'PasswordResetForm';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->clientIdentifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->birthday);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->identifierType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->login);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->email);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->phone);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PasswordResetForm');
    if ($this->clientIdentifier !== null) {
      $xfer += $output->writeFieldBegin('clientIdentifier', TType::STRING, 1);
      $xfer += $output->writeString($this->clientIdentifier);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->birthday !== null) {
      $xfer += $output->writeFieldBegin('birthday', TType::I64, 2);
      $xfer += $output->writeI64($this->birthday);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->identifierType !== null) {
      $xfer += $output->writeFieldBegin('identifierType', TType::I32, 3);
      $xfer += $output->writeI32($this->identifierType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->login !== null) {
      $xfer += $output->writeFieldBegin('login', TType::STRING, 4);
      $xfer += $output->writeString($this->login);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->email !== null) {
      $xfer += $output->writeFieldBegin('email', TType::STRING, 5);
      $xfer += $output->writeString($this->email);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->phone !== null) {
      $xfer += $output->writeFieldBegin('phone', TType::STRING, 6);
      $xfer += $output->writeString($this->phone);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ChangePasswordForm {
  static $_TSPEC;

  /**
   * @var string
   */
  public $oldPassword = null;
  /**
   * @var string
   */
  public $newPassword = null;
  /**
   * @var string
   */
  public $confirmPassword = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'oldPassword',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'newPassword',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'confirmPassword',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['oldPassword'])) {
        $this->oldPassword = $vals['oldPassword'];
      }
      if (isset($vals['newPassword'])) {
        $this->newPassword = $vals['newPassword'];
      }
      if (isset($vals['confirmPassword'])) {
        $this->confirmPassword = $vals['confirmPassword'];
      }
    }
  }

  public function getName() {
    return 'ChangePasswordForm';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->oldPassword);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->newPassword);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->confirmPassword);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ChangePasswordForm');
    if ($this->oldPassword !== null) {
      $xfer += $output->writeFieldBegin('oldPassword', TType::STRING, 1);
      $xfer += $output->writeString($this->oldPassword);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newPassword !== null) {
      $xfer += $output->writeFieldBegin('newPassword', TType::STRING, 2);
      $xfer += $output->writeString($this->newPassword);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->confirmPassword !== null) {
      $xfer += $output->writeFieldBegin('confirmPassword', TType::STRING, 3);
      $xfer += $output->writeString($this->confirmPassword);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @DEPRECATED использовать этот набор полей внутри конкретной
 * операции, даже если он будет дублироваться.
 * Для исключения дублирования эта структура
 * в любом случае не подходит, т.к. объявлены даты bankDate вместо Date.
 * Сейчас (01.04.2014) используется только в Feedback
 */
class UserOperationCommonInfo {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $createDate = null;
  /**
   * @var string
   */
  public $processedDate = null;
  /**
   * @var int
   */
  public $status = null;
  /**
   * @var \Tag[]
   */
  public $tags = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'createDate',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'processedDate',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'status',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'tags',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Tag',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['createDate'])) {
        $this->createDate = $vals['createDate'];
      }
      if (isset($vals['processedDate'])) {
        $this->processedDate = $vals['processedDate'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
    }
  }

  public function getName() {
    return 'UserOperationCommonInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->createDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->processedDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::LST) {
            $this->tags = array();
            $_size64 = 0;
            $_etype67 = 0;
            $xfer += $input->readListBegin($_etype67, $_size64);
            for ($_i68 = 0; $_i68 < $_size64; ++$_i68)
            {
              $elem69 = null;
              $elem69 = new \Tag();
              $xfer += $elem69->read($input);
              $this->tags []= $elem69;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UserOperationCommonInfo');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createDate !== null) {
      $xfer += $output->writeFieldBegin('createDate', TType::STRING, 2);
      $xfer += $output->writeString($this->createDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->processedDate !== null) {
      $xfer += $output->writeFieldBegin('processedDate', TType::STRING, 3);
      $xfer += $output->writeString($this->processedDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::I32, 4);
      $xfer += $output->writeI32($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::LST, 5);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tags));
        {
          foreach ($this->tags as $iter70)
          {
            $xfer += $iter70->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class FeedBackMessageOperation {
  static $_TSPEC;

  /**
   * @var \UserOperationCommonInfo
   */
  public $operationInfo = null;
  /**
   * @var string
   */
  public $subject = null;
  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationInfo',
          'type' => TType::STRUCT,
          'class' => '\UserOperationCommonInfo',
          ),
        2 => array(
          'var' => 'subject',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationInfo'])) {
        $this->operationInfo = $vals['operationInfo'];
      }
      if (isset($vals['subject'])) {
        $this->subject = $vals['subject'];
      }
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'FeedBackMessageOperation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->operationInfo = new \UserOperationCommonInfo();
            $xfer += $this->operationInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->subject);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FeedBackMessageOperation');
    if ($this->operationInfo !== null) {
      if (!is_object($this->operationInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationInfo', TType::STRUCT, 1);
      $xfer += $this->operationInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subject !== null) {
      $xfer += $output->writeFieldBegin('subject', TType::STRING, 2);
      $xfer += $output->writeString($this->subject);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 3);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class FeedBackMessageOperationHistoryItem {
  static $_TSPEC;

  /**
   * @var string
   */
  public $feedBackId = null;
  /**
   * @var string
   */
  public $originalRequest = null;
  /**
   * @var string
   */
  public $response = null;
  /**
   * @var string
   */
  public $responseAuthor = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * @var \Tag[]
   */
  public $tags = null;
  /**
   * @var string
   */
  public $subject = null;
  /**
   * @var int
   */
  public $created = null;
  /**
   * @var int
   */
  public $responseCreated = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'feedBackId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'originalRequest',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'response',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'responseAuthor',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        6 => array(
          'var' => 'tags',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Tag',
            ),
          ),
        7 => array(
          'var' => 'subject',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'created',
          'type' => TType::I64,
          ),
        9 => array(
          'var' => 'responseCreated',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['feedBackId'])) {
        $this->feedBackId = $vals['feedBackId'];
      }
      if (isset($vals['originalRequest'])) {
        $this->originalRequest = $vals['originalRequest'];
      }
      if (isset($vals['response'])) {
        $this->response = $vals['response'];
      }
      if (isset($vals['responseAuthor'])) {
        $this->responseAuthor = $vals['responseAuthor'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
      if (isset($vals['subject'])) {
        $this->subject = $vals['subject'];
      }
      if (isset($vals['created'])) {
        $this->created = $vals['created'];
      }
      if (isset($vals['responseCreated'])) {
        $this->responseCreated = $vals['responseCreated'];
      }
    }
  }

  public function getName() {
    return 'FeedBackMessageOperationHistoryItem';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->feedBackId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->originalRequest);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->response);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->responseAuthor);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->tags = array();
            $_size71 = 0;
            $_etype74 = 0;
            $xfer += $input->readListBegin($_etype74, $_size71);
            for ($_i75 = 0; $_i75 < $_size71; ++$_i75)
            {
              $elem76 = null;
              $elem76 = new \Tag();
              $xfer += $elem76->read($input);
              $this->tags []= $elem76;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->subject);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->created);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->responseCreated);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FeedBackMessageOperationHistoryItem');
    if ($this->feedBackId !== null) {
      $xfer += $output->writeFieldBegin('feedBackId', TType::STRING, 1);
      $xfer += $output->writeString($this->feedBackId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->originalRequest !== null) {
      $xfer += $output->writeFieldBegin('originalRequest', TType::STRING, 2);
      $xfer += $output->writeString($this->originalRequest);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->response !== null) {
      $xfer += $output->writeFieldBegin('response', TType::STRING, 3);
      $xfer += $output->writeString($this->response);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->responseAuthor !== null) {
      $xfer += $output->writeFieldBegin('responseAuthor', TType::STRING, 4);
      $xfer += $output->writeString($this->responseAuthor);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 5);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tags));
        {
          foreach ($this->tags as $iter77)
          {
            $xfer += $iter77->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subject !== null) {
      $xfer += $output->writeFieldBegin('subject', TType::STRING, 7);
      $xfer += $output->writeString($this->subject);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->created !== null) {
      $xfer += $output->writeFieldBegin('created', TType::I64, 8);
      $xfer += $output->writeI64($this->created);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->responseCreated !== null) {
      $xfer += $output->writeFieldBegin('responseCreated', TType::I64, 9);
      $xfer += $output->writeI64($this->responseCreated);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Bank {
  static $_TSPEC;

  /**
   * @var string
   */
  public $bankId = null;
  /**
   * @var string
   */
  public $bankName = null;
  /**
   * @var bool
   */
  public $transferAllowed = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'bankId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'bankName',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'transferAllowed',
          'type' => TType::BOOL,
          ),
        4 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['bankId'])) {
        $this->bankId = $vals['bankId'];
      }
      if (isset($vals['bankName'])) {
        $this->bankName = $vals['bankName'];
      }
      if (isset($vals['transferAllowed'])) {
        $this->transferAllowed = $vals['transferAllowed'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'Bank';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bankId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bankName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->transferAllowed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Bank');
    if ($this->bankId !== null) {
      $xfer += $output->writeFieldBegin('bankId', TType::STRING, 1);
      $xfer += $output->writeString($this->bankId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bankName !== null) {
      $xfer += $output->writeFieldBegin('bankName', TType::STRING, 2);
      $xfer += $output->writeString($this->bankName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->transferAllowed !== null) {
      $xfer += $output->writeFieldBegin('transferAllowed', TType::BOOL, 3);
      $xfer += $output->writeBool($this->transferAllowed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 4);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Субъект операции перевода P2P_IBANK (от клиента к клиенту IBANK)
 * 
 */
class P2POperationSubject {
  static $_TSPEC;

  /**
   * логин клиента, который может выступать собъектом операции (получателем или отправителем)
   * 
   * @var string
   */
  public $login = null;
  /**
   * уточняющий параметр, конкретизирующий какой из счетов клиента будет субъектом операции. если не указан, то счет этого клиента по умолчанию
   * 
   * @var \ContractReference
   */
  public $contractRef = null;
  /**
   * для реализации custom-адресации (например для уточнения какого-то под-счета клиента, если зачислить надо именно на него)
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'login',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'contractRef',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        3 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['login'])) {
        $this->login = $vals['login'];
      }
      if (isset($vals['contractRef'])) {
        $this->contractRef = $vals['contractRef'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'P2POperationSubject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->login);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->contractRef = new \ContractReference();
            $xfer += $this->contractRef->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('P2POperationSubject');
    if ($this->login !== null) {
      $xfer += $output->writeFieldBegin('login', TType::STRING, 1);
      $xfer += $output->writeString($this->login);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contractRef !== null) {
      if (!is_object($this->contractRef)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('contractRef', TType::STRUCT, 2);
      $xfer += $this->contractRef->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 3);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * * Параметр Biller-платежа, который является динамическими (в отличие от статических реквизитов, таких как
 * * номер счета / договора или ЖЭК-а). Этот параметр отражает такое понятие как "счетчик" -- нечто, что
 * * клиент может заполнить самостоятельно, тем самым скорректировав сумму платежа.
 * * Этот объект используется двояко: с одной стороны он возвращается после preface-операции платежа биллера
 *  * (фактически это означате получение "счета на оплату" клиентом от биллера с частично заполненными сетчиками),
 *  * с другой стороны клиент может до-заполнить эти данные (как правило из preface вернется oldValue,
 *  * а клиент должен ввести newValue)
 * *
 */
class BillerMeter {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * Название параметра-счетчика. Например, "Электроэнергия"
   * 
   * @var string
   */
  public $name = null;
  /**
   * Единица измерения. Например, "КВт/ч"
   * 
   * @var string
   */
  public $unitName = null;
  /**
   * Тариф. Определяется соглашением интеграционного и клиентского слоя, но рекомендуется считать тариф в копейках.
   * Т.е. тариф 12.5 означает 12.5 копеек за 1 КВт/ч
   * 
   * 
   * @var double
   */
  public $tariff = null;
  /**
   * Старое значение показания счетчика. Часто может заполняться после выполнения команды prefaceBillPaymentOperation()
   * 
   * @var double
   */
  public $oldValue = null;
  /**
   * Новое значение показания счетчика. Чаще заполняется клиентом, но иногда может быть предложено после операции prefaceBillPaymentOperation (например, если снятие показаний счетчиков проводит контрольная служба биллера)
   * 
   * @var double
   */
  public $newValue = null;
  /**
   * Расчитанная сумма по счетчику. Обычно подразумевается что amount = tariff * (newValue - oldValue).
   * Однако детали реализации зависят от от соглашения между интеграционным слоем и клиентским.
   * Например, amount может напрямую указываться клиентом и превышать расчетную сумму по тарифу, -- как "оплата долга"
   * 
   * 
   * @var int
   */
  public $amount = null;
  /**
   * Если счетчик относится к какой-то секции счета ("субсчету")
   * 
   * @var string
   */
  public $sectionId = null;
  /**
   * Для возможности релаизовать "особенности", например тарифов. К примеру в атрибутах могут быть переданы альтернативные значения тарифов и условия их наступления ("tariffLimit1=100", "tariff1=10.00", "tariffLimit2=250", "tariff2=11.00" )
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'unitName',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'tariff',
          'type' => TType::DOUBLE,
          ),
        5 => array(
          'var' => 'oldValue',
          'type' => TType::DOUBLE,
          ),
        6 => array(
          'var' => 'newValue',
          'type' => TType::DOUBLE,
          ),
        7 => array(
          'var' => 'amount',
          'type' => TType::I64,
          ),
        8 => array(
          'var' => 'sectionId',
          'type' => TType::STRING,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['unitName'])) {
        $this->unitName = $vals['unitName'];
      }
      if (isset($vals['tariff'])) {
        $this->tariff = $vals['tariff'];
      }
      if (isset($vals['oldValue'])) {
        $this->oldValue = $vals['oldValue'];
      }
      if (isset($vals['newValue'])) {
        $this->newValue = $vals['newValue'];
      }
      if (isset($vals['amount'])) {
        $this->amount = $vals['amount'];
      }
      if (isset($vals['sectionId'])) {
        $this->sectionId = $vals['sectionId'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'BillerMeter';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->unitName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->tariff);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->oldValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->newValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->amount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->sectionId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BillerMeter');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->unitName !== null) {
      $xfer += $output->writeFieldBegin('unitName', TType::STRING, 3);
      $xfer += $output->writeString($this->unitName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tariff !== null) {
      $xfer += $output->writeFieldBegin('tariff', TType::DOUBLE, 4);
      $xfer += $output->writeDouble($this->tariff);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->oldValue !== null) {
      $xfer += $output->writeFieldBegin('oldValue', TType::DOUBLE, 5);
      $xfer += $output->writeDouble($this->oldValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newValue !== null) {
      $xfer += $output->writeFieldBegin('newValue', TType::DOUBLE, 6);
      $xfer += $output->writeDouble($this->newValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->amount !== null) {
      $xfer += $output->writeFieldBegin('amount', TType::I64, 7);
      $xfer += $output->writeI64($this->amount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sectionId !== null) {
      $xfer += $output->writeFieldBegin('sectionId', TType::STRING, 8);
      $xfer += $output->writeString($this->sectionId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * * Read-only параметры, которые передает в ответ на prefaceBillerOperation().
 *  * Это могут быть уточнения по счету (ФИО владельца квартиры),
 *  * строки счета (позиция за газ, за свет, за воду, за уборку мусора),
 *  * любая другая детализация счета.
 * *
 */
class BillDetails {
  static $_TSPEC;

  /**
   * Системное название парметра. Например "hot_water_tariff" или "owner_name". Только английские буквы и символы "-" или "_"
   * 
   * @var string
   */
  public $name = null;
  /**
   * Если возможно, название параметра для чтения
   * (локализованное, например "Размер тарифа за услугу поставки горячей воды", или "ФИО владельца квартиры"
   * в зависимости от атрибута lang в запросе prefaceBillerOperation или другой вариант
   * логики в зависимости от интеграционного слоя)
   * 
   * 
   * @var string
   */
  public $title = null;
  /**
   * Значение параметра, например "0.25 грн./1 куб м." или "Иванов Иван Иванович"
   * 
   * @var string
   */
  public $value = null;
  /**
   * Если параметр относится к какой-то секции счета ("субсчету")
   * 
   * @var string
   */
  public $sectionId = null;
  /**
   * Зарезервировано для сложых структурированых данных, если потребуется. Определяется логикой интеграционного слоя
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'title',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'sectionId',
          'type' => TType::STRING,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['title'])) {
        $this->title = $vals['title'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['sectionId'])) {
        $this->sectionId = $vals['sectionId'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'BillDetails';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->title);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->sectionId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BillDetails');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->title !== null) {
      $xfer += $output->writeFieldBegin('title', TType::STRING, 2);
      $xfer += $output->writeString($this->title);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->sectionId !== null) {
      $xfer += $output->writeFieldBegin('sectionId', TType::STRING, 4);
      $xfer += $output->writeString($this->sectionId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Секция счета ("субсчет").
 * Имеет название и идентификатор, на который могут ссылаться BillDetails или BillerMeters,
 * если это детали счета или счетчики относятся к этой части счета ("субсчету")
 * 
 */
class BillSection {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $title = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'title',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['title'])) {
        $this->title = $vals['title'];
      }
    }
  }

  public function getName() {
    return 'BillSection';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->title);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BillSection');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->title !== null) {
      $xfer += $output->writeFieldBegin('title', TType::STRING, 2);
      $xfer += $output->writeString($this->title);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Субъект (в данном случае почти всегда "получатель") платежа.
 * Определяет некоторую внешнюю организацию, имеющую номер в нашей системе billerId и
 * адресацию субъекта операции: номер счета
 * 
 */
class BillerOperationSubject {
  static $_TSPEC;

  /**
   * идентификатор биллера
   * 
   * @var string
   */
  public $billerId = null;
  /**
   * необязательная категория (но может понадобиться для случаев если интеграция выполнена так,
   * что billerId Не уникален в рамках категории *
   * 
   * @var string
   */
  public $categoryId = null;
  /**
   * необязательная ссылка на сервис-провайдера (агрегатора); но может понадобиться для случаев если интеграция выполнена так,
   * что billerId Не уникален в рамках сервис-провайдера *
   * 
   * @var string
   */
  public $providerId = null;
  /**
   * счет в рамках биллера, например номер телефона у мобильного оператора, номер клиентского договора, эл. кошелька и т.п.
   * 
   * @var string
   */
  public $billerAccount = null;
  /**
   * Расширенные аттрибуты для идентификации субъекта операции (локация, номер квартиры, суб-счет, признак "копилка" и т.п.)
   * 
   * @var \Attributes
   */
  public $parameters = null;
  /**
   * Показатели "счетчиков": параметров, которые являются динамическими при каждом платеже и влияют на сумму платежа
   * 
   * @var \BillerMeter[]
   */
  public $meters = null;
  /**
   * Номер счета в учетной системе провайдера счетов; может появляеться после запроса prefaceBillerPaymentOperation()
   * 
   * @var string
   */
  public $billId = null;
  /**
   * Детали операции, которые были предоставлены биллером: уточнения по счету, список предоставленных услуг со значениями и т.д.
   * 
   * @var \BillDetails[]
   */
  public $billDetails = null;
  /**
   * Название частей счета (секций), например, если услуги сгруппированы по какому-то признаку, то эти услуги в виде BillDetails могут иметь одну BillSection
   * 
   * @var \BillSection[]
   */
  public $billSections = null;
  /**
   * Язык, на котором ожидается получить счет. Использовать двузначный код (http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes), например "uk" (а не "ua"... UA это страна, а uk это язык), "ru", "en", "de"
   * 
   * @var string
   */
  public $lang = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'billerId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'categoryId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'providerId',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'billerAccount',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'parameters',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        6 => array(
          'var' => 'meters',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\BillerMeter',
            ),
          ),
        7 => array(
          'var' => 'billId',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'billDetails',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\BillDetails',
            ),
          ),
        9 => array(
          'var' => 'billSections',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\BillSection',
            ),
          ),
        10 => array(
          'var' => 'lang',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['billerId'])) {
        $this->billerId = $vals['billerId'];
      }
      if (isset($vals['categoryId'])) {
        $this->categoryId = $vals['categoryId'];
      }
      if (isset($vals['providerId'])) {
        $this->providerId = $vals['providerId'];
      }
      if (isset($vals['billerAccount'])) {
        $this->billerAccount = $vals['billerAccount'];
      }
      if (isset($vals['parameters'])) {
        $this->parameters = $vals['parameters'];
      }
      if (isset($vals['meters'])) {
        $this->meters = $vals['meters'];
      }
      if (isset($vals['billId'])) {
        $this->billId = $vals['billId'];
      }
      if (isset($vals['billDetails'])) {
        $this->billDetails = $vals['billDetails'];
      }
      if (isset($vals['billSections'])) {
        $this->billSections = $vals['billSections'];
      }
      if (isset($vals['lang'])) {
        $this->lang = $vals['lang'];
      }
    }
  }

  public function getName() {
    return 'BillerOperationSubject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->billerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->categoryId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->providerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->billerAccount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->parameters = new \Attributes();
            $xfer += $this->parameters->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->meters = array();
            $_size78 = 0;
            $_etype81 = 0;
            $xfer += $input->readListBegin($_etype81, $_size78);
            for ($_i82 = 0; $_i82 < $_size78; ++$_i82)
            {
              $elem83 = null;
              $elem83 = new \BillerMeter();
              $xfer += $elem83->read($input);
              $this->meters []= $elem83;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->billId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->billDetails = array();
            $_size84 = 0;
            $_etype87 = 0;
            $xfer += $input->readListBegin($_etype87, $_size84);
            for ($_i88 = 0; $_i88 < $_size84; ++$_i88)
            {
              $elem89 = null;
              $elem89 = new \BillDetails();
              $xfer += $elem89->read($input);
              $this->billDetails []= $elem89;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::LST) {
            $this->billSections = array();
            $_size90 = 0;
            $_etype93 = 0;
            $xfer += $input->readListBegin($_etype93, $_size90);
            for ($_i94 = 0; $_i94 < $_size90; ++$_i94)
            {
              $elem95 = null;
              $elem95 = new \BillSection();
              $xfer += $elem95->read($input);
              $this->billSections []= $elem95;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->lang);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BillerOperationSubject');
    if ($this->billerId !== null) {
      $xfer += $output->writeFieldBegin('billerId', TType::STRING, 1);
      $xfer += $output->writeString($this->billerId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->categoryId !== null) {
      $xfer += $output->writeFieldBegin('categoryId', TType::STRING, 2);
      $xfer += $output->writeString($this->categoryId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->providerId !== null) {
      $xfer += $output->writeFieldBegin('providerId', TType::STRING, 3);
      $xfer += $output->writeString($this->providerId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->billerAccount !== null) {
      $xfer += $output->writeFieldBegin('billerAccount', TType::STRING, 4);
      $xfer += $output->writeString($this->billerAccount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parameters !== null) {
      if (!is_object($this->parameters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parameters', TType::STRUCT, 5);
      $xfer += $this->parameters->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->meters !== null) {
      if (!is_array($this->meters)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('meters', TType::LST, 6);
      {
        $output->writeListBegin(TType::STRUCT, count($this->meters));
        {
          foreach ($this->meters as $iter96)
          {
            $xfer += $iter96->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->billId !== null) {
      $xfer += $output->writeFieldBegin('billId', TType::STRING, 7);
      $xfer += $output->writeString($this->billId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->billDetails !== null) {
      if (!is_array($this->billDetails)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('billDetails', TType::LST, 8);
      {
        $output->writeListBegin(TType::STRUCT, count($this->billDetails));
        {
          foreach ($this->billDetails as $iter97)
          {
            $xfer += $iter97->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->billSections !== null) {
      if (!is_array($this->billSections)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('billSections', TType::LST, 9);
      {
        $output->writeListBegin(TType::STRUCT, count($this->billSections));
        {
          foreach ($this->billSections as $iter98)
          {
            $xfer += $iter98->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lang !== null) {
      $xfer += $output->writeFieldBegin('lang', TType::STRING, 10);
      $xfer += $output->writeString($this->lang);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Субъект операции SWIFT-перевода (адресация "точки" отправки или получения) перевода.
 * TODO: сделать аттрибуты согласно стандарту см. http://en.wikipedia.org/wiki/ISO_9362
 * 
 */
class SWIFTOperationSubject {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'SWIFTOperationSubject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SWIFTOperationSubject');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * 
 */
class CustomOpeartionSubject {
  static $_TSPEC;

  /**
   * The type of custom operation, listad at configuration file for each implementation
   * 
   * @var string
   */
  public $customType = null;
  /**
   * Набор аттриюутов операции, которые были установлены в процессе ее выполнения или те, которые не вписались в набор перечисленных ниже
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'customType',
          'type' => TType::STRING,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['customType'])) {
        $this->customType = $vals['customType'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'CustomOpeartionSubject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->customType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CustomOpeartionSubject');
    if ($this->customType !== null) {
      $xfer += $output->writeFieldBegin('customType', TType::STRING, 1);
      $xfer += $output->writeString($this->customType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Запись об операции с профилем клиента.
 * Это операци входа, смены пароля, сброса пароля.
 * Могут быть типовые операции, описанные в ProfileOperationType.
 */
class ProfileOperationHistoryItem {
  static $_TSPEC;

  /**
   * @var int
   */
  public $profileOperationType = null;
  /**
   * @var string
   */
  public $operationId = null;
  /**
   * @var int
   */
  public $operationDate = null;
  /**
   * @var int
   */
  public $operationStatus = null;
  /**
   * @var string
   */
  public $ipAddress = null;
  /**
   * @var int
   */
  public $credentialsType = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'profileOperationType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'operationId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'operationDate',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'operationStatus',
          'type' => TType::I32,
          ),
        5 => array(
          'var' => 'ipAddress',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'credentialsType',
          'type' => TType::I32,
          ),
        7 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['profileOperationType'])) {
        $this->profileOperationType = $vals['profileOperationType'];
      }
      if (isset($vals['operationId'])) {
        $this->operationId = $vals['operationId'];
      }
      if (isset($vals['operationDate'])) {
        $this->operationDate = $vals['operationDate'];
      }
      if (isset($vals['operationStatus'])) {
        $this->operationStatus = $vals['operationStatus'];
      }
      if (isset($vals['ipAddress'])) {
        $this->ipAddress = $vals['ipAddress'];
      }
      if (isset($vals['credentialsType'])) {
        $this->credentialsType = $vals['credentialsType'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'ProfileOperationHistoryItem';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->profileOperationType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->operationId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->operationDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->operationStatus);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->ipAddress);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->credentialsType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProfileOperationHistoryItem');
    if ($this->profileOperationType !== null) {
      $xfer += $output->writeFieldBegin('profileOperationType', TType::I32, 1);
      $xfer += $output->writeI32($this->profileOperationType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationId !== null) {
      $xfer += $output->writeFieldBegin('operationId', TType::STRING, 2);
      $xfer += $output->writeString($this->operationId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationDate !== null) {
      $xfer += $output->writeFieldBegin('operationDate', TType::I64, 3);
      $xfer += $output->writeI64($this->operationDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationStatus !== null) {
      $xfer += $output->writeFieldBegin('operationStatus', TType::I32, 4);
      $xfer += $output->writeI32($this->operationStatus);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ipAddress !== null) {
      $xfer += $output->writeFieldBegin('ipAddress', TType::STRING, 5);
      $xfer += $output->writeString($this->ipAddress);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->credentialsType !== null) {
      $xfer += $output->writeFieldBegin('credentialsType', TType::I32, 6);
      $xfer += $output->writeI32($this->credentialsType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 7);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OperationHistoryFilter {
  static $_TSPEC;

  /**
   * @var int
   */
  public $filterType = null;
  /**
   * @var string
   */
  public $filterValue = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'filterType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'filterValue',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['filterType'])) {
        $this->filterType = $vals['filterType'];
      }
      if (isset($vals['filterValue'])) {
        $this->filterValue = $vals['filterValue'];
      }
    }
  }

  public function getName() {
    return 'OperationHistoryFilter';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->filterType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->filterValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OperationHistoryFilter');
    if ($this->filterType !== null) {
      $xfer += $output->writeFieldBegin('filterType', TType::I32, 1);
      $xfer += $output->writeI32($this->filterType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->filterValue !== null) {
      $xfer += $output->writeFieldBegin('filterValue', TType::STRING, 2);
      $xfer += $output->writeString($this->filterValue);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * use as source and destination describe in any OperationHistoryItem
 */
class OperationSubject {
  static $_TSPEC;

  /**
   * Номер счета
   * 
   * @var string
   */
  public $accountNumber = null;
  /**
   * МФО бана (идентфиикатор банка)
   * 
   * @var string
   */
  public $bankId = null;
  /**
   * Налоговый номер (ЕГРПОУ или ИНН)
   * 
   * @var string
   */
  public $taxId = null;
  /**
   * Наименование субъекта (название юр-лица или ФИО физ-лица)
   * 
   * @var string
   */
  public $name = null;
  /**
   * Валюта
   * 
   * 
   * @var string
   */
  public $currency = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'accountNumber',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'bankId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'taxId',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['accountNumber'])) {
        $this->accountNumber = $vals['accountNumber'];
      }
      if (isset($vals['bankId'])) {
        $this->bankId = $vals['bankId'];
      }
      if (isset($vals['taxId'])) {
        $this->taxId = $vals['taxId'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
    }
  }

  public function getName() {
    return 'OperationSubject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accountNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bankId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->taxId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OperationSubject');
    if ($this->accountNumber !== null) {
      $xfer += $output->writeFieldBegin('accountNumber', TType::STRING, 1);
      $xfer += $output->writeString($this->accountNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bankId !== null) {
      $xfer += $output->writeFieldBegin('bankId', TType::STRING, 2);
      $xfer += $output->writeString($this->bankId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->taxId !== null) {
      $xfer += $output->writeFieldBegin('taxId', TType::STRING, 3);
      $xfer += $output->writeString($this->taxId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 4);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 5);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Data for addressing the intrabank transfer operation.
 */
class IntrabankOperationSubject {
  static $_TSPEC;

  /**
   * Target identifier type: DEAL_NUMBER, ACCOUNT_NUMBER or CARD_NUMBER
   * 
   * @var int
   */
  public $identifierType = null;
  /**
   * Target identifier value (e.g. '26201234567890' for account number)
   * 
   * @var string
   */
  public $identifier = null;
  /**
   * Server-generated challenge request value. E.g. short or masked target contragent name or some additional request like "Give the birthday of recipient", etc. Not required for preface phase. (See challenge-response principle here: https://en.wikipedia.org/wiki/Challenge%E2%80%93response_authentication)
   * 
   * @var string
   */
  public $challengeRequestValue = null;
  /**
   * Challenge response if challenge request was provided by server. Depend on server settings, client should/must provide the response for asked challenge (on preface phase)
   * 
   * @var string
   */
  public $challengeResponseValue = null;
  /**
   * Attributes for functionality extension
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'identifierType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'identifier',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'challengeRequestValue',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'challengeResponseValue',
          'type' => TType::STRING,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['identifierType'])) {
        $this->identifierType = $vals['identifierType'];
      }
      if (isset($vals['identifier'])) {
        $this->identifier = $vals['identifier'];
      }
      if (isset($vals['challengeRequestValue'])) {
        $this->challengeRequestValue = $vals['challengeRequestValue'];
      }
      if (isset($vals['challengeResponseValue'])) {
        $this->challengeResponseValue = $vals['challengeResponseValue'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'IntrabankOperationSubject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->identifierType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->identifier);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->challengeRequestValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->challengeResponseValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('IntrabankOperationSubject');
    if ($this->identifierType !== null) {
      $xfer += $output->writeFieldBegin('identifierType', TType::I32, 1);
      $xfer += $output->writeI32($this->identifierType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->identifier !== null) {
      $xfer += $output->writeFieldBegin('identifier', TType::STRING, 2);
      $xfer += $output->writeString($this->identifier);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->challengeRequestValue !== null) {
      $xfer += $output->writeFieldBegin('challengeRequestValue', TType::STRING, 3);
      $xfer += $output->writeString($this->challengeRequestValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->challengeResponseValue !== null) {
      $xfer += $output->writeFieldBegin('challengeResponseValue', TType::STRING, 4);
      $xfer += $output->writeString($this->challengeResponseValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Data for Card to Card operation.
 */
class CardToCardOperationSubject {
  static $_TSPEC;

  /**
   * Sender card reference
   * 
   * @var \CardReference
   */
  public $senderCard = null;
  /**
   * Receiver card reference
   * 
   * @var \CardReference
   */
  public $receiverCard = null;
  /**
   * Data related to 3D secure. Here is good described API for full 3D Secure: http://docs.3dsecure.io/
   * 
   * @var \Secure3DRequest
   */
  public $secure3DRequest = null;
  /**
   * Is OTP required for operation. Usually is true for non-3D Secure operation but sometimes may demand even if operation is 3D-secure
   * 
   * @var bool
   */
  public $otpRequired = null;
  /**
   * Extended attributes, depends on card-to-card provider details: approval code, prn, etc. May be useful for showing correct receipt
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'senderCard',
          'type' => TType::STRUCT,
          'class' => '\CardReference',
          ),
        2 => array(
          'var' => 'receiverCard',
          'type' => TType::STRUCT,
          'class' => '\CardReference',
          ),
        3 => array(
          'var' => 'secure3DRequest',
          'type' => TType::STRUCT,
          'class' => '\Secure3DRequest',
          ),
        4 => array(
          'var' => 'otpRequired',
          'type' => TType::BOOL,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['senderCard'])) {
        $this->senderCard = $vals['senderCard'];
      }
      if (isset($vals['receiverCard'])) {
        $this->receiverCard = $vals['receiverCard'];
      }
      if (isset($vals['secure3DRequest'])) {
        $this->secure3DRequest = $vals['secure3DRequest'];
      }
      if (isset($vals['otpRequired'])) {
        $this->otpRequired = $vals['otpRequired'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'CardToCardOperationSubject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->senderCard = new \CardReference();
            $xfer += $this->senderCard->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->receiverCard = new \CardReference();
            $xfer += $this->receiverCard->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->secure3DRequest = new \Secure3DRequest();
            $xfer += $this->secure3DRequest->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->otpRequired);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CardToCardOperationSubject');
    if ($this->senderCard !== null) {
      if (!is_object($this->senderCard)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('senderCard', TType::STRUCT, 1);
      $xfer += $this->senderCard->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->receiverCard !== null) {
      if (!is_object($this->receiverCard)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('receiverCard', TType::STRUCT, 2);
      $xfer += $this->receiverCard->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->secure3DRequest !== null) {
      if (!is_object($this->secure3DRequest)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('secure3DRequest', TType::STRUCT, 3);
      $xfer += $this->secure3DRequest->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->otpRequired !== null) {
      $xfer += $output->writeFieldBegin('otpRequired', TType::BOOL, 4);
      $xfer += $output->writeBool($this->otpRequired);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Data for Card to Account operation.
 */
class CardToContractOperationSubject {
  static $_TSPEC;

  /**
   * Sender card reference
   * 
   * @var \CardReference
   */
  public $senderCard = null;
  /**
   * Receiver contract reference
   * 
   * @var \ContractReference
   */
  public $receiverContract = null;
  /**
   * Data related to 3D secure. Here is good described API for full 3D Secure: http://docs.3dsecure.io/
   * 
   * @var \Secure3DRequest
   */
  public $secure3DRequest = null;
  /**
   * Is OTP required for operation. Usually is true for non-3D Secure operation but sometimes may demand even if operation is 3D-secure
   * 
   * @var bool
   */
  public $otpRequired = null;
  /**
   * Extended attributes, depends on card-to-card provider details: approval code, prn, etc. May be useful for showing correct receipt
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'senderCard',
          'type' => TType::STRUCT,
          'class' => '\CardReference',
          ),
        2 => array(
          'var' => 'receiverContract',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        3 => array(
          'var' => 'secure3DRequest',
          'type' => TType::STRUCT,
          'class' => '\Secure3DRequest',
          ),
        4 => array(
          'var' => 'otpRequired',
          'type' => TType::BOOL,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['senderCard'])) {
        $this->senderCard = $vals['senderCard'];
      }
      if (isset($vals['receiverContract'])) {
        $this->receiverContract = $vals['receiverContract'];
      }
      if (isset($vals['secure3DRequest'])) {
        $this->secure3DRequest = $vals['secure3DRequest'];
      }
      if (isset($vals['otpRequired'])) {
        $this->otpRequired = $vals['otpRequired'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'CardToContractOperationSubject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->senderCard = new \CardReference();
            $xfer += $this->senderCard->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->receiverContract = new \ContractReference();
            $xfer += $this->receiverContract->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->secure3DRequest = new \Secure3DRequest();
            $xfer += $this->secure3DRequest->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->otpRequired);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CardToContractOperationSubject');
    if ($this->senderCard !== null) {
      if (!is_object($this->senderCard)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('senderCard', TType::STRUCT, 1);
      $xfer += $this->senderCard->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->receiverContract !== null) {
      if (!is_object($this->receiverContract)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('receiverContract', TType::STRUCT, 2);
      $xfer += $this->receiverContract->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->secure3DRequest !== null) {
      if (!is_object($this->secure3DRequest)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('secure3DRequest', TType::STRUCT, 3);
      $xfer += $this->secure3DRequest->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->otpRequired !== null) {
      $xfer += $output->writeFieldBegin('otpRequired', TType::BOOL, 4);
      $xfer += $output->writeBool($this->otpRequired);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Data for Close Contract operation.
 */
class CloseContractOperationSubject {
  static $_TSPEC;

  /**
   * @var \ContractReference
   */
  public $contractToClose = null;
  /**
   * Contract for compensation can be at different cases as contract from which
   * contract to close will compensata and contract to which will.
   * 
   * @var \ContractReference
   */
  public $contracToCompensate = null;
  /**
   * Attributes for functionality extension
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'contractToClose',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        2 => array(
          'var' => 'contracToCompensate',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['contractToClose'])) {
        $this->contractToClose = $vals['contractToClose'];
      }
      if (isset($vals['contracToCompensate'])) {
        $this->contracToCompensate = $vals['contracToCompensate'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'CloseContractOperationSubject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->contractToClose = new \ContractReference();
            $xfer += $this->contractToClose->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->contracToCompensate = new \ContractReference();
            $xfer += $this->contracToCompensate->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CloseContractOperationSubject');
    if ($this->contractToClose !== null) {
      if (!is_object($this->contractToClose)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('contractToClose', TType::STRUCT, 1);
      $xfer += $this->contractToClose->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contracToCompensate !== null) {
      if (!is_object($this->contracToCompensate)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('contracToCompensate', TType::STRUCT, 2);
      $xfer += $this->contracToCompensate->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CardContractOperationHistoryItem {
  static $_TSPEC;

  /**
   * @var int
   */
  public $operationDate = null;
  /**
   * @var int
   */
  public $finalizationDate = null;
  /**
   * @var string
   */
  public $approvalCode = null;
  /**
   * @var string
   */
  public $currency = null;
  /**
   * @var int
   */
  public $amountInCents = null;
  /**
   * @var int
   */
  public $localAmountInCents = null;
  /**
   * @var string
   */
  public $description = null;
  /**
   * @var \OperationSubject
   */
  public $source = null;
  /**
   * @var \OperationSubject
   */
  public $destination = null;
  /**
   * аттрибуты для расширенных данных
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationDate',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'finalizationDate',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'approvalCode',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'amountInCents',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'localAmountInCents',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'source',
          'type' => TType::STRUCT,
          'class' => '\OperationSubject',
          ),
        9 => array(
          'var' => 'destination',
          'type' => TType::STRUCT,
          'class' => '\OperationSubject',
          ),
        10 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationDate'])) {
        $this->operationDate = $vals['operationDate'];
      }
      if (isset($vals['finalizationDate'])) {
        $this->finalizationDate = $vals['finalizationDate'];
      }
      if (isset($vals['approvalCode'])) {
        $this->approvalCode = $vals['approvalCode'];
      }
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['amountInCents'])) {
        $this->amountInCents = $vals['amountInCents'];
      }
      if (isset($vals['localAmountInCents'])) {
        $this->localAmountInCents = $vals['localAmountInCents'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['source'])) {
        $this->source = $vals['source'];
      }
      if (isset($vals['destination'])) {
        $this->destination = $vals['destination'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'CardContractOperationHistoryItem';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->operationDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->finalizationDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->approvalCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->amountInCents);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->localAmountInCents);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->source = new \OperationSubject();
            $xfer += $this->source->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRUCT) {
            $this->destination = new \OperationSubject();
            $xfer += $this->destination->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CardContractOperationHistoryItem');
    if ($this->operationDate !== null) {
      $xfer += $output->writeFieldBegin('operationDate', TType::I64, 1);
      $xfer += $output->writeI64($this->operationDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->finalizationDate !== null) {
      $xfer += $output->writeFieldBegin('finalizationDate', TType::I64, 2);
      $xfer += $output->writeI64($this->finalizationDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approvalCode !== null) {
      $xfer += $output->writeFieldBegin('approvalCode', TType::STRING, 3);
      $xfer += $output->writeString($this->approvalCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 4);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->amountInCents !== null) {
      $xfer += $output->writeFieldBegin('amountInCents', TType::I64, 5);
      $xfer += $output->writeI64($this->amountInCents);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->localAmountInCents !== null) {
      $xfer += $output->writeFieldBegin('localAmountInCents', TType::I64, 6);
      $xfer += $output->writeI64($this->localAmountInCents);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 7);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->source !== null) {
      if (!is_object($this->source)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('source', TType::STRUCT, 8);
      $xfer += $this->source->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->destination !== null) {
      if (!is_object($this->destination)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('destination', TType::STRUCT, 9);
      $xfer += $this->destination->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 10);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AccountContractOperationHistoryItem {
  static $_TSPEC;

  /**
   * @var int
   */
  public $operationDate = null;
  /**
   * @var int
   */
  public $finalizationDate = null;
  /**
   * @var string
   */
  public $approvalCode = null;
  /**
   * @var string
   */
  public $currency = null;
  /**
   * @var int
   */
  public $amountInCents = null;
  /**
   * @var int
   */
  public $localAmountInCents = null;
  /**
   * @var string
   */
  public $description = null;
  /**
   * @var \OperationSubject
   */
  public $source = null;
  /**
   * @var \OperationSubject
   */
  public $destination = null;
  /**
   * аттрибуты для расширенных данных
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationDate',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'finalizationDate',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'approvalCode',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'amountInCents',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'localAmountInCents',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'source',
          'type' => TType::STRUCT,
          'class' => '\OperationSubject',
          ),
        9 => array(
          'var' => 'destination',
          'type' => TType::STRUCT,
          'class' => '\OperationSubject',
          ),
        10 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationDate'])) {
        $this->operationDate = $vals['operationDate'];
      }
      if (isset($vals['finalizationDate'])) {
        $this->finalizationDate = $vals['finalizationDate'];
      }
      if (isset($vals['approvalCode'])) {
        $this->approvalCode = $vals['approvalCode'];
      }
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['amountInCents'])) {
        $this->amountInCents = $vals['amountInCents'];
      }
      if (isset($vals['localAmountInCents'])) {
        $this->localAmountInCents = $vals['localAmountInCents'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['source'])) {
        $this->source = $vals['source'];
      }
      if (isset($vals['destination'])) {
        $this->destination = $vals['destination'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'AccountContractOperationHistoryItem';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->operationDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->finalizationDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->approvalCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->amountInCents);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->localAmountInCents);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->source = new \OperationSubject();
            $xfer += $this->source->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRUCT) {
            $this->destination = new \OperationSubject();
            $xfer += $this->destination->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AccountContractOperationHistoryItem');
    if ($this->operationDate !== null) {
      $xfer += $output->writeFieldBegin('operationDate', TType::I64, 1);
      $xfer += $output->writeI64($this->operationDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->finalizationDate !== null) {
      $xfer += $output->writeFieldBegin('finalizationDate', TType::I64, 2);
      $xfer += $output->writeI64($this->finalizationDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approvalCode !== null) {
      $xfer += $output->writeFieldBegin('approvalCode', TType::STRING, 3);
      $xfer += $output->writeString($this->approvalCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 4);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->amountInCents !== null) {
      $xfer += $output->writeFieldBegin('amountInCents', TType::I64, 5);
      $xfer += $output->writeI64($this->amountInCents);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->localAmountInCents !== null) {
      $xfer += $output->writeFieldBegin('localAmountInCents', TType::I64, 6);
      $xfer += $output->writeI64($this->localAmountInCents);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 7);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->source !== null) {
      if (!is_object($this->source)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('source', TType::STRUCT, 8);
      $xfer += $this->source->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->destination !== null) {
      if (!is_object($this->destination)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('destination', TType::STRUCT, 9);
      $xfer += $this->destination->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 10);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DepositContractOperationHistoryItem {
  static $_TSPEC;

  /**
   * @var int
   */
  public $operationDate = null;
  /**
   * @var int
   */
  public $finalizationDate = null;
  /**
   * @var string
   */
  public $approvalCode = null;
  /**
   * @var string
   */
  public $currency = null;
  /**
   * @var int
   */
  public $amountInCents = null;
  /**
   * @var int
   */
  public $localAmountInCents = null;
  /**
   * @var string
   */
  public $description = null;
  /**
   * @var \OperationSubject
   */
  public $source = null;
  /**
   * @var \OperationSubject
   */
  public $destination = null;
  /**
   * аттрибуты для расширенных данных
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationDate',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'finalizationDate',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'approvalCode',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'amountInCents',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'localAmountInCents',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'source',
          'type' => TType::STRUCT,
          'class' => '\OperationSubject',
          ),
        9 => array(
          'var' => 'destination',
          'type' => TType::STRUCT,
          'class' => '\OperationSubject',
          ),
        10 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationDate'])) {
        $this->operationDate = $vals['operationDate'];
      }
      if (isset($vals['finalizationDate'])) {
        $this->finalizationDate = $vals['finalizationDate'];
      }
      if (isset($vals['approvalCode'])) {
        $this->approvalCode = $vals['approvalCode'];
      }
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['amountInCents'])) {
        $this->amountInCents = $vals['amountInCents'];
      }
      if (isset($vals['localAmountInCents'])) {
        $this->localAmountInCents = $vals['localAmountInCents'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['source'])) {
        $this->source = $vals['source'];
      }
      if (isset($vals['destination'])) {
        $this->destination = $vals['destination'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'DepositContractOperationHistoryItem';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->operationDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->finalizationDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->approvalCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->amountInCents);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->localAmountInCents);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->source = new \OperationSubject();
            $xfer += $this->source->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRUCT) {
            $this->destination = new \OperationSubject();
            $xfer += $this->destination->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DepositContractOperationHistoryItem');
    if ($this->operationDate !== null) {
      $xfer += $output->writeFieldBegin('operationDate', TType::I64, 1);
      $xfer += $output->writeI64($this->operationDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->finalizationDate !== null) {
      $xfer += $output->writeFieldBegin('finalizationDate', TType::I64, 2);
      $xfer += $output->writeI64($this->finalizationDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approvalCode !== null) {
      $xfer += $output->writeFieldBegin('approvalCode', TType::STRING, 3);
      $xfer += $output->writeString($this->approvalCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 4);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->amountInCents !== null) {
      $xfer += $output->writeFieldBegin('amountInCents', TType::I64, 5);
      $xfer += $output->writeI64($this->amountInCents);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->localAmountInCents !== null) {
      $xfer += $output->writeFieldBegin('localAmountInCents', TType::I64, 6);
      $xfer += $output->writeI64($this->localAmountInCents);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 7);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->source !== null) {
      if (!is_object($this->source)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('source', TType::STRUCT, 8);
      $xfer += $this->source->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->destination !== null) {
      if (!is_object($this->destination)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('destination', TType::STRUCT, 9);
      $xfer += $this->destination->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 10);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CreditContractOperationHistoryItem {
  static $_TSPEC;

  /**
   * @var int
   */
  public $operationDate = null;
  /**
   * @var int
   */
  public $finalizationDate = null;
  /**
   * @var string
   */
  public $approvalCode = null;
  /**
   * @var string
   */
  public $currency = null;
  /**
   * @var int
   */
  public $amountInCents = null;
  /**
   * @var int
   */
  public $localAmountInCents = null;
  /**
   * @var string
   */
  public $description = null;
  /**
   * @var \OperationSubject
   */
  public $source = null;
  /**
   * @var \OperationSubject
   */
  public $destination = null;
  /**
   * аттрибуты для расширенных данных
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'operationDate',
          'type' => TType::I64,
          ),
        2 => array(
          'var' => 'finalizationDate',
          'type' => TType::I64,
          ),
        3 => array(
          'var' => 'approvalCode',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'amountInCents',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'localAmountInCents',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'source',
          'type' => TType::STRUCT,
          'class' => '\OperationSubject',
          ),
        9 => array(
          'var' => 'destination',
          'type' => TType::STRUCT,
          'class' => '\OperationSubject',
          ),
        10 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['operationDate'])) {
        $this->operationDate = $vals['operationDate'];
      }
      if (isset($vals['finalizationDate'])) {
        $this->finalizationDate = $vals['finalizationDate'];
      }
      if (isset($vals['approvalCode'])) {
        $this->approvalCode = $vals['approvalCode'];
      }
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['amountInCents'])) {
        $this->amountInCents = $vals['amountInCents'];
      }
      if (isset($vals['localAmountInCents'])) {
        $this->localAmountInCents = $vals['localAmountInCents'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['source'])) {
        $this->source = $vals['source'];
      }
      if (isset($vals['destination'])) {
        $this->destination = $vals['destination'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'CreditContractOperationHistoryItem';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->operationDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->finalizationDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->approvalCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->amountInCents);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->localAmountInCents);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->source = new \OperationSubject();
            $xfer += $this->source->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRUCT) {
            $this->destination = new \OperationSubject();
            $xfer += $this->destination->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CreditContractOperationHistoryItem');
    if ($this->operationDate !== null) {
      $xfer += $output->writeFieldBegin('operationDate', TType::I64, 1);
      $xfer += $output->writeI64($this->operationDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->finalizationDate !== null) {
      $xfer += $output->writeFieldBegin('finalizationDate', TType::I64, 2);
      $xfer += $output->writeI64($this->finalizationDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approvalCode !== null) {
      $xfer += $output->writeFieldBegin('approvalCode', TType::STRING, 3);
      $xfer += $output->writeString($this->approvalCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 4);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->amountInCents !== null) {
      $xfer += $output->writeFieldBegin('amountInCents', TType::I64, 5);
      $xfer += $output->writeI64($this->amountInCents);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->localAmountInCents !== null) {
      $xfer += $output->writeFieldBegin('localAmountInCents', TType::I64, 6);
      $xfer += $output->writeI64($this->localAmountInCents);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 7);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->source !== null) {
      if (!is_object($this->source)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('source', TType::STRUCT, 8);
      $xfer += $this->source->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->destination !== null) {
      if (!is_object($this->destination)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('destination', TType::STRUCT, 9);
      $xfer += $this->destination->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 10);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Описание условий выполнения операции, используются для информирования о лимитах,
 * размере комиссии, условиях аутентификации для операции
 * 
 */
class OperationConditions {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $extAuthRequired = null;
  /**
   * @var int
   */
  public $extAuthScope = null;
  /**
   * @var int
   */
  public $maxAmount = null;
  /**
   * @var int
   */
  public $commission = null;
  /**
   * @var int
   */
  public $minAmount = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'extAuthRequired',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'extAuthScope',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'maxAmount',
          'type' => TType::I64,
          ),
        4 => array(
          'var' => 'commission',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'minAmount',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['extAuthRequired'])) {
        $this->extAuthRequired = $vals['extAuthRequired'];
      }
      if (isset($vals['extAuthScope'])) {
        $this->extAuthScope = $vals['extAuthScope'];
      }
      if (isset($vals['maxAmount'])) {
        $this->maxAmount = $vals['maxAmount'];
      }
      if (isset($vals['commission'])) {
        $this->commission = $vals['commission'];
      }
      if (isset($vals['minAmount'])) {
        $this->minAmount = $vals['minAmount'];
      }
    }
  }

  public function getName() {
    return 'OperationConditions';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->extAuthRequired);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->extAuthScope);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->maxAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->commission);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->minAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OperationConditions');
    if ($this->extAuthRequired !== null) {
      $xfer += $output->writeFieldBegin('extAuthRequired', TType::BOOL, 1);
      $xfer += $output->writeBool($this->extAuthRequired);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->extAuthScope !== null) {
      $xfer += $output->writeFieldBegin('extAuthScope', TType::I32, 2);
      $xfer += $output->writeI32($this->extAuthScope);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->maxAmount !== null) {
      $xfer += $output->writeFieldBegin('maxAmount', TType::I64, 3);
      $xfer += $output->writeI64($this->maxAmount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->commission !== null) {
      $xfer += $output->writeFieldBegin('commission', TType::I64, 4);
      $xfer += $output->writeI64($this->commission);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->minAmount !== null) {
      $xfer += $output->writeFieldBegin('minAmount', TType::I64, 5);
      $xfer += $output->writeI64($this->minAmount);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Операция перевода между собственными счетами (договорами на банковские продукты)
 * 
 */
class ContractToContractOperation {
  static $_TSPEC;

  /**
   * @var \ContractReference
   */
  public $srcContractRef = null;
  /**
   * @var \ContractReference
   */
  public $destContractRef = null;
  /**
   * @var string
   */
  public $currency = null;
  /**
   * @var int
   */
  public $amountInCents = null;
  /**
   * @var \OperationConditions
   */
  public $operationConditions = null;
  /**
   * @var \Attributes
   */
  public $attr = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'srcContractRef',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        2 => array(
          'var' => 'destContractRef',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        3 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'amountInCents',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'operationConditions',
          'type' => TType::STRUCT,
          'class' => '\OperationConditions',
          ),
        6 => array(
          'var' => 'attr',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['srcContractRef'])) {
        $this->srcContractRef = $vals['srcContractRef'];
      }
      if (isset($vals['destContractRef'])) {
        $this->destContractRef = $vals['destContractRef'];
      }
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['amountInCents'])) {
        $this->amountInCents = $vals['amountInCents'];
      }
      if (isset($vals['operationConditions'])) {
        $this->operationConditions = $vals['operationConditions'];
      }
      if (isset($vals['attr'])) {
        $this->attr = $vals['attr'];
      }
    }
  }

  public function getName() {
    return 'ContractToContractOperation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->srcContractRef = new \ContractReference();
            $xfer += $this->srcContractRef->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->destContractRef = new \ContractReference();
            $xfer += $this->destContractRef->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->amountInCents);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->operationConditions = new \OperationConditions();
            $xfer += $this->operationConditions->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->attr = new \Attributes();
            $xfer += $this->attr->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ContractToContractOperation');
    if ($this->srcContractRef !== null) {
      if (!is_object($this->srcContractRef)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('srcContractRef', TType::STRUCT, 1);
      $xfer += $this->srcContractRef->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->destContractRef !== null) {
      if (!is_object($this->destContractRef)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('destContractRef', TType::STRUCT, 2);
      $xfer += $this->destContractRef->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 3);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->amountInCents !== null) {
      $xfer += $output->writeFieldBegin('amountInCents', TType::I64, 4);
      $xfer += $output->writeI64($this->amountInCents);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationConditions !== null) {
      if (!is_object($this->operationConditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationConditions', TType::STRUCT, 5);
      $xfer += $this->operationConditions->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attr !== null) {
      if (!is_object($this->attr)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attr', TType::STRUCT, 6);
      $xfer += $this->attr->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated, use ContractReference
 * 
 */
class OperationSource {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var int
   */
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'OperationSource';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OperationSource');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 2);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated, use combination of ContractReference, FinancialOperationType, OperationSubject
 * 
 */
class OperationDestination {
  static $_TSPEC;

  /**
   * @var string
   */
  public $type = null;
  /**
   * @var string
   */
  public $bankId = null;
  /**
   * @var string
   */
  public $accountNo = null;
  /**
   * @var string
   */
  public $taxId = null;
  /**
   * @var string
   */
  public $beneficiaryName = null;
  /**
   * @var string
   */
  public $paymentDescription = null;
  /**
   * @var int
   */
  public $contractType = null;
  /**
   * @var string
   */
  public $contractId = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'bankId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'accountNo',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'taxId',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'beneficiaryName',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'paymentDescription',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'contractType',
          'type' => TType::I32,
          ),
        8 => array(
          'var' => 'contractId',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['bankId'])) {
        $this->bankId = $vals['bankId'];
      }
      if (isset($vals['accountNo'])) {
        $this->accountNo = $vals['accountNo'];
      }
      if (isset($vals['taxId'])) {
        $this->taxId = $vals['taxId'];
      }
      if (isset($vals['beneficiaryName'])) {
        $this->beneficiaryName = $vals['beneficiaryName'];
      }
      if (isset($vals['paymentDescription'])) {
        $this->paymentDescription = $vals['paymentDescription'];
      }
      if (isset($vals['contractType'])) {
        $this->contractType = $vals['contractType'];
      }
      if (isset($vals['contractId'])) {
        $this->contractId = $vals['contractId'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'OperationDestination';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->bankId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->accountNo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->taxId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->beneficiaryName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->paymentDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->contractType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->contractId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OperationDestination');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::STRING, 1);
      $xfer += $output->writeString($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->bankId !== null) {
      $xfer += $output->writeFieldBegin('bankId', TType::STRING, 2);
      $xfer += $output->writeString($this->bankId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->accountNo !== null) {
      $xfer += $output->writeFieldBegin('accountNo', TType::STRING, 3);
      $xfer += $output->writeString($this->accountNo);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->taxId !== null) {
      $xfer += $output->writeFieldBegin('taxId', TType::STRING, 4);
      $xfer += $output->writeString($this->taxId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->beneficiaryName !== null) {
      $xfer += $output->writeFieldBegin('beneficiaryName', TType::STRING, 5);
      $xfer += $output->writeString($this->beneficiaryName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->paymentDescription !== null) {
      $xfer += $output->writeFieldBegin('paymentDescription', TType::STRING, 6);
      $xfer += $output->writeString($this->paymentDescription);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contractType !== null) {
      $xfer += $output->writeFieldBegin('contractType', TType::I32, 7);
      $xfer += $output->writeI32($this->contractType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->contractId !== null) {
      $xfer += $output->writeFieldBegin('contractId', TType::STRING, 8);
      $xfer += $output->writeString($this->contractId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 9);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DefinedAmount {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var int
   */
  public $amount = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'amount',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['amount'])) {
        $this->amount = $vals['amount'];
      }
    }
  }

  public function getName() {
    return 'DefinedAmount';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->amount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DefinedAmount');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->amount !== null) {
      $xfer += $output->writeFieldBegin('amount', TType::I64, 2);
      $xfer += $output->writeI64($this->amount);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OperationTemplateProperties {
  static $_TSPEC;

  /**
   * Название на пример "За квартиру 1"
   * 
   * @var string
   */
  public $title = null;
  /**
   * Описание, например "Платеж за квартиру по адресу Иванова 2, только вода и комуналка. Эл-энергия ОТДЕЛЬНО!"
   * 
   * @var string
   */
  public $description = null;
  /**
   * Валюта
   * 
   * @var string
   */
  public $currency = null;
  /**
   * @var \DefinedAmount[]
   */
  public $definedAmounts = null;
  /**
   * Ссылка на иконку, если используется
   * 
   * @var string
   */
  public $iconRef = null;
  /**
   * Цвет, назначенный шаблону, опционально, например для цвета фона кнопки
   * 
   * @var string
   */
  public $color = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * Контракт (счет) клиента по умолчанию, с которого предлагается делать платеж
   * 
   * @var \ContractReference
   */
  public $defaultSourceContract = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'title',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'definedAmounts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\DefinedAmount',
            ),
          ),
        5 => array(
          'var' => 'iconRef',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'color',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        8 => array(
          'var' => 'defaultSourceContract',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['title'])) {
        $this->title = $vals['title'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['definedAmounts'])) {
        $this->definedAmounts = $vals['definedAmounts'];
      }
      if (isset($vals['iconRef'])) {
        $this->iconRef = $vals['iconRef'];
      }
      if (isset($vals['color'])) {
        $this->color = $vals['color'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['defaultSourceContract'])) {
        $this->defaultSourceContract = $vals['defaultSourceContract'];
      }
    }
  }

  public function getName() {
    return 'OperationTemplateProperties';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->title);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::LST) {
            $this->definedAmounts = array();
            $_size99 = 0;
            $_etype102 = 0;
            $xfer += $input->readListBegin($_etype102, $_size99);
            for ($_i103 = 0; $_i103 < $_size99; ++$_i103)
            {
              $elem104 = null;
              $elem104 = new \DefinedAmount();
              $xfer += $elem104->read($input);
              $this->definedAmounts []= $elem104;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->iconRef);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->color);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->defaultSourceContract = new \ContractReference();
            $xfer += $this->defaultSourceContract->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OperationTemplateProperties');
    if ($this->title !== null) {
      $xfer += $output->writeFieldBegin('title', TType::STRING, 1);
      $xfer += $output->writeString($this->title);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 2);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 3);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->definedAmounts !== null) {
      if (!is_array($this->definedAmounts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('definedAmounts', TType::LST, 4);
      {
        $output->writeListBegin(TType::STRUCT, count($this->definedAmounts));
        {
          foreach ($this->definedAmounts as $iter105)
          {
            $xfer += $iter105->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->iconRef !== null) {
      $xfer += $output->writeFieldBegin('iconRef', TType::STRING, 5);
      $xfer += $output->writeString($this->iconRef);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->color !== null) {
      $xfer += $output->writeFieldBegin('color', TType::STRING, 6);
      $xfer += $output->writeString($this->color);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 7);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->defaultSourceContract !== null) {
      if (!is_object($this->defaultSourceContract)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('defaultSourceContract', TType::STRUCT, 8);
      $xfer += $this->defaultSourceContract->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Субъект ("Реквизиты") финансовой операции.
 * Определяет тип этой операции и служит контейнером для данных, описывающих реквизиты в соответствии с этим типом.
 * 
 */
class FinancialOperationSubject {
  static $_TSPEC;

  /**
   * Тип финансовой операции. Для разных типов операции будут заполнены
   * разные Реквизиты
   * 
   * @var int
   */
  public $type = null;
  /**
   * Реквизит, используемый как текстовое дополнение к основым реквизитам (например "Назначение платежа" SEP_TRANSFER)
   * но который считается частью реквизитов (не может быть изменен при редактировании шаблона!)
   * 
   * 
   * @var string
   */
  public $subjectDescription = null;
  /**
   * Реквизиты операции пополнеия своего счета. Обязательное для CONTRACT_TO_CONTRACT
   * 
   * @var \ContractReference
   */
  public $subjectContract = null;
  /**
   * Реквизиты платежа СЭП. Обязательный только для типа SEP_TRANSFER
   * 
   * @var \OperationSubject
   */
  public $subjectSEP = null;
  /**
   * Реквизиты платежа P2P. Обязательный только для PTP_TRANSFER
   * 
   * @var \P2POperationSubject
   */
  public $subjectP2P = null;
  /**
   * Реквизиты платежа на биллера (номер биллера, номер счета и т.п.). Обязателен для BILLER_PAYMENT
   * 
   * @var \BillerOperationSubject
   */
  public $subjectBiller = null;
  /**
   * Реквизиты SWIFT-перевода. Обязателен для SWIFT_TRANSFER
   * 
   * @var \SWIFTOperationSubject
   */
  public $subjectSWIFT = null;
  /**
   * a
   * 
   * @var \IntrabankOperationSubject
   */
  public $intrabankOperationSubject = null;
  /**
   * Параметры открытия депозита
   * 
   * @var \DepositConditions
   */
  public $subjectMakeDeposit = null;
  /**
   * Card to card operation data
   * 
   * @var \CardToCardOperationSubject
   */
  public $subjectCardToCard = null;
  /**
   * Card to contract operation data
   * 
   * @var \CardToContractOperationSubject
   */
  public $subjectCardToContract = null;
  /**
   * Close contract data
   * 
   * @var \CloseContractOperationSubject
   */
  public $subjectCloseContract = null;
  /**
   * Custom operation
   * 
   * @var \CustomOpeartionSubject
   */
  public $subjectCustomOpeartion = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'subjectDescription',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'subjectContract',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        4 => array(
          'var' => 'subjectSEP',
          'type' => TType::STRUCT,
          'class' => '\OperationSubject',
          ),
        5 => array(
          'var' => 'subjectP2P',
          'type' => TType::STRUCT,
          'class' => '\P2POperationSubject',
          ),
        6 => array(
          'var' => 'subjectBiller',
          'type' => TType::STRUCT,
          'class' => '\BillerOperationSubject',
          ),
        7 => array(
          'var' => 'subjectSWIFT',
          'type' => TType::STRUCT,
          'class' => '\SWIFTOperationSubject',
          ),
        8 => array(
          'var' => 'intrabankOperationSubject',
          'type' => TType::STRUCT,
          'class' => '\IntrabankOperationSubject',
          ),
        9 => array(
          'var' => 'subjectMakeDeposit',
          'type' => TType::STRUCT,
          'class' => '\DepositConditions',
          ),
        10 => array(
          'var' => 'subjectCardToCard',
          'type' => TType::STRUCT,
          'class' => '\CardToCardOperationSubject',
          ),
        11 => array(
          'var' => 'subjectCardToContract',
          'type' => TType::STRUCT,
          'class' => '\CardToContractOperationSubject',
          ),
        12 => array(
          'var' => 'subjectCloseContract',
          'type' => TType::STRUCT,
          'class' => '\CloseContractOperationSubject',
          ),
        99 => array(
          'var' => 'subjectCustomOpeartion',
          'type' => TType::STRUCT,
          'class' => '\CustomOpeartionSubject',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['subjectDescription'])) {
        $this->subjectDescription = $vals['subjectDescription'];
      }
      if (isset($vals['subjectContract'])) {
        $this->subjectContract = $vals['subjectContract'];
      }
      if (isset($vals['subjectSEP'])) {
        $this->subjectSEP = $vals['subjectSEP'];
      }
      if (isset($vals['subjectP2P'])) {
        $this->subjectP2P = $vals['subjectP2P'];
      }
      if (isset($vals['subjectBiller'])) {
        $this->subjectBiller = $vals['subjectBiller'];
      }
      if (isset($vals['subjectSWIFT'])) {
        $this->subjectSWIFT = $vals['subjectSWIFT'];
      }
      if (isset($vals['intrabankOperationSubject'])) {
        $this->intrabankOperationSubject = $vals['intrabankOperationSubject'];
      }
      if (isset($vals['subjectMakeDeposit'])) {
        $this->subjectMakeDeposit = $vals['subjectMakeDeposit'];
      }
      if (isset($vals['subjectCardToCard'])) {
        $this->subjectCardToCard = $vals['subjectCardToCard'];
      }
      if (isset($vals['subjectCardToContract'])) {
        $this->subjectCardToContract = $vals['subjectCardToContract'];
      }
      if (isset($vals['subjectCloseContract'])) {
        $this->subjectCloseContract = $vals['subjectCloseContract'];
      }
      if (isset($vals['subjectCustomOpeartion'])) {
        $this->subjectCustomOpeartion = $vals['subjectCustomOpeartion'];
      }
    }
  }

  public function getName() {
    return 'FinancialOperationSubject';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->subjectDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->subjectContract = new \ContractReference();
            $xfer += $this->subjectContract->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->subjectSEP = new \OperationSubject();
            $xfer += $this->subjectSEP->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->subjectP2P = new \P2POperationSubject();
            $xfer += $this->subjectP2P->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->subjectBiller = new \BillerOperationSubject();
            $xfer += $this->subjectBiller->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->subjectSWIFT = new \SWIFTOperationSubject();
            $xfer += $this->subjectSWIFT->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->intrabankOperationSubject = new \IntrabankOperationSubject();
            $xfer += $this->intrabankOperationSubject->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRUCT) {
            $this->subjectMakeDeposit = new \DepositConditions();
            $xfer += $this->subjectMakeDeposit->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->subjectCardToCard = new \CardToCardOperationSubject();
            $xfer += $this->subjectCardToCard->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRUCT) {
            $this->subjectCardToContract = new \CardToContractOperationSubject();
            $xfer += $this->subjectCardToContract->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRUCT) {
            $this->subjectCloseContract = new \CloseContractOperationSubject();
            $xfer += $this->subjectCloseContract->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->subjectCustomOpeartion = new \CustomOpeartionSubject();
            $xfer += $this->subjectCustomOpeartion->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FinancialOperationSubject');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectDescription !== null) {
      $xfer += $output->writeFieldBegin('subjectDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->subjectDescription);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectContract !== null) {
      if (!is_object($this->subjectContract)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectContract', TType::STRUCT, 3);
      $xfer += $this->subjectContract->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectSEP !== null) {
      if (!is_object($this->subjectSEP)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectSEP', TType::STRUCT, 4);
      $xfer += $this->subjectSEP->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectP2P !== null) {
      if (!is_object($this->subjectP2P)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectP2P', TType::STRUCT, 5);
      $xfer += $this->subjectP2P->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectBiller !== null) {
      if (!is_object($this->subjectBiller)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectBiller', TType::STRUCT, 6);
      $xfer += $this->subjectBiller->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectSWIFT !== null) {
      if (!is_object($this->subjectSWIFT)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectSWIFT', TType::STRUCT, 7);
      $xfer += $this->subjectSWIFT->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->intrabankOperationSubject !== null) {
      if (!is_object($this->intrabankOperationSubject)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('intrabankOperationSubject', TType::STRUCT, 8);
      $xfer += $this->intrabankOperationSubject->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectMakeDeposit !== null) {
      if (!is_object($this->subjectMakeDeposit)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectMakeDeposit', TType::STRUCT, 9);
      $xfer += $this->subjectMakeDeposit->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectCardToCard !== null) {
      if (!is_object($this->subjectCardToCard)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectCardToCard', TType::STRUCT, 10);
      $xfer += $this->subjectCardToCard->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectCardToContract !== null) {
      if (!is_object($this->subjectCardToContract)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectCardToContract', TType::STRUCT, 11);
      $xfer += $this->subjectCardToContract->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectCloseContract !== null) {
      if (!is_object($this->subjectCloseContract)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectCloseContract', TType::STRUCT, 12);
      $xfer += $this->subjectCloseContract->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectCustomOpeartion !== null) {
      if (!is_object($this->subjectCustomOpeartion)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectCustomOpeartion', TType::STRUCT, 99);
      $xfer += $this->subjectCustomOpeartion->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Шаблон финансовой операции.
 * 
 */
class OperationTemplate {
  static $_TSPEC;

  /**
   * ID шаблона клиента
   * 
   * @var string
   */
  public $id = null;
  /**
   * Название на пример "За квартиру 1"
   * 
   * @var string
   */
  public $title = null;
  /**
   * Описание, например "Платеж за квартиру по адресу Иванова 2, только вода и комуналка. Эл-энергия ОТДЕЛЬНО!"
   * 
   * @var string
   */
  public $description = null;
  /**
   * Валюта
   * 
   * @var string
   */
  public $currency = null;
  /**
   * Ссылка на иконку, если используется
   * 
   * @var string
   */
  public $iconRef = null;
  /**
   * @var int
   */
  public $creationDate = null;
  /**
   * @var int
   */
  public $updateDate = null;
  /**
   * @var int
   */
  public $lastExecutionDate = null;
  /**
   * @var int
   */
  public $executionCount = null;
  /**
   * @var int
   */
  public $origin = null;
  /**
   * @var int
   */
  public $lastExecutionAmount = null;
  /**
   * @var \DefinedAmount[]
   */
  public $definedAmounts = null;
  /**
   * @Deprecated, use defaultSourceContract
   * 
   * @var \OperationSource
   */
  public $defaultSource = null;
  /**
   * @Deprecated, use appropriated for operationType parameters 'subjectXxxxx'
   * 
   * @var \OperationDestination
   */
  public $destination = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * Цвет, назначенный шаблону, опционально, например для цвета фона кнопки
   * 
   * @var string
   */
  public $color = null;
  /**
   * @Deprecated, use operationSubject.type Тип финансовой операции. Для разных типов операции будут заполнены
   * разные Реквизиты
   * 
   * @var int
   */
  public $operationType = null;
  /**
   * Контракт (счет) клиента по умолчанию, с которого предлагается делать платеж
   * 
   * @var \ContractReference
   */
  public $defaultSourceContract = null;
  /**
   * Реквизиты операции.
   * 
   * @var \FinancialOperationSubject
   */
  public $operationSubject = null;
  /**
   * @var bool
   */
  public $approved = null;
  /**
   * Дата удаления шаблона. 0, если шаблон активный
   * 
   * @var int
   */
  public $deleteDate = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'title',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'iconRef',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'creationDate',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'updateDate',
          'type' => TType::I64,
          ),
        8 => array(
          'var' => 'lastExecutionDate',
          'type' => TType::I64,
          ),
        9 => array(
          'var' => 'executionCount',
          'type' => TType::I64,
          ),
        10 => array(
          'var' => 'origin',
          'type' => TType::I32,
          ),
        11 => array(
          'var' => 'lastExecutionAmount',
          'type' => TType::I64,
          ),
        12 => array(
          'var' => 'definedAmounts',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\DefinedAmount',
            ),
          ),
        13 => array(
          'var' => 'defaultSource',
          'type' => TType::STRUCT,
          'class' => '\OperationSource',
          ),
        14 => array(
          'var' => 'destination',
          'type' => TType::STRUCT,
          'class' => '\OperationDestination',
          ),
        15 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        16 => array(
          'var' => 'color',
          'type' => TType::STRING,
          ),
        17 => array(
          'var' => 'operationType',
          'type' => TType::I32,
          ),
        18 => array(
          'var' => 'defaultSourceContract',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        19 => array(
          'var' => 'operationSubject',
          'type' => TType::STRUCT,
          'class' => '\FinancialOperationSubject',
          ),
        20 => array(
          'var' => 'approved',
          'type' => TType::BOOL,
          ),
        21 => array(
          'var' => 'deleteDate',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['title'])) {
        $this->title = $vals['title'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['iconRef'])) {
        $this->iconRef = $vals['iconRef'];
      }
      if (isset($vals['creationDate'])) {
        $this->creationDate = $vals['creationDate'];
      }
      if (isset($vals['updateDate'])) {
        $this->updateDate = $vals['updateDate'];
      }
      if (isset($vals['lastExecutionDate'])) {
        $this->lastExecutionDate = $vals['lastExecutionDate'];
      }
      if (isset($vals['executionCount'])) {
        $this->executionCount = $vals['executionCount'];
      }
      if (isset($vals['origin'])) {
        $this->origin = $vals['origin'];
      }
      if (isset($vals['lastExecutionAmount'])) {
        $this->lastExecutionAmount = $vals['lastExecutionAmount'];
      }
      if (isset($vals['definedAmounts'])) {
        $this->definedAmounts = $vals['definedAmounts'];
      }
      if (isset($vals['defaultSource'])) {
        $this->defaultSource = $vals['defaultSource'];
      }
      if (isset($vals['destination'])) {
        $this->destination = $vals['destination'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['color'])) {
        $this->color = $vals['color'];
      }
      if (isset($vals['operationType'])) {
        $this->operationType = $vals['operationType'];
      }
      if (isset($vals['defaultSourceContract'])) {
        $this->defaultSourceContract = $vals['defaultSourceContract'];
      }
      if (isset($vals['operationSubject'])) {
        $this->operationSubject = $vals['operationSubject'];
      }
      if (isset($vals['approved'])) {
        $this->approved = $vals['approved'];
      }
      if (isset($vals['deleteDate'])) {
        $this->deleteDate = $vals['deleteDate'];
      }
    }
  }

  public function getName() {
    return 'OperationTemplate';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->title);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->iconRef);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->creationDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->updateDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lastExecutionDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->executionCount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->origin);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->lastExecutionAmount);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::LST) {
            $this->definedAmounts = array();
            $_size106 = 0;
            $_etype109 = 0;
            $xfer += $input->readListBegin($_etype109, $_size106);
            for ($_i110 = 0; $_i110 < $_size106; ++$_i110)
            {
              $elem111 = null;
              $elem111 = new \DefinedAmount();
              $xfer += $elem111->read($input);
              $this->definedAmounts []= $elem111;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::STRUCT) {
            $this->defaultSource = new \OperationSource();
            $xfer += $this->defaultSource->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::STRUCT) {
            $this->destination = new \OperationDestination();
            $xfer += $this->destination->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->color);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 17:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->operationType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 18:
          if ($ftype == TType::STRUCT) {
            $this->defaultSourceContract = new \ContractReference();
            $xfer += $this->defaultSourceContract->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 19:
          if ($ftype == TType::STRUCT) {
            $this->operationSubject = new \FinancialOperationSubject();
            $xfer += $this->operationSubject->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 20:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->approved);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 21:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->deleteDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OperationTemplate');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->title !== null) {
      $xfer += $output->writeFieldBegin('title', TType::STRING, 2);
      $xfer += $output->writeString($this->title);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 3);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 4);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->iconRef !== null) {
      $xfer += $output->writeFieldBegin('iconRef', TType::STRING, 5);
      $xfer += $output->writeString($this->iconRef);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->creationDate !== null) {
      $xfer += $output->writeFieldBegin('creationDate', TType::I64, 6);
      $xfer += $output->writeI64($this->creationDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->updateDate !== null) {
      $xfer += $output->writeFieldBegin('updateDate', TType::I64, 7);
      $xfer += $output->writeI64($this->updateDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastExecutionDate !== null) {
      $xfer += $output->writeFieldBegin('lastExecutionDate', TType::I64, 8);
      $xfer += $output->writeI64($this->lastExecutionDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executionCount !== null) {
      $xfer += $output->writeFieldBegin('executionCount', TType::I64, 9);
      $xfer += $output->writeI64($this->executionCount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->origin !== null) {
      $xfer += $output->writeFieldBegin('origin', TType::I32, 10);
      $xfer += $output->writeI32($this->origin);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->lastExecutionAmount !== null) {
      $xfer += $output->writeFieldBegin('lastExecutionAmount', TType::I64, 11);
      $xfer += $output->writeI64($this->lastExecutionAmount);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->definedAmounts !== null) {
      if (!is_array($this->definedAmounts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('definedAmounts', TType::LST, 12);
      {
        $output->writeListBegin(TType::STRUCT, count($this->definedAmounts));
        {
          foreach ($this->definedAmounts as $iter112)
          {
            $xfer += $iter112->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->defaultSource !== null) {
      if (!is_object($this->defaultSource)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('defaultSource', TType::STRUCT, 13);
      $xfer += $this->defaultSource->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->destination !== null) {
      if (!is_object($this->destination)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('destination', TType::STRUCT, 14);
      $xfer += $this->destination->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 15);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->color !== null) {
      $xfer += $output->writeFieldBegin('color', TType::STRING, 16);
      $xfer += $output->writeString($this->color);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationType !== null) {
      $xfer += $output->writeFieldBegin('operationType', TType::I32, 17);
      $xfer += $output->writeI32($this->operationType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->defaultSourceContract !== null) {
      if (!is_object($this->defaultSourceContract)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('defaultSourceContract', TType::STRUCT, 18);
      $xfer += $this->defaultSourceContract->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationSubject !== null) {
      if (!is_object($this->operationSubject)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationSubject', TType::STRUCT, 19);
      $xfer += $this->operationSubject->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approved !== null) {
      $xfer += $output->writeFieldBegin('approved', TType::BOOL, 20);
      $xfer += $output->writeBool($this->approved);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deleteDate !== null) {
      $xfer += $output->writeFieldBegin('deleteDate', TType::I64, 21);
      $xfer += $output->writeI64($this->deleteDate);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Структура определяет данные операции регистрации
 * наличных расходов (или доходов).
 * При этом операция считается как "расход" при отрицательном поле balance
 * а "доходом" при положительном балансе
 */
class CashExpenseOperation {
  static $_TSPEC;

  /**
   * Readonly
   * 
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $name = null;
  /**
   * @var string
   */
  public $description = null;
  /**
   * @var int
   */
  public $balance = null;
  /**
   * @var string
   */
  public $currency = null;
  /**
   * @var int
   */
  public $createDate = null;
  /**
   * @var int
   */
  public $processDate = null;
  /**
   * @var int
   */
  public $status = null;
  /**
   * @var \Tag[]
   */
  public $tags = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * Дата совершения операции. Может быть как в прошлом ("вчера потратил 100 USD" так и будущим "плановая покупка"). Однако в статус "processed" операция перейдет только из статуса "approved" И (!) не раньше чем наступит дата "executeDate"
   * 
   * @var int
   */
  public $executeDate = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'balance',
          'type' => TType::I64,
          ),
        5 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'createDate',
          'type' => TType::I64,
          ),
        7 => array(
          'var' => 'processDate',
          'type' => TType::I64,
          ),
        8 => array(
          'var' => 'status',
          'type' => TType::I32,
          ),
        9 => array(
          'var' => 'tags',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Tag',
            ),
          ),
        10 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        11 => array(
          'var' => 'executeDate',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['balance'])) {
        $this->balance = $vals['balance'];
      }
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['createDate'])) {
        $this->createDate = $vals['createDate'];
      }
      if (isset($vals['processDate'])) {
        $this->processDate = $vals['processDate'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['executeDate'])) {
        $this->executeDate = $vals['executeDate'];
      }
    }
  }

  public function getName() {
    return 'CashExpenseOperation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->balance);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->createDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->processDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::LST) {
            $this->tags = array();
            $_size113 = 0;
            $_etype116 = 0;
            $xfer += $input->readListBegin($_etype116, $_size113);
            for ($_i117 = 0; $_i117 < $_size113; ++$_i117)
            {
              $elem118 = null;
              $elem118 = new \Tag();
              $xfer += $elem118->read($input);
              $this->tags []= $elem118;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->executeDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CashExpenseOperation');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 3);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->balance !== null) {
      $xfer += $output->writeFieldBegin('balance', TType::I64, 4);
      $xfer += $output->writeI64($this->balance);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 5);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createDate !== null) {
      $xfer += $output->writeFieldBegin('createDate', TType::I64, 6);
      $xfer += $output->writeI64($this->createDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->processDate !== null) {
      $xfer += $output->writeFieldBegin('processDate', TType::I64, 7);
      $xfer += $output->writeI64($this->processDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::I32, 8);
      $xfer += $output->writeI32($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::LST, 9);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tags));
        {
          foreach ($this->tags as $iter119)
          {
            $xfer += $iter119->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 10);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executeDate !== null) {
      $xfer += $output->writeFieldBegin('executeDate', TType::I64, 11);
      $xfer += $output->writeI64($this->executeDate);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BillerParameterConfiguration {
  static $_TSPEC;

  /**
   * @var string
   */
  public $name = null;
  /**
   * @var string
   */
  public $title = null;
  /**
   * @var int
   */
  public $type = null;
  /**
   * @var string
   */
  public $validationRule = null;
  /**
   * @var string
   */
  public $hint = null;
  /**
   * Для расширенной информации о поле или о способах его валидации, например "regexp", "mask", "format"
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'title',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'validationRule',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'hint',
          'type' => TType::STRING,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['title'])) {
        $this->title = $vals['title'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['validationRule'])) {
        $this->validationRule = $vals['validationRule'];
      }
      if (isset($vals['hint'])) {
        $this->hint = $vals['hint'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'BillerParameterConfiguration';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->title);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->validationRule);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hint);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BillerParameterConfiguration');
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->title !== null) {
      $xfer += $output->writeFieldBegin('title', TType::STRING, 2);
      $xfer += $output->writeString($this->title);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 3);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validationRule !== null) {
      $xfer += $output->writeFieldBegin('validationRule', TType::STRING, 4);
      $xfer += $output->writeString($this->validationRule);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hint !== null) {
      $xfer += $output->writeFieldBegin('hint', TType::STRING, 5);
      $xfer += $output->writeString($this->hint);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Вспомогательная структура эквивалентная Biller за исключением аттрибутов,
 *  связанных с категорией. Может быть только внутри Biller в случае, если
 *  данный Biller есть сборка в рамках Ibank-каталога биллеров из одного или
 *  более оригинальных биллеров
 */
class AssembledBiller {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $title = null;
  /**
   * @var string
   */
  public $providerId = null;
  /**
   * @var string
   */
  public $providerTitle = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * @var string[]
   */
  public $allowedLocations = null;
  /**
   * @var \BillerParameterConfiguration[]
   */
  public $parametersConf = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'title',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'providerId',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'providerTitle',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        8 => array(
          'var' => 'allowedLocations',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        9 => array(
          'var' => 'parametersConf',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\BillerParameterConfiguration',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['title'])) {
        $this->title = $vals['title'];
      }
      if (isset($vals['providerId'])) {
        $this->providerId = $vals['providerId'];
      }
      if (isset($vals['providerTitle'])) {
        $this->providerTitle = $vals['providerTitle'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['allowedLocations'])) {
        $this->allowedLocations = $vals['allowedLocations'];
      }
      if (isset($vals['parametersConf'])) {
        $this->parametersConf = $vals['parametersConf'];
      }
    }
  }

  public function getName() {
    return 'AssembledBiller';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->title);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->providerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->providerTitle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->allowedLocations = array();
            $_size120 = 0;
            $_etype123 = 0;
            $xfer += $input->readListBegin($_etype123, $_size120);
            for ($_i124 = 0; $_i124 < $_size120; ++$_i124)
            {
              $elem125 = null;
              $xfer += $input->readString($elem125);
              $this->allowedLocations []= $elem125;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::LST) {
            $this->parametersConf = array();
            $_size126 = 0;
            $_etype129 = 0;
            $xfer += $input->readListBegin($_etype129, $_size126);
            for ($_i130 = 0; $_i130 < $_size126; ++$_i130)
            {
              $elem131 = null;
              $elem131 = new \BillerParameterConfiguration();
              $xfer += $elem131->read($input);
              $this->parametersConf []= $elem131;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AssembledBiller');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->title !== null) {
      $xfer += $output->writeFieldBegin('title', TType::STRING, 2);
      $xfer += $output->writeString($this->title);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->providerId !== null) {
      $xfer += $output->writeFieldBegin('providerId', TType::STRING, 5);
      $xfer += $output->writeString($this->providerId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->providerTitle !== null) {
      $xfer += $output->writeFieldBegin('providerTitle', TType::STRING, 6);
      $xfer += $output->writeString($this->providerTitle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 7);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->allowedLocations !== null) {
      if (!is_array($this->allowedLocations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('allowedLocations', TType::LST, 8);
      {
        $output->writeListBegin(TType::STRING, count($this->allowedLocations));
        {
          foreach ($this->allowedLocations as $iter132)
          {
            $xfer += $output->writeString($iter132);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parametersConf !== null) {
      if (!is_array($this->parametersConf)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parametersConf', TType::LST, 9);
      {
        $output->writeListBegin(TType::STRUCT, count($this->parametersConf));
        {
          foreach ($this->parametersConf as $iter133)
          {
            $xfer += $iter133->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Biller: компания, которая может принимать платежи типа BILLER_PAYMENT
 * Компания может принадлежать "провайдеру" (компания-агрегатор, предоставляющая каталог).
 * Компания может принадлежать категории (в общем случае категория может быть как в рамках провайдера
 * так и общая для всех провайдеров).
 * 
 */
class Biller {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $title = null;
  /**
   * @var string
   */
  public $categoryId = null;
  /**
   * @var string
   */
  public $categoryTitle = null;
  /**
   * @var string
   */
  public $providerId = null;
  /**
   * @var string
   */
  public $providerTitle = null;
  /**
   * @var string
   */
  public $iconRef = null;
  /**
   * @var string[]
   */
  public $allowedLocations = null;
  /**
   * @var \BillerParameterConfiguration[]
   */
  public $parametersConf = null;
  /**
   * Биллеры, которые объединены в рамках текущего биллера в рамках каталога биллеров
   * 
   * @var \AssembledBiller[]
   */
  public $assembledBillers = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'title',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'categoryId',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'categoryTitle',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'providerId',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'providerTitle',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'iconRef',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'allowedLocations',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        9 => array(
          'var' => 'parametersConf',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\BillerParameterConfiguration',
            ),
          ),
        10 => array(
          'var' => 'assembledBillers',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\AssembledBiller',
            ),
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['title'])) {
        $this->title = $vals['title'];
      }
      if (isset($vals['categoryId'])) {
        $this->categoryId = $vals['categoryId'];
      }
      if (isset($vals['categoryTitle'])) {
        $this->categoryTitle = $vals['categoryTitle'];
      }
      if (isset($vals['providerId'])) {
        $this->providerId = $vals['providerId'];
      }
      if (isset($vals['providerTitle'])) {
        $this->providerTitle = $vals['providerTitle'];
      }
      if (isset($vals['iconRef'])) {
        $this->iconRef = $vals['iconRef'];
      }
      if (isset($vals['allowedLocations'])) {
        $this->allowedLocations = $vals['allowedLocations'];
      }
      if (isset($vals['parametersConf'])) {
        $this->parametersConf = $vals['parametersConf'];
      }
      if (isset($vals['assembledBillers'])) {
        $this->assembledBillers = $vals['assembledBillers'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'Biller';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->title);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->categoryId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->categoryTitle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->providerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->providerTitle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->iconRef);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->allowedLocations = array();
            $_size134 = 0;
            $_etype137 = 0;
            $xfer += $input->readListBegin($_etype137, $_size134);
            for ($_i138 = 0; $_i138 < $_size134; ++$_i138)
            {
              $elem139 = null;
              $xfer += $input->readString($elem139);
              $this->allowedLocations []= $elem139;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::LST) {
            $this->parametersConf = array();
            $_size140 = 0;
            $_etype143 = 0;
            $xfer += $input->readListBegin($_etype143, $_size140);
            for ($_i144 = 0; $_i144 < $_size140; ++$_i144)
            {
              $elem145 = null;
              $elem145 = new \BillerParameterConfiguration();
              $xfer += $elem145->read($input);
              $this->parametersConf []= $elem145;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::LST) {
            $this->assembledBillers = array();
            $_size146 = 0;
            $_etype149 = 0;
            $xfer += $input->readListBegin($_etype149, $_size146);
            for ($_i150 = 0; $_i150 < $_size146; ++$_i150)
            {
              $elem151 = null;
              $elem151 = new \AssembledBiller();
              $xfer += $elem151->read($input);
              $this->assembledBillers []= $elem151;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Biller');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->title !== null) {
      $xfer += $output->writeFieldBegin('title', TType::STRING, 2);
      $xfer += $output->writeString($this->title);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->categoryId !== null) {
      $xfer += $output->writeFieldBegin('categoryId', TType::STRING, 3);
      $xfer += $output->writeString($this->categoryId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->categoryTitle !== null) {
      $xfer += $output->writeFieldBegin('categoryTitle', TType::STRING, 4);
      $xfer += $output->writeString($this->categoryTitle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->providerId !== null) {
      $xfer += $output->writeFieldBegin('providerId', TType::STRING, 5);
      $xfer += $output->writeString($this->providerId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->providerTitle !== null) {
      $xfer += $output->writeFieldBegin('providerTitle', TType::STRING, 6);
      $xfer += $output->writeString($this->providerTitle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->iconRef !== null) {
      $xfer += $output->writeFieldBegin('iconRef', TType::STRING, 7);
      $xfer += $output->writeString($this->iconRef);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->allowedLocations !== null) {
      if (!is_array($this->allowedLocations)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('allowedLocations', TType::LST, 8);
      {
        $output->writeListBegin(TType::STRING, count($this->allowedLocations));
        {
          foreach ($this->allowedLocations as $iter152)
          {
            $xfer += $output->writeString($iter152);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parametersConf !== null) {
      if (!is_array($this->parametersConf)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('parametersConf', TType::LST, 9);
      {
        $output->writeListBegin(TType::STRUCT, count($this->parametersConf));
        {
          foreach ($this->parametersConf as $iter153)
          {
            $xfer += $iter153->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->assembledBillers !== null) {
      if (!is_array($this->assembledBillers)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('assembledBillers', TType::LST, 10);
      {
        $output->writeListBegin(TType::STRUCT, count($this->assembledBillers));
        {
          foreach ($this->assembledBillers as $iter154)
          {
            $xfer += $iter154->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * BillerCategory: категория ("папка"), которой могут принадлежать "биллеры" (см.  Biller).
 * 
 */
class BillerCategory {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * @var string
   */
  public $parentId = null;
  /**
   * @var string
   */
  public $title = null;
  /**
   * @var string
   */
  public $description = null;
  /**
   * @var string
   */
  public $providerId = null;
  /**
   * @var string
   */
  public $providerTitle = null;
  /**
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'parentId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'title',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'providerId',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'providerTitle',
          'type' => TType::STRING,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['parentId'])) {
        $this->parentId = $vals['parentId'];
      }
      if (isset($vals['title'])) {
        $this->title = $vals['title'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['providerId'])) {
        $this->providerId = $vals['providerId'];
      }
      if (isset($vals['providerTitle'])) {
        $this->providerTitle = $vals['providerTitle'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'BillerCategory';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->parentId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->title);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->providerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->providerTitle);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BillerCategory');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->parentId !== null) {
      $xfer += $output->writeFieldBegin('parentId', TType::STRING, 2);
      $xfer += $output->writeString($this->parentId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->title !== null) {
      $xfer += $output->writeFieldBegin('title', TType::STRING, 3);
      $xfer += $output->writeString($this->title);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 4);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->providerId !== null) {
      $xfer += $output->writeFieldBegin('providerId', TType::STRING, 5);
      $xfer += $output->writeString($this->providerId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->providerTitle !== null) {
      $xfer += $output->writeFieldBegin('providerTitle', TType::STRING, 6);
      $xfer += $output->writeString($this->providerTitle);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Contains the mobile keys used to secure the communication during subsequent remote management sessions.
 */
class MasterCardMobileKeys {
  static $_TSPEC;

  /**
   * public key certificate which is used to wrap the randomly-generated key (RGK) during the MPA registration process
   * 
   * @var string
   */
  public $publicKeyCertificate = null;
  /**
   * The identifier for the Mobile Keys used to manage the CLOUD credentials, as assigned by MDES upon successful registration.
   * 
   * @var string
   */
  public $mobileKeysetId = null;
  /**
   * Mobile Transport Key used to provide confidentiality of data at the transport level between the Mobile Payment App and MDES.
   * 
   * @var string
   */
  public $transportKey = null;
  /**
   * Mobile MAC Key used to provide integrity of data at the transport level between the Mobile Payment App and MDES.
   * 
   * @var string
   */
  public $macKey = null;
  /**
   * Mobile Data Encryption Key used to encrypt any sensitive data at the data field level between the Mobile Payment App and MDES.
   * 
   * @var string
   */
  public $dataEncryptionKey = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'publicKeyCertificate',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'mobileKeysetId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'transportKey',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'macKey',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'dataEncryptionKey',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['publicKeyCertificate'])) {
        $this->publicKeyCertificate = $vals['publicKeyCertificate'];
      }
      if (isset($vals['mobileKeysetId'])) {
        $this->mobileKeysetId = $vals['mobileKeysetId'];
      }
      if (isset($vals['transportKey'])) {
        $this->transportKey = $vals['transportKey'];
      }
      if (isset($vals['macKey'])) {
        $this->macKey = $vals['macKey'];
      }
      if (isset($vals['dataEncryptionKey'])) {
        $this->dataEncryptionKey = $vals['dataEncryptionKey'];
      }
    }
  }

  public function getName() {
    return 'MasterCardMobileKeys';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->publicKeyCertificate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->mobileKeysetId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->transportKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->macKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dataEncryptionKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MasterCardMobileKeys');
    if ($this->publicKeyCertificate !== null) {
      $xfer += $output->writeFieldBegin('publicKeyCertificate', TType::STRING, 1);
      $xfer += $output->writeString($this->publicKeyCertificate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mobileKeysetId !== null) {
      $xfer += $output->writeFieldBegin('mobileKeysetId', TType::STRING, 2);
      $xfer += $output->writeString($this->mobileKeysetId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->transportKey !== null) {
      $xfer += $output->writeFieldBegin('transportKey', TType::STRING, 3);
      $xfer += $output->writeString($this->transportKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->macKey !== null) {
      $xfer += $output->writeFieldBegin('macKey', TType::STRING, 4);
      $xfer += $output->writeString($this->macKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dataEncryptionKey !== null) {
      $xfer += $output->writeFieldBegin('dataEncryptionKey', TType::STRING, 5);
      $xfer += $output->writeString($this->dataEncryptionKey);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SubjectDeviceRegistration {
  static $_TSPEC;

  /**
   * Identifier for the specific Mobile Payment App instance, unique across a given Wallet Identifier. This value cannot be changed after digitization.
   * Generated on server side
   * 
   * @var string
   */
  public $paymentAppInstanceId = null;
  /**
   * @var \MasterCardMobileKeys
   */
  public $masterCardMobileKeys = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'paymentAppInstanceId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'masterCardMobileKeys',
          'type' => TType::STRUCT,
          'class' => '\MasterCardMobileKeys',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['paymentAppInstanceId'])) {
        $this->paymentAppInstanceId = $vals['paymentAppInstanceId'];
      }
      if (isset($vals['masterCardMobileKeys'])) {
        $this->masterCardMobileKeys = $vals['masterCardMobileKeys'];
      }
    }
  }

  public function getName() {
    return 'SubjectDeviceRegistration';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->paymentAppInstanceId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->masterCardMobileKeys = new \MasterCardMobileKeys();
            $xfer += $this->masterCardMobileKeys->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SubjectDeviceRegistration');
    if ($this->paymentAppInstanceId !== null) {
      $xfer += $output->writeFieldBegin('paymentAppInstanceId', TType::STRING, 1);
      $xfer += $output->writeString($this->paymentAppInstanceId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->masterCardMobileKeys !== null) {
      if (!is_object($this->masterCardMobileKeys)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('masterCardMobileKeys', TType::STRUCT, 2);
      $xfer += $this->masterCardMobileKeys->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MasterCardTokenInfo {
  static $_TSPEC;

  /**
   * The last few digits (typically four) of the Token PAN.
   * 
   * @var string
   */
  public $tokenPanSuffix = null;
  /**
   * The last few digits (typically four) of the Account PAN.
   * 
   * @var string
   */
  public $acountPanSuffix = null;
  /**
   * The expiry of the Token PAN, given in MMYY format.
   * 
   * @var string
   */
  public $tokenExpiry = null;
  /**
   * Whether DSRP transactions are supported by this Token.
   * Must be one of:
   * true  - DSRP capable
   * false - Not DSRP capable
   * 
   * @var bool
   */
  public $dsrpCapable = null;
  /**
   * A value indicating the confidence level of the token to Account PAN binding.
   * 
   * @var string
   */
  public $tokenAssuranceLevel = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tokenPanSuffix',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'acountPanSuffix',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'tokenExpiry',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'dsrpCapable',
          'type' => TType::BOOL,
          ),
        5 => array(
          'var' => 'tokenAssuranceLevel',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tokenPanSuffix'])) {
        $this->tokenPanSuffix = $vals['tokenPanSuffix'];
      }
      if (isset($vals['acountPanSuffix'])) {
        $this->acountPanSuffix = $vals['acountPanSuffix'];
      }
      if (isset($vals['tokenExpiry'])) {
        $this->tokenExpiry = $vals['tokenExpiry'];
      }
      if (isset($vals['dsrpCapable'])) {
        $this->dsrpCapable = $vals['dsrpCapable'];
      }
      if (isset($vals['tokenAssuranceLevel'])) {
        $this->tokenAssuranceLevel = $vals['tokenAssuranceLevel'];
      }
    }
  }

  public function getName() {
    return 'MasterCardTokenInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenPanSuffix);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->acountPanSuffix);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenExpiry);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->dsrpCapable);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenAssuranceLevel);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MasterCardTokenInfo');
    if ($this->tokenPanSuffix !== null) {
      $xfer += $output->writeFieldBegin('tokenPanSuffix', TType::STRING, 1);
      $xfer += $output->writeString($this->tokenPanSuffix);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->acountPanSuffix !== null) {
      $xfer += $output->writeFieldBegin('acountPanSuffix', TType::STRING, 2);
      $xfer += $output->writeString($this->acountPanSuffix);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tokenExpiry !== null) {
      $xfer += $output->writeFieldBegin('tokenExpiry', TType::STRING, 3);
      $xfer += $output->writeString($this->tokenExpiry);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dsrpCapable !== null) {
      $xfer += $output->writeFieldBegin('dsrpCapable', TType::BOOL, 4);
      $xfer += $output->writeBool($this->dsrpCapable);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tokenAssuranceLevel !== null) {
      $xfer += $output->writeFieldBegin('tokenAssuranceLevel', TType::STRING, 5);
      $xfer += $output->writeString($this->tokenAssuranceLevel);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MasterCardTokenDetailData {
  static $_TSPEC;

  /**
   * The Token Primary Account Number of the card
   * 
   * @var string
   */
  public $tokenNumber = null;
  /**
   * The month of the token expiration date.
   * 
   * @var string
   */
  public $expiryMonth = null;
  /**
   * The year of the token expiration date
   * 
   * @var string
   */
  public $expiryYear = null;
  /**
   * The date/time after which this CardInfoData object is considered invalid. If present, all systems must reject this CardInfoData object after this time and treat it as invalid data.
   * Must be expressed in ISO 8601 extended format as one of the following:
   * YYYY-MM-DDThh:mm:ss[.sss]Z
   * YYYY-MM-DDThh:mm:ss[.sss]±hh:mm
   * Where [.sss] is optional and can be 1 to 3 digits.
   * Must be a value no more than 30 days in the future. MasterCard recommends using a value of (Current Time + 30 minutes).
   * 
   * @var string
   */
  public $dataValidUntilTimestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tokenNumber',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'expiryMonth',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'expiryYear',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'dataValidUntilTimestamp',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tokenNumber'])) {
        $this->tokenNumber = $vals['tokenNumber'];
      }
      if (isset($vals['expiryMonth'])) {
        $this->expiryMonth = $vals['expiryMonth'];
      }
      if (isset($vals['expiryYear'])) {
        $this->expiryYear = $vals['expiryYear'];
      }
      if (isset($vals['dataValidUntilTimestamp'])) {
        $this->dataValidUntilTimestamp = $vals['dataValidUntilTimestamp'];
      }
    }
  }

  public function getName() {
    return 'MasterCardTokenDetailData';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expiryMonth);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->expiryYear);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dataValidUntilTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MasterCardTokenDetailData');
    if ($this->tokenNumber !== null) {
      $xfer += $output->writeFieldBegin('tokenNumber', TType::STRING, 1);
      $xfer += $output->writeString($this->tokenNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expiryMonth !== null) {
      $xfer += $output->writeFieldBegin('expiryMonth', TType::STRING, 2);
      $xfer += $output->writeString($this->expiryMonth);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->expiryYear !== null) {
      $xfer += $output->writeFieldBegin('expiryYear', TType::STRING, 3);
      $xfer += $output->writeString($this->expiryYear);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dataValidUntilTimestamp !== null) {
      $xfer += $output->writeFieldBegin('dataValidUntilTimestamp', TType::STRING, 4);
      $xfer += $output->writeString($this->dataValidUntilTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MasterCardTokenDetail {
  static $_TSPEC;

  /**
   * Globally unique identifier for the Token, as assigned by MDES.
   * 
   * @var string
   */
  public $tokenUniqueReference = null;
  /**
   * The certificate fingerprint identifying the public key used to encrypt the ephemeral AES key.
   * 
   * @var string
   */
  public $publicKeyFingerprint = null;
  /**
   * One-time use AES key encrypted by the MasterCard public key (as identified by 'publicKeyFingerprint') using the OAEP or RSA Encryption Standard PKCS #1 v1.5 scheme (depending on the value of 'oaepHashingAlgorithm'.
   * Requirement is for a 128-bit key (with 256-bit key supported as an option).
   * 
   * @var string
   */
  public $encryptedKey = null;
  /**
   * * Hashing algorithm used with the OAEP scheme.
   * * If omitted, then the RSA Encryption Standard PKCS #1 v1.5 will be used.
   *    * Must be one of:
   *    * "SHA256"
   *    * "SHA512"
   * 
   * @var string
   */
  public $oaepHashingAlgorithm = null;
  /**
   * The initialization vector used when encrypting data using the one-time use AES key. Must be exactly 16 bytes (32 character hex string) to match the block size.
   * If not present, an IV of zero is assumed.s
   * 
   * @var string
   */
  public $iv = null;
  /**
   * Contains the encrypted TokenDetailData object. Encrypted by the ephemeral AES key using CBC mode (IV as provided in 'iv', or zero if none provided) and PKCS#7 padding.
   * 
   * @var string
   */
  public $encryptedData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tokenUniqueReference',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'publicKeyFingerprint',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'encryptedKey',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'oaepHashingAlgorithm',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'iv',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'encryptedData',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tokenUniqueReference'])) {
        $this->tokenUniqueReference = $vals['tokenUniqueReference'];
      }
      if (isset($vals['publicKeyFingerprint'])) {
        $this->publicKeyFingerprint = $vals['publicKeyFingerprint'];
      }
      if (isset($vals['encryptedKey'])) {
        $this->encryptedKey = $vals['encryptedKey'];
      }
      if (isset($vals['oaepHashingAlgorithm'])) {
        $this->oaepHashingAlgorithm = $vals['oaepHashingAlgorithm'];
      }
      if (isset($vals['iv'])) {
        $this->iv = $vals['iv'];
      }
      if (isset($vals['encryptedData'])) {
        $this->encryptedData = $vals['encryptedData'];
      }
    }
  }

  public function getName() {
    return 'MasterCardTokenDetail';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenUniqueReference);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->publicKeyFingerprint);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->encryptedKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->oaepHashingAlgorithm);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->iv);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->encryptedData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MasterCardTokenDetail');
    if ($this->tokenUniqueReference !== null) {
      $xfer += $output->writeFieldBegin('tokenUniqueReference', TType::STRING, 1);
      $xfer += $output->writeString($this->tokenUniqueReference);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->publicKeyFingerprint !== null) {
      $xfer += $output->writeFieldBegin('publicKeyFingerprint', TType::STRING, 2);
      $xfer += $output->writeString($this->publicKeyFingerprint);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->encryptedKey !== null) {
      $xfer += $output->writeFieldBegin('encryptedKey', TType::STRING, 3);
      $xfer += $output->writeString($this->encryptedKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->oaepHashingAlgorithm !== null) {
      $xfer += $output->writeFieldBegin('oaepHashingAlgorithm', TType::STRING, 4);
      $xfer += $output->writeString($this->oaepHashingAlgorithm);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->iv !== null) {
      $xfer += $output->writeFieldBegin('iv', TType::STRING, 5);
      $xfer += $output->writeString($this->iv);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->encryptedData !== null) {
      $xfer += $output->writeFieldBegin('encryptedData', TType::STRING, 6);
      $xfer += $output->writeString($this->encryptedData);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MasterCardToken {
  static $_TSPEC;

  /**
   * Contains all the token specific data for this card.
   * Required if the decision was APPROVED or REQUIRE_ADDITIONAL_AUTHENTICATION.
   * 
   * @var \MasterCardTokenInfo
   */
  public $tokenInfo = null;
  /**
   * Contains token information of the card tokenized.
   * Rrequired if tokenType = STATIC and decision is not DECLINED.
   * 
   * @var \MasterCardTokenDetail
   */
  public $tokenDetail = null;
  /**
   * Transaction Details Service URL.
   * Conditional – required if TDS is supported. Not present if TDS is not supported or if the Token is not eligible for transaction details.
   * 
   * @var string
   */
  public $tdsRegistrationUrl = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tokenInfo',
          'type' => TType::STRUCT,
          'class' => '\MasterCardTokenInfo',
          ),
        2 => array(
          'var' => 'tokenDetail',
          'type' => TType::STRUCT,
          'class' => '\MasterCardTokenDetail',
          ),
        3 => array(
          'var' => 'tdsRegistrationUrl',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tokenInfo'])) {
        $this->tokenInfo = $vals['tokenInfo'];
      }
      if (isset($vals['tokenDetail'])) {
        $this->tokenDetail = $vals['tokenDetail'];
      }
      if (isset($vals['tdsRegistrationUrl'])) {
        $this->tdsRegistrationUrl = $vals['tdsRegistrationUrl'];
      }
    }
  }

  public function getName() {
    return 'MasterCardToken';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->tokenInfo = new \MasterCardTokenInfo();
            $xfer += $this->tokenInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->tokenDetail = new \MasterCardTokenDetail();
            $xfer += $this->tokenDetail->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tdsRegistrationUrl);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MasterCardToken');
    if ($this->tokenInfo !== null) {
      if (!is_object($this->tokenInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tokenInfo', TType::STRUCT, 1);
      $xfer += $this->tokenInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tokenDetail !== null) {
      if (!is_object($this->tokenDetail)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tokenDetail', TType::STRUCT, 2);
      $xfer += $this->tokenDetail->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tdsRegistrationUrl !== null) {
      $xfer += $output->writeFieldBegin('tdsRegistrationUrl', TType::STRING, 3);
      $xfer += $output->writeString($this->tdsRegistrationUrl);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Token {
  static $_TSPEC;

  /**
   * @var \MasterCardToken
   */
  public $masterCardToken = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'masterCardToken',
          'type' => TType::STRUCT,
          'class' => '\MasterCardToken',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['masterCardToken'])) {
        $this->masterCardToken = $vals['masterCardToken'];
      }
    }
  }

  public function getName() {
    return 'Token';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->masterCardToken = new \MasterCardToken();
            $xfer += $this->masterCardToken->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Token');
    if ($this->masterCardToken !== null) {
      if (!is_object($this->masterCardToken)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('masterCardToken', TType::STRUCT, 1);
      $xfer += $this->masterCardToken->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AuthenticationMethod {
  static $_TSPEC;

  /**
   * Unique identifier assigned to this Authentication Method.
   * 
   * @var string
   */
  public $id = null;
  /**
   * Specifies the authentication method type.
   * Must be one of:
   * "TEXT_TO_CARDHOLDER_NUMBER"
   * "EMAIL_TO_CARDHOLDER_ADDRESS"
   * "CARDHOLDER_TO_CALL_AUTOMATED_NUMBER"
   * "CARDHOLDER_TO_CALL_MANNED_NUMBER"
   * "CARDHOLDER_TO_VISIT_WEBSITE"
   * "CARDHOLDER_TO_USE_ISSUER_MOBILE_APP"
   * "ISSUER_TO_CALL_CARDHOLDER_NUMBER"
   * 
   * @var string
   */
  public $type = null;
  /**
   * Specifies the authentication method value (meaning varies depending on the authentication method type).
   * Tequired in Digitize or Tokenize response depending on "type".
   * 
   * @var string
   */
  public $value = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
    }
  }

  public function getName() {
    return 'AuthenticationMethod';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AuthenticationMethod');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::STRING, 2);
      $xfer += $output->writeString($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ProductConfig {
  static $_TSPEC;

  /**
   * The MasterCard or Maestro brand logo associated with this card. Provided as an Asset ID – use the Get Asset API (See Section 2.2.5) to retrieve the actual asset.
   * 
   * @var string
   */
  public $brandLogoAssetId = null;
  /**
   * The logo of the issuing bank. Provided as an Asset ID – use the Get Asset API (See Section 2.2.5) to retrieve the actual asset.
   * 
   * @var string
   */
  public $issuerLogoAssetId = null;
  /**
   * Whether the product is co-branded.
   * Must be one of:
   * true - This is a co-branded product.
   * false - This is not a co-branded product.
   * 
   * @var string
   */
  public $isCoBranded = null;
  /**
   * Textual name of the co-brand partner.
   * Required if isCoBranded = "true". Not present otherwise.
   * 
   * @var string
   */
  public $coBrandName = null;
  /**
   * The co-brand logo (if any) for this product. Provided as an Asset ID – use the Get Asset API (See Section 2.2.5) to retrieve the actual asset.
   * 
   * @var string
   */
  public $coBrandLogoAssetId = null;
  /**
   * * The card image used to represent the digital card in the wallet.
   *    * This ‘combined’ option contains the MasterCard, bank and any co-brand logos. Provided as an Asset ID – use the Get Asset API (See Section 2.2.5) to retrieve the actual asset.
   *    * Either CardBackgroundCombined or CardBackground will be provided.
   * 
   * @var string
   */
  public $cardBackgroundCombinedAssetId = null;
  /**
   * * The card image used to represent the digital card in the wallet.
   *    * This ‘non-combined’ option does not contain the MasterCard, bank, or co-brand logos.
   *    * Provided as an Asset ID – use the Get Asset API (See Section 2.2.5) to retrieve the actual asset.
   *    * Either CardBackgroundCombined or CardBackground will be provided.
   * 
   * @var string
   */
  public $cardBackgroundAssetId = null;
  /**
   * The icon representing the primary brand(s) associated with this product. Provided as an Asset ID – use the Get Asset API (See Section 2.2.5) to retrieve the actual asset.
   * 
   * @var string
   */
  public $iconAssetId = null;
  /**
   * Foreground color, used to overlay text on top of the card image.
   * 
   * @var string
   */
  public $foregroundColor = null;
  /**
   * Name of the issuing bank.
   * 
   * @var string
   */
  public $issuerName = null;
  /**
   * A short description for this product.
   * 
   * @var string
   */
  public $shortDescription = null;
  /**
   * A long description for this product.
   * 
   * @var string
   */
  public $longDescription = null;
  /**
   * Customer service website of the issuing bank.
   * 
   * @var string
   */
  public $customerServiceUrl = null;
  /**
   * Customer service email address of the issuing bank.
   * 
   * @var string
   */
  public $customerServiceEmail = null;
  /**
   * Customer service phone number of the issuing bank.
   * 
   * @var string
   */
  public $customerServicePhoneNumber = null;
  /**
   * Mobile app of the issuing bank.
   * 
   * @var string
   */
  public $issuerMobileApp = null;
  /**
   * Logon URL for the issuing bank’s online banking website.
   * 
   * @var string
   */
  public $onlineBankingLoginUrl = null;
  /**
   * URL linking to the issuing bank’s terms and conditions for this product.
   * 
   * @var string
   */
  public $termsAndConditionsUrl = null;
  /**
   * URL linking to the issuing bank’s privacy policy for this product.
   * 
   * @var string
   */
  public $privacyPolicyUrl = null;
  /**
   * Freeform identifier for this product configuration as assigned by the issuer.
   * 
   * @var string
   */
  public $issuerProductConfigCode = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'brandLogoAssetId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'issuerLogoAssetId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'isCoBranded',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'coBrandName',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'coBrandLogoAssetId',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'cardBackgroundCombinedAssetId',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'cardBackgroundAssetId',
          'type' => TType::STRING,
          ),
        8 => array(
          'var' => 'iconAssetId',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'foregroundColor',
          'type' => TType::STRING,
          ),
        10 => array(
          'var' => 'issuerName',
          'type' => TType::STRING,
          ),
        11 => array(
          'var' => 'shortDescription',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'longDescription',
          'type' => TType::STRING,
          ),
        13 => array(
          'var' => 'customerServiceUrl',
          'type' => TType::STRING,
          ),
        14 => array(
          'var' => 'customerServiceEmail',
          'type' => TType::STRING,
          ),
        15 => array(
          'var' => 'customerServicePhoneNumber',
          'type' => TType::STRING,
          ),
        16 => array(
          'var' => 'issuerMobileApp',
          'type' => TType::STRING,
          ),
        17 => array(
          'var' => 'onlineBankingLoginUrl',
          'type' => TType::STRING,
          ),
        18 => array(
          'var' => 'termsAndConditionsUrl',
          'type' => TType::STRING,
          ),
        19 => array(
          'var' => 'privacyPolicyUrl',
          'type' => TType::STRING,
          ),
        20 => array(
          'var' => 'issuerProductConfigCode',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['brandLogoAssetId'])) {
        $this->brandLogoAssetId = $vals['brandLogoAssetId'];
      }
      if (isset($vals['issuerLogoAssetId'])) {
        $this->issuerLogoAssetId = $vals['issuerLogoAssetId'];
      }
      if (isset($vals['isCoBranded'])) {
        $this->isCoBranded = $vals['isCoBranded'];
      }
      if (isset($vals['coBrandName'])) {
        $this->coBrandName = $vals['coBrandName'];
      }
      if (isset($vals['coBrandLogoAssetId'])) {
        $this->coBrandLogoAssetId = $vals['coBrandLogoAssetId'];
      }
      if (isset($vals['cardBackgroundCombinedAssetId'])) {
        $this->cardBackgroundCombinedAssetId = $vals['cardBackgroundCombinedAssetId'];
      }
      if (isset($vals['cardBackgroundAssetId'])) {
        $this->cardBackgroundAssetId = $vals['cardBackgroundAssetId'];
      }
      if (isset($vals['iconAssetId'])) {
        $this->iconAssetId = $vals['iconAssetId'];
      }
      if (isset($vals['foregroundColor'])) {
        $this->foregroundColor = $vals['foregroundColor'];
      }
      if (isset($vals['issuerName'])) {
        $this->issuerName = $vals['issuerName'];
      }
      if (isset($vals['shortDescription'])) {
        $this->shortDescription = $vals['shortDescription'];
      }
      if (isset($vals['longDescription'])) {
        $this->longDescription = $vals['longDescription'];
      }
      if (isset($vals['customerServiceUrl'])) {
        $this->customerServiceUrl = $vals['customerServiceUrl'];
      }
      if (isset($vals['customerServiceEmail'])) {
        $this->customerServiceEmail = $vals['customerServiceEmail'];
      }
      if (isset($vals['customerServicePhoneNumber'])) {
        $this->customerServicePhoneNumber = $vals['customerServicePhoneNumber'];
      }
      if (isset($vals['issuerMobileApp'])) {
        $this->issuerMobileApp = $vals['issuerMobileApp'];
      }
      if (isset($vals['onlineBankingLoginUrl'])) {
        $this->onlineBankingLoginUrl = $vals['onlineBankingLoginUrl'];
      }
      if (isset($vals['termsAndConditionsUrl'])) {
        $this->termsAndConditionsUrl = $vals['termsAndConditionsUrl'];
      }
      if (isset($vals['privacyPolicyUrl'])) {
        $this->privacyPolicyUrl = $vals['privacyPolicyUrl'];
      }
      if (isset($vals['issuerProductConfigCode'])) {
        $this->issuerProductConfigCode = $vals['issuerProductConfigCode'];
      }
    }
  }

  public function getName() {
    return 'ProductConfig';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->brandLogoAssetId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->issuerLogoAssetId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->isCoBranded);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->coBrandName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->coBrandLogoAssetId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->cardBackgroundCombinedAssetId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->cardBackgroundAssetId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->iconAssetId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->foregroundColor);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->issuerName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->shortDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->longDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->customerServiceUrl);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->customerServiceEmail);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->customerServicePhoneNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->issuerMobileApp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 17:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->onlineBankingLoginUrl);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 18:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->termsAndConditionsUrl);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 19:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->privacyPolicyUrl);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 20:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->issuerProductConfigCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProductConfig');
    if ($this->brandLogoAssetId !== null) {
      $xfer += $output->writeFieldBegin('brandLogoAssetId', TType::STRING, 1);
      $xfer += $output->writeString($this->brandLogoAssetId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->issuerLogoAssetId !== null) {
      $xfer += $output->writeFieldBegin('issuerLogoAssetId', TType::STRING, 2);
      $xfer += $output->writeString($this->issuerLogoAssetId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->isCoBranded !== null) {
      $xfer += $output->writeFieldBegin('isCoBranded', TType::STRING, 3);
      $xfer += $output->writeString($this->isCoBranded);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->coBrandName !== null) {
      $xfer += $output->writeFieldBegin('coBrandName', TType::STRING, 4);
      $xfer += $output->writeString($this->coBrandName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->coBrandLogoAssetId !== null) {
      $xfer += $output->writeFieldBegin('coBrandLogoAssetId', TType::STRING, 5);
      $xfer += $output->writeString($this->coBrandLogoAssetId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cardBackgroundCombinedAssetId !== null) {
      $xfer += $output->writeFieldBegin('cardBackgroundCombinedAssetId', TType::STRING, 6);
      $xfer += $output->writeString($this->cardBackgroundCombinedAssetId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cardBackgroundAssetId !== null) {
      $xfer += $output->writeFieldBegin('cardBackgroundAssetId', TType::STRING, 7);
      $xfer += $output->writeString($this->cardBackgroundAssetId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->iconAssetId !== null) {
      $xfer += $output->writeFieldBegin('iconAssetId', TType::STRING, 8);
      $xfer += $output->writeString($this->iconAssetId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->foregroundColor !== null) {
      $xfer += $output->writeFieldBegin('foregroundColor', TType::STRING, 9);
      $xfer += $output->writeString($this->foregroundColor);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->issuerName !== null) {
      $xfer += $output->writeFieldBegin('issuerName', TType::STRING, 10);
      $xfer += $output->writeString($this->issuerName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->shortDescription !== null) {
      $xfer += $output->writeFieldBegin('shortDescription', TType::STRING, 11);
      $xfer += $output->writeString($this->shortDescription);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->longDescription !== null) {
      $xfer += $output->writeFieldBegin('longDescription', TType::STRING, 12);
      $xfer += $output->writeString($this->longDescription);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->customerServiceUrl !== null) {
      $xfer += $output->writeFieldBegin('customerServiceUrl', TType::STRING, 13);
      $xfer += $output->writeString($this->customerServiceUrl);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->customerServiceEmail !== null) {
      $xfer += $output->writeFieldBegin('customerServiceEmail', TType::STRING, 14);
      $xfer += $output->writeString($this->customerServiceEmail);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->customerServicePhoneNumber !== null) {
      $xfer += $output->writeFieldBegin('customerServicePhoneNumber', TType::STRING, 15);
      $xfer += $output->writeString($this->customerServicePhoneNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->issuerMobileApp !== null) {
      $xfer += $output->writeFieldBegin('issuerMobileApp', TType::STRING, 16);
      $xfer += $output->writeString($this->issuerMobileApp);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->onlineBankingLoginUrl !== null) {
      $xfer += $output->writeFieldBegin('onlineBankingLoginUrl', TType::STRING, 17);
      $xfer += $output->writeString($this->onlineBankingLoginUrl);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->termsAndConditionsUrl !== null) {
      $xfer += $output->writeFieldBegin('termsAndConditionsUrl', TType::STRING, 18);
      $xfer += $output->writeString($this->termsAndConditionsUrl);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->privacyPolicyUrl !== null) {
      $xfer += $output->writeFieldBegin('privacyPolicyUrl', TType::STRING, 19);
      $xfer += $output->writeString($this->privacyPolicyUrl);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->issuerProductConfigCode !== null) {
      $xfer += $output->writeFieldBegin('issuerProductConfigCode', TType::STRING, 20);
      $xfer += $output->writeString($this->issuerProductConfigCode);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MasterCardEligibilityReceipt {
  static $_TSPEC;

  /**
   * @var string
   */
  public $value = null;
  /**
   * @var string
   */
  public $validForMinutes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'value',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'validForMinutes',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['value'])) {
        $this->value = $vals['value'];
      }
      if (isset($vals['validForMinutes'])) {
        $this->validForMinutes = $vals['validForMinutes'];
      }
    }
  }

  public function getName() {
    return 'MasterCardEligibilityReceipt';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->value);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->validForMinutes);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MasterCardEligibilityReceipt');
    if ($this->value !== null) {
      $xfer += $output->writeFieldBegin('value', TType::STRING, 1);
      $xfer += $output->writeString($this->value);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->validForMinutes !== null) {
      $xfer += $output->writeFieldBegin('validForMinutes', TType::STRING, 2);
      $xfer += $output->writeString($this->validForMinutes);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MasterCardApplicableCardInfo {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $isSecurityCodeApplicable = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'isSecurityCodeApplicable',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['isSecurityCodeApplicable'])) {
        $this->isSecurityCodeApplicable = $vals['isSecurityCodeApplicable'];
      }
    }
  }

  public function getName() {
    return 'MasterCardApplicableCardInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->isSecurityCodeApplicable);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MasterCardApplicableCardInfo');
    if ($this->isSecurityCodeApplicable !== null) {
      $xfer += $output->writeFieldBegin('isSecurityCodeApplicable', TType::BOOL, 1);
      $xfer += $output->writeBool($this->isSecurityCodeApplicable);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MasterCardEligibilityResponse {
  static $_TSPEC;

  /**
   * @var string
   */
  public $responseId = null;
  /**
   * @var \MasterCardEligibilityReceipt
   */
  public $masterCardEligibilityReceipt = null;
  /**
   * @var string
   */
  public $termsAndConditionsAssetId = null;
  /**
   * @var \MasterCardApplicableCardInfo
   */
  public $masterCardApplicableCardInfo = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'responseId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'masterCardEligibilityReceipt',
          'type' => TType::STRUCT,
          'class' => '\MasterCardEligibilityReceipt',
          ),
        3 => array(
          'var' => 'termsAndConditionsAssetId',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'masterCardApplicableCardInfo',
          'type' => TType::STRUCT,
          'class' => '\MasterCardApplicableCardInfo',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['responseId'])) {
        $this->responseId = $vals['responseId'];
      }
      if (isset($vals['masterCardEligibilityReceipt'])) {
        $this->masterCardEligibilityReceipt = $vals['masterCardEligibilityReceipt'];
      }
      if (isset($vals['termsAndConditionsAssetId'])) {
        $this->termsAndConditionsAssetId = $vals['termsAndConditionsAssetId'];
      }
      if (isset($vals['masterCardApplicableCardInfo'])) {
        $this->masterCardApplicableCardInfo = $vals['masterCardApplicableCardInfo'];
      }
    }
  }

  public function getName() {
    return 'MasterCardEligibilityResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->responseId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->masterCardEligibilityReceipt = new \MasterCardEligibilityReceipt();
            $xfer += $this->masterCardEligibilityReceipt->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->termsAndConditionsAssetId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->masterCardApplicableCardInfo = new \MasterCardApplicableCardInfo();
            $xfer += $this->masterCardApplicableCardInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MasterCardEligibilityResponse');
    if ($this->responseId !== null) {
      $xfer += $output->writeFieldBegin('responseId', TType::STRING, 1);
      $xfer += $output->writeString($this->responseId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->masterCardEligibilityReceipt !== null) {
      if (!is_object($this->masterCardEligibilityReceipt)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('masterCardEligibilityReceipt', TType::STRUCT, 2);
      $xfer += $this->masterCardEligibilityReceipt->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->termsAndConditionsAssetId !== null) {
      $xfer += $output->writeFieldBegin('termsAndConditionsAssetId', TType::STRING, 3);
      $xfer += $output->writeString($this->termsAndConditionsAssetId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->masterCardApplicableCardInfo !== null) {
      if (!is_object($this->masterCardApplicableCardInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('masterCardApplicableCardInfo', TType::STRUCT, 4);
      $xfer += $this->masterCardApplicableCardInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * 
 * 
 * for MC - Contains the mobile keys used to secure the communication during subsequent remote management sessions.
 */
class SubjectCardTokenization {
  static $_TSPEC;

  /**
   * The tokenization decision for this digitization request.
   * Values:
   * "APPROVED"
   * "DECLINED"
   * "REQUIRE_ADDITIONAL_AUTHENTICATION"
   * 
   * @var string
   */
  public $decision = null;
  /**
   * When additional authentication is required, this is the list of supported authentication methods.
   * Required if "decision" = "REQUIRE_ADDITIONAL_AUTHENTICATION"
   * 
   * @var \AuthenticationMethod[]
   */
  public $authenticationMethods = null;
  /**
   * For MC:
   * The unique reference allocated to the new Token. Serves as a unique identifier for all subsequent queries or management functions relating to this Token.
   * Required if the decision was APPROVED or REQUIRE_ADDITIONAL_AUTHENTICATION
   * 
   * @var string
   */
  public $tokenID = null;
  /**
   * For MC:
   * The unique reference allocated to the Account Primary Account Number.
   * Required if the decision was APPROVED or REQUIRE_ADDITIONAL_AUTHENTICATION
   * 
   * @var string
   */
  public $panID = null;
  /**
   * Contains all Product Configuration data for this card.
   * 
   * @var \ProductConfig
   */
  public $productConfig = null;
  /**
   * 
   * @var \Token
   */
  public $token = null;
  /**
   * 
   * @var \MasterCardEligibilityResponse
   */
  public $masterCardEligibilityResponse = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'decision',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'authenticationMethods',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\AuthenticationMethod',
            ),
          ),
        3 => array(
          'var' => 'tokenID',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'panID',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'productConfig',
          'type' => TType::STRUCT,
          'class' => '\ProductConfig',
          ),
        6 => array(
          'var' => 'token',
          'type' => TType::STRUCT,
          'class' => '\Token',
          ),
        7 => array(
          'var' => 'masterCardEligibilityResponse',
          'type' => TType::STRUCT,
          'class' => '\MasterCardEligibilityResponse',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['decision'])) {
        $this->decision = $vals['decision'];
      }
      if (isset($vals['authenticationMethods'])) {
        $this->authenticationMethods = $vals['authenticationMethods'];
      }
      if (isset($vals['tokenID'])) {
        $this->tokenID = $vals['tokenID'];
      }
      if (isset($vals['panID'])) {
        $this->panID = $vals['panID'];
      }
      if (isset($vals['productConfig'])) {
        $this->productConfig = $vals['productConfig'];
      }
      if (isset($vals['token'])) {
        $this->token = $vals['token'];
      }
      if (isset($vals['masterCardEligibilityResponse'])) {
        $this->masterCardEligibilityResponse = $vals['masterCardEligibilityResponse'];
      }
    }
  }

  public function getName() {
    return 'SubjectCardTokenization';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->decision);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->authenticationMethods = array();
            $_size155 = 0;
            $_etype158 = 0;
            $xfer += $input->readListBegin($_etype158, $_size155);
            for ($_i159 = 0; $_i159 < $_size155; ++$_i159)
            {
              $elem160 = null;
              $elem160 = new \AuthenticationMethod();
              $xfer += $elem160->read($input);
              $this->authenticationMethods []= $elem160;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenID);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->panID);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->productConfig = new \ProductConfig();
            $xfer += $this->productConfig->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->token = new \Token();
            $xfer += $this->token->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->masterCardEligibilityResponse = new \MasterCardEligibilityResponse();
            $xfer += $this->masterCardEligibilityResponse->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SubjectCardTokenization');
    if ($this->decision !== null) {
      $xfer += $output->writeFieldBegin('decision', TType::STRING, 1);
      $xfer += $output->writeString($this->decision);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->authenticationMethods !== null) {
      if (!is_array($this->authenticationMethods)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('authenticationMethods', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->authenticationMethods));
        {
          foreach ($this->authenticationMethods as $iter161)
          {
            $xfer += $iter161->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tokenID !== null) {
      $xfer += $output->writeFieldBegin('tokenID', TType::STRING, 3);
      $xfer += $output->writeString($this->tokenID);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->panID !== null) {
      $xfer += $output->writeFieldBegin('panID', TType::STRING, 4);
      $xfer += $output->writeString($this->panID);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->productConfig !== null) {
      if (!is_object($this->productConfig)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('productConfig', TType::STRUCT, 5);
      $xfer += $this->productConfig->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->token !== null) {
      if (!is_object($this->token)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('token', TType::STRUCT, 6);
      $xfer += $this->token->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->masterCardEligibilityResponse !== null) {
      if (!is_object($this->masterCardEligibilityResponse)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('masterCardEligibilityResponse', TType::STRUCT, 7);
      $xfer += $this->masterCardEligibilityResponse->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Иерархия общих (чаще всего сервисных) операций.
 * Этот класс описывает операции, не относящися к финансовым (FinancialOperation) или к
 * операциям с профилем клиента (ProfileOperationHistoryItem)
 * 
 */
class CommonOperation {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * Тип операции. Определяет какие аттрибуты будут заполнены. См. описание каждого аттрибута
   * 
   * @var int
   */
  public $type = null;
  /**
   * Набор аттриюутов операции, которые были установлены в процессе ее выполнения или те, которые не вписались в набор перечисленных ниже
   * 
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * условия выполнения операции, обычно заполняются при preface и после execute (в первую очередь для хранений комиссии)
   * 
   * @var \OperationConditions
   */
  public $operationConditions = null;
  /**
   * Название операции. Не обязательный ни для каких операций. Только для удобства поиска клиентом.
   * 
   * @var string
   */
  public $name = null;
  /**
   * Описание операции, "назначение платежа". Не обязательный ни для каких операций. Только для удобства поиска клиентом.
   * 
   * @var string
   */
  public $description = null;
  /**
   * Дата создания операции
   * 
   * @var int
   */
  public $createDate = null;
  /**
   * дата подтверждения клиентом, т.е. дата, когда Ibank убедилось, что операция может быть принята от клиента (например подтверждена расширенной аутентификацией)
   * 
   * @var int
   */
  public $approveDate = null;
  /**
   * дата процессирования операции (передачи в банковские системы).
   * 
   * @var int
   */
  public $processeDate = null;
  /**
   * дата предписанного выполнения операции. может присутствовать если операцию необходимо выполнять не в момент ее подтверждения, а позже или раньше (возможно для CASH_TRANSFER)
   * 
   * @var int
   */
  public $executeDate = null;
  /**
   * статус операции. обязательно присутсвует если операция уже прошла executeXxxOperation
   * 
   * @var int
   */
  public $status = null;
  /**
   * теги, которые пользователь повесил на операцию, или которые появились автоматически (например перешли с шаблона)
   * 
   * @var \Tag[]
   */
  public $tags = null;
  /**
   * если эта операция выполнялась на основании шаблона (если операция поддерживает шаблонирование), то этот параметр ссылается на ID шаблона.
   * 
   * @var string
   */
  public $templateId = null;
  /**
   * Контракт (счет), с которого списывается возможная комиссия за операцию.
   *  * Обязательный в случае если при обработке правил вычеслена ненулевая комиссия.
   * *
   * 
   * @var \ContractReference
   */
  public $srcContractRef = null;
  /**
   * Контракт (счет), к которому относится эта операция. Может совпадать с srcContractRef.
   * Обязателен для операций: lockCard, unlockCard, changeLimit
   * 
   * 
   * @var \ContractReference
   */
  public $dstContractRef = null;
  /**
   * В случае если операция относится к конкретной карте в рамках карт-контракта,
   * указывается маска карты в формате 1234********5678 (4 цифры, 8 звездочек, 4 цифры).
   * Обязательное только для сервисных операций с картами (lockCard, unlockCard, changeLimit в случае если тип контракта карточный и лимит на карту
   * 
   * 
   * @var string
   */
  public $dstCardNumberMask = null;
  /**
   * Реквизиты операции изменения лимитов счета или карты. Собственно лимит, который был предписан к установке
   * Обязательное только для операции changeLimit
   * 
   * 
   * @var \Limit
   */
  public $subjectChangeLimit = null;
  /**
   * Идентификатор, который присвоен интегрционным слоем этой операции.
   * Может отсутствовать в период между отправкой этой операции (APPROVED) и реальной обработкой в банке (PROCESSED),
   * если операция отгружается через канал, работающий асинхронно (postponed).
   * 
   * 
   * @var string
   */
  public $externalOperationId = null;
  /**
   * @var \SubjectDeviceRegistration
   */
  public $subjectDeviceRegistration = null;
  /**
   * @var \SubjectCardTokenization
   */
  public $subjectCardTokenization = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        4 => array(
          'var' => 'operationConditions',
          'type' => TType::STRUCT,
          'class' => '\OperationConditions',
          ),
        5 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'createDate',
          'type' => TType::I64,
          ),
        10 => array(
          'var' => 'approveDate',
          'type' => TType::I64,
          ),
        11 => array(
          'var' => 'processeDate',
          'type' => TType::I64,
          ),
        12 => array(
          'var' => 'executeDate',
          'type' => TType::I64,
          ),
        13 => array(
          'var' => 'status',
          'type' => TType::I32,
          ),
        14 => array(
          'var' => 'tags',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Tag',
            ),
          ),
        15 => array(
          'var' => 'templateId',
          'type' => TType::STRING,
          ),
        16 => array(
          'var' => 'srcContractRef',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        17 => array(
          'var' => 'dstContractRef',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        18 => array(
          'var' => 'dstCardNumberMask',
          'type' => TType::STRING,
          ),
        19 => array(
          'var' => 'subjectChangeLimit',
          'type' => TType::STRUCT,
          'class' => '\Limit',
          ),
        20 => array(
          'var' => 'externalOperationId',
          'type' => TType::STRING,
          ),
        21 => array(
          'var' => 'subjectDeviceRegistration',
          'type' => TType::STRUCT,
          'class' => '\SubjectDeviceRegistration',
          ),
        22 => array(
          'var' => 'subjectCardTokenization',
          'type' => TType::STRUCT,
          'class' => '\SubjectCardTokenization',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['operationConditions'])) {
        $this->operationConditions = $vals['operationConditions'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['createDate'])) {
        $this->createDate = $vals['createDate'];
      }
      if (isset($vals['approveDate'])) {
        $this->approveDate = $vals['approveDate'];
      }
      if (isset($vals['processeDate'])) {
        $this->processeDate = $vals['processeDate'];
      }
      if (isset($vals['executeDate'])) {
        $this->executeDate = $vals['executeDate'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
      if (isset($vals['templateId'])) {
        $this->templateId = $vals['templateId'];
      }
      if (isset($vals['srcContractRef'])) {
        $this->srcContractRef = $vals['srcContractRef'];
      }
      if (isset($vals['dstContractRef'])) {
        $this->dstContractRef = $vals['dstContractRef'];
      }
      if (isset($vals['dstCardNumberMask'])) {
        $this->dstCardNumberMask = $vals['dstCardNumberMask'];
      }
      if (isset($vals['subjectChangeLimit'])) {
        $this->subjectChangeLimit = $vals['subjectChangeLimit'];
      }
      if (isset($vals['externalOperationId'])) {
        $this->externalOperationId = $vals['externalOperationId'];
      }
      if (isset($vals['subjectDeviceRegistration'])) {
        $this->subjectDeviceRegistration = $vals['subjectDeviceRegistration'];
      }
      if (isset($vals['subjectCardTokenization'])) {
        $this->subjectCardTokenization = $vals['subjectCardTokenization'];
      }
    }
  }

  public function getName() {
    return 'CommonOperation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->operationConditions = new \OperationConditions();
            $xfer += $this->operationConditions->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->createDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->approveDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->processeDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->executeDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::LST) {
            $this->tags = array();
            $_size162 = 0;
            $_etype165 = 0;
            $xfer += $input->readListBegin($_etype165, $_size162);
            for ($_i166 = 0; $_i166 < $_size162; ++$_i166)
            {
              $elem167 = null;
              $elem167 = new \Tag();
              $xfer += $elem167->read($input);
              $this->tags []= $elem167;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->templateId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::STRUCT) {
            $this->srcContractRef = new \ContractReference();
            $xfer += $this->srcContractRef->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 17:
          if ($ftype == TType::STRUCT) {
            $this->dstContractRef = new \ContractReference();
            $xfer += $this->dstContractRef->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 18:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->dstCardNumberMask);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 19:
          if ($ftype == TType::STRUCT) {
            $this->subjectChangeLimit = new \Limit();
            $xfer += $this->subjectChangeLimit->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 20:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->externalOperationId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 21:
          if ($ftype == TType::STRUCT) {
            $this->subjectDeviceRegistration = new \SubjectDeviceRegistration();
            $xfer += $this->subjectDeviceRegistration->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 22:
          if ($ftype == TType::STRUCT) {
            $this->subjectCardTokenization = new \SubjectCardTokenization();
            $xfer += $this->subjectCardTokenization->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CommonOperation');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 2);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 3);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationConditions !== null) {
      if (!is_object($this->operationConditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationConditions', TType::STRUCT, 4);
      $xfer += $this->operationConditions->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 5);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 6);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createDate !== null) {
      $xfer += $output->writeFieldBegin('createDate', TType::I64, 9);
      $xfer += $output->writeI64($this->createDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approveDate !== null) {
      $xfer += $output->writeFieldBegin('approveDate', TType::I64, 10);
      $xfer += $output->writeI64($this->approveDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->processeDate !== null) {
      $xfer += $output->writeFieldBegin('processeDate', TType::I64, 11);
      $xfer += $output->writeI64($this->processeDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executeDate !== null) {
      $xfer += $output->writeFieldBegin('executeDate', TType::I64, 12);
      $xfer += $output->writeI64($this->executeDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::I32, 13);
      $xfer += $output->writeI32($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::LST, 14);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tags));
        {
          foreach ($this->tags as $iter168)
          {
            $xfer += $iter168->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->templateId !== null) {
      $xfer += $output->writeFieldBegin('templateId', TType::STRING, 15);
      $xfer += $output->writeString($this->templateId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->srcContractRef !== null) {
      if (!is_object($this->srcContractRef)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('srcContractRef', TType::STRUCT, 16);
      $xfer += $this->srcContractRef->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dstContractRef !== null) {
      if (!is_object($this->dstContractRef)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dstContractRef', TType::STRUCT, 17);
      $xfer += $this->dstContractRef->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dstCardNumberMask !== null) {
      $xfer += $output->writeFieldBegin('dstCardNumberMask', TType::STRING, 18);
      $xfer += $output->writeString($this->dstCardNumberMask);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectChangeLimit !== null) {
      if (!is_object($this->subjectChangeLimit)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectChangeLimit', TType::STRUCT, 19);
      $xfer += $this->subjectChangeLimit->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->externalOperationId !== null) {
      $xfer += $output->writeFieldBegin('externalOperationId', TType::STRING, 20);
      $xfer += $output->writeString($this->externalOperationId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectDeviceRegistration !== null) {
      if (!is_object($this->subjectDeviceRegistration)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectDeviceRegistration', TType::STRUCT, 21);
      $xfer += $this->subjectDeviceRegistration->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectCardTokenization !== null) {
      if (!is_object($this->subjectCardTokenization)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectCardTokenization', TType::STRUCT, 22);
      $xfer += $this->subjectCardTokenization->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Иерархия финансовых операций. Состоит из сборника всех свойств всех финансовых операций.
 * Необходима из-за отсутсвия наследования и полиморфизма, в случае, когда нужно вернуть список
 * операций за период, например, а список содержит разнородные элементы: P2P, CashExpense, Contract2Contract и др.
 * 
 */
class FinancialOperation {
  static $_TSPEC;

  /**
   * @var string
   */
  public $id = null;
  /**
   * Тип операции. Определяет какие аттрибуты будут заполнены. См. описание каждого аттрибута
   * 
   * @var int
   */
  public $type = null;
  /**
   * Набор аттриюутов операции, которые были установлены в процессе ее выполнения или те, которые не вписались в набор перечисленных ниже
   * 
   * @var \Attributes
   */
  public $attributes = null;
  /**
   * условия выполнения операции, обычно заполняются при preface и после execute (в первую очередь для хранений комиссии)
   * 
   * @var \OperationConditions
   */
  public $operationConditions = null;
  /**
   * Название операции. Обязательно только для CASH_TRANSFER
   * 
   * @var string
   */
  public $name = null;
  /**
   * Описание операции, "назначение платежа". Обязательно только для
   * 
   * @var string
   */
  public $description = null;
  /**
   * сумма операции, всегда обязательна для финансовой операции
   * 
   * @var int
   */
  public $amountInCents = null;
  /**
   * валюта операции, может отсутсвовать только на этапе prefaceOperation() когда валюта автоматически определяется
   * 
   * @var string
   */
  public $currency = null;
  /**
   * дата создания. отсутствует в случае работы с prefaceXxxOperation()
   * 
   * @var int
   */
  public $createDate = null;
  /**
   * дата подтверждения клиентом. отсутствует в случае работы с prefaceXxxOperation()
   * 
   * @var int
   */
  public $approveDate = null;
  /**
   * дата процессирования операции (передачи в банковские системы). отсутствует в случае работы с prefaceXxxOperation()
   * 
   * @var int
   */
  public $processeDate = null;
  /**
   * дата предписанного выполнения операции. может присутствовать если операцию необходимо выполнять не в момент ее подтверждения, а позже или раньше (возможно для CASH_TRANSFER)
   * 
   * @var int
   */
  public $executeDate = null;
  /**
   * статус операции. обязательно присутсвует если операция уже прошла executeXxxOperation
   * 
   * @var int
   */
  public $status = null;
  /**
   * теги, которые пользователь повесил на операцию, или которые появились автоматически (например перешли с шаблона)
   * 
   * @var \Tag[]
   */
  public $tags = null;
  /**
   * если эта операция выполнялась на основании шаблона, то этот параметр ссылается на ID шаблона. на этапе preface() или execute() игнорируется, может быть установлен только методами execute|prefaceOperationTemplate()
   * 
   * @var string
   */
  public $templateId = null;
  /**
   * Контракт (счет), с которого списываются средства для операции. Обязательное для всех типов, кроме CASH_TRANSFER
   * 
   * @var \ContractReference
   */
  public $srcContractRef = null;
  /**
   * Контракт (счет), на который происходит пополнение. Обязательное для CONTRACT_TO_CONTRACT
   * 
   * @var \ContractReference
   */
  public $dstContractRef = null;
  /**
   * Идентификатор, который присвоен интегрционным слоем этой операции.
   * Может отсутствовать в период между отправкой этой операции (APPROVED) и реальной обработкой в банке (PROCESSED),
   * если операция отгружается через канал, работающий асинхронно (postponed).
   * 
   * 
   * @var string
   */
  public $externalOperationId = null;
  /**
   * аггрегатор реквизитов операций
   * 
   * @var \FinancialOperationSubject
   */
  public $subject = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        4 => array(
          'var' => 'operationConditions',
          'type' => TType::STRUCT,
          'class' => '\OperationConditions',
          ),
        5 => array(
          'var' => 'name',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'description',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'amountInCents',
          'type' => TType::I64,
          ),
        8 => array(
          'var' => 'currency',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'createDate',
          'type' => TType::I64,
          ),
        10 => array(
          'var' => 'approveDate',
          'type' => TType::I64,
          ),
        11 => array(
          'var' => 'processeDate',
          'type' => TType::I64,
          ),
        12 => array(
          'var' => 'executeDate',
          'type' => TType::I64,
          ),
        13 => array(
          'var' => 'status',
          'type' => TType::I32,
          ),
        14 => array(
          'var' => 'tags',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\Tag',
            ),
          ),
        15 => array(
          'var' => 'templateId',
          'type' => TType::STRING,
          ),
        16 => array(
          'var' => 'srcContractRef',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        17 => array(
          'var' => 'dstContractRef',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        23 => array(
          'var' => 'externalOperationId',
          'type' => TType::STRING,
          ),
        24 => array(
          'var' => 'subject',
          'type' => TType::STRUCT,
          'class' => '\FinancialOperationSubject',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
      if (isset($vals['operationConditions'])) {
        $this->operationConditions = $vals['operationConditions'];
      }
      if (isset($vals['name'])) {
        $this->name = $vals['name'];
      }
      if (isset($vals['description'])) {
        $this->description = $vals['description'];
      }
      if (isset($vals['amountInCents'])) {
        $this->amountInCents = $vals['amountInCents'];
      }
      if (isset($vals['currency'])) {
        $this->currency = $vals['currency'];
      }
      if (isset($vals['createDate'])) {
        $this->createDate = $vals['createDate'];
      }
      if (isset($vals['approveDate'])) {
        $this->approveDate = $vals['approveDate'];
      }
      if (isset($vals['processeDate'])) {
        $this->processeDate = $vals['processeDate'];
      }
      if (isset($vals['executeDate'])) {
        $this->executeDate = $vals['executeDate'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['tags'])) {
        $this->tags = $vals['tags'];
      }
      if (isset($vals['templateId'])) {
        $this->templateId = $vals['templateId'];
      }
      if (isset($vals['srcContractRef'])) {
        $this->srcContractRef = $vals['srcContractRef'];
      }
      if (isset($vals['dstContractRef'])) {
        $this->dstContractRef = $vals['dstContractRef'];
      }
      if (isset($vals['externalOperationId'])) {
        $this->externalOperationId = $vals['externalOperationId'];
      }
      if (isset($vals['subject'])) {
        $this->subject = $vals['subject'];
      }
    }
  }

  public function getName() {
    return 'FinancialOperation';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->operationConditions = new \OperationConditions();
            $xfer += $this->operationConditions->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->name);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->description);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->amountInCents);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->currency);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->createDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->approveDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->processeDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->executeDate);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 13:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 14:
          if ($ftype == TType::LST) {
            $this->tags = array();
            $_size169 = 0;
            $_etype172 = 0;
            $xfer += $input->readListBegin($_etype172, $_size169);
            for ($_i173 = 0; $_i173 < $_size169; ++$_i173)
            {
              $elem174 = null;
              $elem174 = new \Tag();
              $xfer += $elem174->read($input);
              $this->tags []= $elem174;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 15:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->templateId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 16:
          if ($ftype == TType::STRUCT) {
            $this->srcContractRef = new \ContractReference();
            $xfer += $this->srcContractRef->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 17:
          if ($ftype == TType::STRUCT) {
            $this->dstContractRef = new \ContractReference();
            $xfer += $this->dstContractRef->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 23:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->externalOperationId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 24:
          if ($ftype == TType::STRUCT) {
            $this->subject = new \FinancialOperationSubject();
            $xfer += $this->subject->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('FinancialOperation');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 2);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 3);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->operationConditions !== null) {
      if (!is_object($this->operationConditions)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('operationConditions', TType::STRUCT, 4);
      $xfer += $this->operationConditions->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->name !== null) {
      $xfer += $output->writeFieldBegin('name', TType::STRING, 5);
      $xfer += $output->writeString($this->name);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->description !== null) {
      $xfer += $output->writeFieldBegin('description', TType::STRING, 6);
      $xfer += $output->writeString($this->description);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->amountInCents !== null) {
      $xfer += $output->writeFieldBegin('amountInCents', TType::I64, 7);
      $xfer += $output->writeI64($this->amountInCents);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->currency !== null) {
      $xfer += $output->writeFieldBegin('currency', TType::STRING, 8);
      $xfer += $output->writeString($this->currency);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->createDate !== null) {
      $xfer += $output->writeFieldBegin('createDate', TType::I64, 9);
      $xfer += $output->writeI64($this->createDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->approveDate !== null) {
      $xfer += $output->writeFieldBegin('approveDate', TType::I64, 10);
      $xfer += $output->writeI64($this->approveDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->processeDate !== null) {
      $xfer += $output->writeFieldBegin('processeDate', TType::I64, 11);
      $xfer += $output->writeI64($this->processeDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->executeDate !== null) {
      $xfer += $output->writeFieldBegin('executeDate', TType::I64, 12);
      $xfer += $output->writeI64($this->executeDate);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::I32, 13);
      $xfer += $output->writeI32($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tags !== null) {
      if (!is_array($this->tags)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('tags', TType::LST, 14);
      {
        $output->writeListBegin(TType::STRUCT, count($this->tags));
        {
          foreach ($this->tags as $iter175)
          {
            $xfer += $iter175->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->templateId !== null) {
      $xfer += $output->writeFieldBegin('templateId', TType::STRING, 15);
      $xfer += $output->writeString($this->templateId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->srcContractRef !== null) {
      if (!is_object($this->srcContractRef)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('srcContractRef', TType::STRUCT, 16);
      $xfer += $this->srcContractRef->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->dstContractRef !== null) {
      if (!is_object($this->dstContractRef)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('dstContractRef', TType::STRUCT, 17);
      $xfer += $this->dstContractRef->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->externalOperationId !== null) {
      $xfer += $output->writeFieldBegin('externalOperationId', TType::STRING, 23);
      $xfer += $output->writeString($this->externalOperationId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subject !== null) {
      if (!is_object($this->subject)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subject', TType::STRUCT, 24);
      $xfer += $this->subject->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * The response to some offer.
 */
class OfferResponse {
  static $_TSPEC;

  /**
   * Unique offer response ID
   * 
   * @var string
   */
  public $id = null;
  /**
   * ID of originating offer (the Offer to which this OfferResponse was answered)
   * 
   * @var string
   */
  public $offerId = null;
  /**
   * What kind of response was given (accepting, rejecting, etc.)
   * 
   * @var int
   */
  public $type = null;
  /**
   * Some client's explanation why he/she answered that way. Used mostly for not-accepting types (reason of rejection).
   * 
   * @var string
   */
  public $responseReason = null;
  /**
   * If offer supposed to be answered by some kind of operation and it really was answered with some operation (e.g. feedback operation or even make deposit, etc.)
   * 
   * @var string
   */
  public $callToActionOperationId = null;
  /**
   * Attributes for functinal extensions
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'offerId',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'responseReason',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'callToActionOperationId',
          'type' => TType::STRING,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['offerId'])) {
        $this->offerId = $vals['offerId'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['responseReason'])) {
        $this->responseReason = $vals['responseReason'];
      }
      if (isset($vals['callToActionOperationId'])) {
        $this->callToActionOperationId = $vals['callToActionOperationId'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'OfferResponse';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->offerId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->responseReason);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->callToActionOperationId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OfferResponse');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->offerId !== null) {
      $xfer += $output->writeFieldBegin('offerId', TType::STRING, 2);
      $xfer += $output->writeString($this->offerId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 3);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->responseReason !== null) {
      $xfer += $output->writeFieldBegin('responseReason', TType::STRING, 4);
      $xfer += $output->writeString($this->responseReason);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->callToActionOperationId !== null) {
      $xfer += $output->writeFieldBegin('callToActionOperationId', TType::STRING, 5);
      $xfer += $output->writeString($this->callToActionOperationId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Incoming information offered to client.
 * It could be some advertisement, incoming messages from Bank or other service provider.
 */
class Offer {
  static $_TSPEC;

  /**
   * Unique offer ID
   * 
   * @var string
   */
  public $id = null;
  /**
   * Offer status describes should offer be shown to Client or not
   * 
   * @var int
   */
  public $status = null;
  /**
   * Describes channel type for which this offer is adopted (it's recommended to ask the offers only for channel which is now used by client)
   * 
   * @var int
   */
  public $channelType = null;
  /**
   * Offer content. It contains the binary data adopted to asked channel type
   * 
   * @var \Base64BinaryData
   */
  public $mainContent = null;
  /**
   * Additional offer content. E.g. here could be images or attached files, mentioned somewhere in main content, etc.
   * 
   * @var array
   */
  public $additionalContentParts = null;
  /**
   * Response typed supposed for this offer. E.g. if offer is just for information, it's only one response type allowed: ACCEPT (in this situation means 'Mark as read')
   * 
   * @var int[]
   */
  public $allowedResponseTypes = null;
  /**
   * If there are responses made by client, they are listed here. List is not provided when Offer is one of just fetched Offers. It is provided only for fetchOffer() request
   * 
   * @var \OfferResponse[]
   */
  public $offerResponses = null;
  /**
   * If offer suppose to be reacted by some operation (e.g. if Offer is proposal for do some charity, the SEPTransfer template may be provided here)
   * 
   * @var \OperationTemplate
   */
  public $callToActionTemplate = null;
  /**
   * If offer has POSTPONED status, here is the date-time till Client should not be disturbed with this Offer
   * 
   * @var int
   */
  public $postponedTo = null;
  /**
   * Attributes for functinal extensions
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'id',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'status',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'channelType',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'mainContent',
          'type' => TType::STRUCT,
          'class' => '\Base64BinaryData',
          ),
        5 => array(
          'var' => 'additionalContentParts',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRUCT,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRUCT,
            'class' => '\Base64BinaryData',
            ),
          ),
        6 => array(
          'var' => 'allowedResponseTypes',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        7 => array(
          'var' => 'offerResponses',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\OfferResponse',
            ),
          ),
        8 => array(
          'var' => 'callToActionTemplate',
          'type' => TType::STRUCT,
          'class' => '\OperationTemplate',
          ),
        9 => array(
          'var' => 'postponedTo',
          'type' => TType::I64,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['id'])) {
        $this->id = $vals['id'];
      }
      if (isset($vals['status'])) {
        $this->status = $vals['status'];
      }
      if (isset($vals['channelType'])) {
        $this->channelType = $vals['channelType'];
      }
      if (isset($vals['mainContent'])) {
        $this->mainContent = $vals['mainContent'];
      }
      if (isset($vals['additionalContentParts'])) {
        $this->additionalContentParts = $vals['additionalContentParts'];
      }
      if (isset($vals['allowedResponseTypes'])) {
        $this->allowedResponseTypes = $vals['allowedResponseTypes'];
      }
      if (isset($vals['offerResponses'])) {
        $this->offerResponses = $vals['offerResponses'];
      }
      if (isset($vals['callToActionTemplate'])) {
        $this->callToActionTemplate = $vals['callToActionTemplate'];
      }
      if (isset($vals['postponedTo'])) {
        $this->postponedTo = $vals['postponedTo'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'Offer';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->id);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->status);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->channelType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->mainContent = new \Base64BinaryData();
            $xfer += $this->mainContent->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::MAP) {
            $this->additionalContentParts = array();
            $_size176 = 0;
            $_ktype177 = 0;
            $_vtype178 = 0;
            $xfer += $input->readMapBegin($_ktype177, $_vtype178, $_size176);
            for ($_i180 = 0; $_i180 < $_size176; ++$_i180)
            {
              $key181 = '';
              $val182 = new \Base64BinaryData();
              $xfer += $input->readString($key181);
              $val182 = new \Base64BinaryData();
              $xfer += $val182->read($input);
              $this->additionalContentParts[$key181] = $val182;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::LST) {
            $this->allowedResponseTypes = array();
            $_size183 = 0;
            $_etype186 = 0;
            $xfer += $input->readListBegin($_etype186, $_size183);
            for ($_i187 = 0; $_i187 < $_size183; ++$_i187)
            {
              $elem188 = null;
              $xfer += $input->readI32($elem188);
              $this->allowedResponseTypes []= $elem188;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::LST) {
            $this->offerResponses = array();
            $_size189 = 0;
            $_etype192 = 0;
            $xfer += $input->readListBegin($_etype192, $_size189);
            for ($_i193 = 0; $_i193 < $_size189; ++$_i193)
            {
              $elem194 = null;
              $elem194 = new \OfferResponse();
              $xfer += $elem194->read($input);
              $this->offerResponses []= $elem194;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRUCT) {
            $this->callToActionTemplate = new \OperationTemplate();
            $xfer += $this->callToActionTemplate->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->postponedTo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Offer');
    if ($this->id !== null) {
      $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
      $xfer += $output->writeString($this->id);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->status !== null) {
      $xfer += $output->writeFieldBegin('status', TType::I32, 2);
      $xfer += $output->writeI32($this->status);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->channelType !== null) {
      $xfer += $output->writeFieldBegin('channelType', TType::I32, 3);
      $xfer += $output->writeI32($this->channelType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->mainContent !== null) {
      if (!is_object($this->mainContent)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('mainContent', TType::STRUCT, 4);
      $xfer += $this->mainContent->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->additionalContentParts !== null) {
      if (!is_array($this->additionalContentParts)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('additionalContentParts', TType::MAP, 5);
      {
        $output->writeMapBegin(TType::STRING, TType::STRUCT, count($this->additionalContentParts));
        {
          foreach ($this->additionalContentParts as $kiter195 => $viter196)
          {
            $xfer += $output->writeString($kiter195);
            $xfer += $viter196->write($output);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->allowedResponseTypes !== null) {
      if (!is_array($this->allowedResponseTypes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('allowedResponseTypes', TType::LST, 6);
      {
        $output->writeListBegin(TType::I32, count($this->allowedResponseTypes));
        {
          foreach ($this->allowedResponseTypes as $iter197)
          {
            $xfer += $output->writeI32($iter197);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->offerResponses !== null) {
      if (!is_array($this->offerResponses)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('offerResponses', TType::LST, 7);
      {
        $output->writeListBegin(TType::STRUCT, count($this->offerResponses));
        {
          foreach ($this->offerResponses as $iter198)
          {
            $xfer += $iter198->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->callToActionTemplate !== null) {
      if (!is_object($this->callToActionTemplate)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('callToActionTemplate', TType::STRUCT, 8);
      $xfer += $this->callToActionTemplate->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->postponedTo !== null) {
      $xfer += $output->writeFieldBegin('postponedTo', TType::I64, 9);
      $xfer += $output->writeI64($this->postponedTo);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Filter for fetching Offers.
 */
class OfferFilter {
  static $_TSPEC;

  /**
   * For what channel the Offers wil be fetched. It will define the Offer content. However if
   * 
   * @var int
   */
  public $channelType = null;
  /**
   * Offers in which statuses should be fetched. Empty list will raise error
   * 
   * @var int[]
   */
  public $allowedStatuses = null;
  /**
   * To fetch only offers with/without responses or no matter
   * 
   * @var int
   */
  public $havingResponses = null;
  /**
   * To fetch only offers with/without call-to-action operation or no matter
   * 
   * @var int
   */
  public $havingCallToActionOperation = null;
  /**
   * Attributes for functinal extensions
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'channelType',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'allowedStatuses',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        3 => array(
          'var' => 'havingResponses',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'havingCallToActionOperation',
          'type' => TType::I32,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['channelType'])) {
        $this->channelType = $vals['channelType'];
      }
      if (isset($vals['allowedStatuses'])) {
        $this->allowedStatuses = $vals['allowedStatuses'];
      }
      if (isset($vals['havingResponses'])) {
        $this->havingResponses = $vals['havingResponses'];
      }
      if (isset($vals['havingCallToActionOperation'])) {
        $this->havingCallToActionOperation = $vals['havingCallToActionOperation'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'OfferFilter';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->channelType);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->allowedStatuses = array();
            $_size199 = 0;
            $_etype202 = 0;
            $xfer += $input->readListBegin($_etype202, $_size199);
            for ($_i203 = 0; $_i203 < $_size199; ++$_i203)
            {
              $elem204 = null;
              $xfer += $input->readI32($elem204);
              $this->allowedStatuses []= $elem204;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->havingResponses);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->havingCallToActionOperation);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OfferFilter');
    if ($this->channelType !== null) {
      $xfer += $output->writeFieldBegin('channelType', TType::I32, 1);
      $xfer += $output->writeI32($this->channelType);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->allowedStatuses !== null) {
      if (!is_array($this->allowedStatuses)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('allowedStatuses', TType::LST, 2);
      {
        $output->writeListBegin(TType::I32, count($this->allowedStatuses));
        {
          foreach ($this->allowedStatuses as $iter205)
          {
            $xfer += $output->writeI32($iter205);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->havingResponses !== null) {
      $xfer += $output->writeFieldBegin('havingResponses', TType::I32, 3);
      $xfer += $output->writeI32($this->havingResponses);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->havingCallToActionOperation !== null) {
      $xfer += $output->writeFieldBegin('havingCallToActionOperation', TType::I32, 4);
      $xfer += $output->writeI32($this->havingCallToActionOperation);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Remoute Notification Service (e.g. GoogleCloudMesseging) registration information
 */
class RnsInfo {
  static $_TSPEC;

  /**
   * Will pack on server to com.mastercard.walletservices.mdes.RnsInfo object for MC
   * 
   * @var string
   */
  public $gcmRegistrationId = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'gcmRegistrationId',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['gcmRegistrationId'])) {
        $this->gcmRegistrationId = $vals['gcmRegistrationId'];
      }
    }
  }

  public function getName() {
    return 'RnsInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->gcmRegistrationId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RnsInfo');
    if ($this->gcmRegistrationId !== null) {
      $xfer += $output->writeFieldBegin('gcmRegistrationId', TType::STRING, 1);
      $xfer += $output->writeString($this->gcmRegistrationId);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * For MasetrCard only "token" and "deviceRegistrationForm.cardPaymentSystem" must be present at the call
 * For MasterCard Response data contains a file of MIME type "application/pkix-cert" according to RFC 2585.
 * Used to wrap rgk!
 * At CommonOperation.subjectDeviceRegistration.masterCardMobileKeys.publicKeyCertificate will
 * returned x509 certificate of public key in base64 encoded format (can be changed)
 */
class DeviceRegistrationForm {
  static $_TSPEC;

  /**
   * CardPaymentSystem enum
   * Values must be:
   * "VISA"
   * "MASTERCARD". <br>
   * Required for:<br>StartDeviceRegistraqtion<br>FinishDeviceRegistration
   * 
   * @var int
   */
  public $cardPaymentSystem = null;
  /**
   * RnsInfo structre. Contain in the field "gcmRegistrationId" identificator of Remoute Notification Service.
   * <br>Required for:<br>FinishDeviceRegistration
   * 
   * @var \RnsInfo
   */
  public $rnsInfo = null;
  /**
   * Unique device fingerprint, which is a SHA-256 hash computed over a list of data elements retrieved from the Mobile Payment App and the Mobile Device.
   *   calculateDeviceFingerPrint of com.mastercard.mcbp.core.AndroidMobileDeviceInfo for MC
   * <br>Required for:<br>FinishDeviceRegistration
   * 
   * @var string
   */
  public $deviceFingerprint = null;
  /**
   * The new Mobile PIN value as chosen by the user, to be updated in MDES.
   * The Mobile PIN value is supplied as a Format 4 PIN Block using a substitute value for the PAN as specified in Section 4.1.3.2, encrypted using the given "rgk".
   * <br>Required for:<br>FinishDeviceRegistration
   * 
   * @var string
   */
  public $newMobilePin = null;
  /**
   * Attributes spesific for different payment systems look in to root structure documentation
   * <br>Required for:<br>FinishDeviceRegistration
   * <br>
   * <br>publicKeyFingerprint key - String type.
   *                        The certificate fingerprint identifying the public key used to encrypt the randomly-generated AES key ("rgk").
   * <br>rgk key            - String type.
   *                        Randomly-generated 128-bit AES key, encrypted by the MasterCard public key (provided during onboarding) using OAEP with SHA-256 hashing algorithm
   *                        Must be saved (generated?) at the mobile device side due to using as key for decript of  MobileKeys...
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cardPaymentSystem',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'rnsInfo',
          'type' => TType::STRUCT,
          'class' => '\RnsInfo',
          ),
        3 => array(
          'var' => 'deviceFingerprint',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'newMobilePin',
          'type' => TType::STRING,
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['cardPaymentSystem'])) {
        $this->cardPaymentSystem = $vals['cardPaymentSystem'];
      }
      if (isset($vals['rnsInfo'])) {
        $this->rnsInfo = $vals['rnsInfo'];
      }
      if (isset($vals['deviceFingerprint'])) {
        $this->deviceFingerprint = $vals['deviceFingerprint'];
      }
      if (isset($vals['newMobilePin'])) {
        $this->newMobilePin = $vals['newMobilePin'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'DeviceRegistrationForm';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->cardPaymentSystem);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->rnsInfo = new \RnsInfo();
            $xfer += $this->rnsInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->deviceFingerprint);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->newMobilePin);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeviceRegistrationForm');
    if ($this->cardPaymentSystem !== null) {
      $xfer += $output->writeFieldBegin('cardPaymentSystem', TType::I32, 1);
      $xfer += $output->writeI32($this->cardPaymentSystem);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->rnsInfo !== null) {
      if (!is_object($this->rnsInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('rnsInfo', TType::STRUCT, 2);
      $xfer += $this->rnsInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deviceFingerprint !== null) {
      $xfer += $output->writeFieldBegin('deviceFingerprint', TType::STRING, 3);
      $xfer += $output->writeString($this->deviceFingerprint);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newMobilePin !== null) {
      $xfer += $output->writeFieldBegin('newMobilePin', TType::STRING, 4);
      $xfer += $output->writeString($this->newMobilePin);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class DeviceInfo {
  static $_TSPEC;

  /**
   * The name that the Cardholder has associated
   * to the target provisioned device (or device being provisioned).
   * 
   * @var string
   */
  public $deviceName = null;
  /**
   * The serial number of the target provisioned device
   * (or device being provisioned). May be masked.
   * 
   * @var string
   */
  public $serialNumber = null;
  /**
   * The form factor of the target provisioned device
   * (or device being provisioned).
   * Must be one of:
   * "PHONE" - Mobile phone.
   * "TABLET_OR_EREADER" - Tablet computer or e-reader.
   * "WATCH_OR_WRISTBAND" - Watch or wristband, including a fitness band, smart strap, disposable band, watch add-on, security / ID Band
   * "CARD" - Card
   * "STICKER" - Sticker
   * "PC" - PC or Laptop
   * "DEVICE_PERIPHERAL"
   * "TAG"
   * "JEWELRY"
   * "FASHION_ACCESSORY"
   * "GARMENT"
   * "DOMESTIC_APPLIANCE"
   * "VEHICLE"
   * "MEDIA_OR_GAMING_DEVICE"
   * 
   * @var string
   */
  public $formFactor = null;
  /**
   * The architecture or technology used for token storage.
   * Must be one of:
   * "DEVICE_MEMORY" - Device memory.
   * "DEVICE_MEMORY_PROTECTED_TPM" - Device memory using a protected trust platform module.
   * "TEE" - Trusted execution environment.
   * "SE" - Secure element.
   * "SERVER" - Server host.
   * "VEE" - Virtual execution environment.
   * 
   * @var string
   */
  public $storageTechnology = null;
  /**
   * The name of the operating system of the target provisioned device
   * * (or device being provisioned).
   *    * Must be one of:
   *    * "ANDROID" - Google Android operating system.
   *    * "WINDOWS" - Microsoft Windows operating system.
   *    * "TIZEN" - Tizen operating system.
   *    * "PAGARE_EMBEDDED_OS" - FitPay embedded operating system
   *    * "ANDROID_WEAR" - Android wear operating system
   *    * "EMBEDDED_OS" - All Embedded operating system and Real time Operating systems
   * 
   * @var string
   */
  public $osName = null;
  /**
   * The version of the operating system of the target provisioned device
   * (or device being provisioned).
   * 
   * @var string
   */
  public $osVersion = null;
  /**
   * Whether the target provisioned device (or device being provisioned) has NFC capability.
   * Must be one of:
   * "true" - The device is NFC capable
   * "false" - The device is not NFC capable
   * 
   * @var bool
   */
  public $nfcCapable = null;
  /**
   * The IMEI number of the target provisioned device
   * (or device being provisioned).
   * 
   * @var string
   */
  public $imei = null;
  /**
   * The MSISDN of the target provisioned device
   * (or device being provisioned).
   * 
   * @var string
   */
  public $msisdn = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'deviceName',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'serialNumber',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'formFactor',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'storageTechnology',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'osName',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'osVersion',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'nfcCapable',
          'type' => TType::BOOL,
          ),
        8 => array(
          'var' => 'imei',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'msisdn',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['deviceName'])) {
        $this->deviceName = $vals['deviceName'];
      }
      if (isset($vals['serialNumber'])) {
        $this->serialNumber = $vals['serialNumber'];
      }
      if (isset($vals['formFactor'])) {
        $this->formFactor = $vals['formFactor'];
      }
      if (isset($vals['storageTechnology'])) {
        $this->storageTechnology = $vals['storageTechnology'];
      }
      if (isset($vals['osName'])) {
        $this->osName = $vals['osName'];
      }
      if (isset($vals['osVersion'])) {
        $this->osVersion = $vals['osVersion'];
      }
      if (isset($vals['nfcCapable'])) {
        $this->nfcCapable = $vals['nfcCapable'];
      }
      if (isset($vals['imei'])) {
        $this->imei = $vals['imei'];
      }
      if (isset($vals['msisdn'])) {
        $this->msisdn = $vals['msisdn'];
      }
    }
  }

  public function getName() {
    return 'DeviceInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->deviceName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->serialNumber);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->formFactor);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->storageTechnology);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->osName);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->osVersion);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->nfcCapable);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->imei);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->msisdn);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeviceInfo');
    if ($this->deviceName !== null) {
      $xfer += $output->writeFieldBegin('deviceName', TType::STRING, 1);
      $xfer += $output->writeString($this->deviceName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->serialNumber !== null) {
      $xfer += $output->writeFieldBegin('serialNumber', TType::STRING, 2);
      $xfer += $output->writeString($this->serialNumber);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->formFactor !== null) {
      $xfer += $output->writeFieldBegin('formFactor', TType::STRING, 3);
      $xfer += $output->writeString($this->formFactor);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->storageTechnology !== null) {
      $xfer += $output->writeFieldBegin('storageTechnology', TType::STRING, 4);
      $xfer += $output->writeString($this->storageTechnology);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->osName !== null) {
      $xfer += $output->writeFieldBegin('osName', TType::STRING, 5);
      $xfer += $output->writeString($this->osName);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->osVersion !== null) {
      $xfer += $output->writeFieldBegin('osVersion', TType::STRING, 6);
      $xfer += $output->writeString($this->osVersion);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->nfcCapable !== null) {
      $xfer += $output->writeFieldBegin('nfcCapable', TType::BOOL, 7);
      $xfer += $output->writeBool($this->nfcCapable);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->imei !== null) {
      $xfer += $output->writeFieldBegin('imei', TType::STRING, 8);
      $xfer += $output->writeString($this->imei);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->msisdn !== null) {
      $xfer += $output->writeFieldBegin('msisdn', TType::STRING, 9);
      $xfer += $output->writeString($this->msisdn);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class MasterCardCardInfo {
  static $_TSPEC;

  /**
   * For repeat digitizations, the unique reference allocated to the Account Primary Account Number.
   * When supplied, the tokenUniqueReferenceForPanInfo, accountNumber, expiryMonth and expiryYear are omitted from CardInfoData.
   * Only allowed if tokenUniqueReferenceForPanInfo is not present and encrypted data does not contain the account information!
   * 
   * @var string
   */
  public $panUniqueReference = null;
  /**
   * For repeat digitizations, the unique reference allocated to the token will be used to retrieve the account number and expiration date.
   * When supplied, the panUniqueReference, accountNumber, expiryMonth and expiryYear are omitted from CardInfoData.
   * 
   * @var string
   */
  public $tokenUniqueReferenceForPanInfo = null;
  /**
   * The fingerprint of the public key used to encrypt the ephemeral AES key.
   * Required if encryptedData is present
   * 
   * @var string
   */
  public $publicKeyFingerprint = null;
  /**
   * One-time use AES key encrypted by the MasterCard public key (as identified by 'publicKeyFingerprint') using the OAEP or
   * RSA Encryption Standard PKCS #1 v1.5 (depending on the value of 'oaepHashingAlgorithm'.
   * Required if encryptedData is present
   * 
   * @var string
   */
  public $encryptedKey = null;
  /**
   * * Hashing algorithm used with the OAEP scheme.
   *    * If omitted, then the RSA Encryption Standard PKCS #1 v1.5 will be used.
   *    * Must be one of:
   *    * "SHA256"
   *    * "SHA512"
   * 
   * @var string
   */
  public $oaepHashingAlgorithm = null;
  /**
   * The initialization vector used when encrypting data using the one-time use AES key. Must be exactly 16 bytes (32 character hex string) to match the block size.
   * If not present, an IV of zero is assumed.
   * 
   * @var string
   */
  public $iv = null;
  /**
   * Contains the encrypted CardInfoData object. Encrypted by the ephemeral AES key using CBC mode (IV as provided in 'iv', or zero if none provided) and PKCS#7 padding.
   * Required if panUniqueReference and tokenUniqueReferenceForPanInfo are not present
   * 
   * @var string
   */
  public $encryptedData = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'panUniqueReference',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'tokenUniqueReferenceForPanInfo',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'publicKeyFingerprint',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'encryptedKey',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'oaepHashingAlgorithm',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'iv',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'encryptedData',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['panUniqueReference'])) {
        $this->panUniqueReference = $vals['panUniqueReference'];
      }
      if (isset($vals['tokenUniqueReferenceForPanInfo'])) {
        $this->tokenUniqueReferenceForPanInfo = $vals['tokenUniqueReferenceForPanInfo'];
      }
      if (isset($vals['publicKeyFingerprint'])) {
        $this->publicKeyFingerprint = $vals['publicKeyFingerprint'];
      }
      if (isset($vals['encryptedKey'])) {
        $this->encryptedKey = $vals['encryptedKey'];
      }
      if (isset($vals['oaepHashingAlgorithm'])) {
        $this->oaepHashingAlgorithm = $vals['oaepHashingAlgorithm'];
      }
      if (isset($vals['iv'])) {
        $this->iv = $vals['iv'];
      }
      if (isset($vals['encryptedData'])) {
        $this->encryptedData = $vals['encryptedData'];
      }
    }
  }

  public function getName() {
    return 'MasterCardCardInfo';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->panUniqueReference);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenUniqueReferenceForPanInfo);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->publicKeyFingerprint);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->encryptedKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->oaepHashingAlgorithm);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->iv);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->encryptedData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MasterCardCardInfo');
    if ($this->panUniqueReference !== null) {
      $xfer += $output->writeFieldBegin('panUniqueReference', TType::STRING, 1);
      $xfer += $output->writeString($this->panUniqueReference);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tokenUniqueReferenceForPanInfo !== null) {
      $xfer += $output->writeFieldBegin('tokenUniqueReferenceForPanInfo', TType::STRING, 2);
      $xfer += $output->writeString($this->tokenUniqueReferenceForPanInfo);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->publicKeyFingerprint !== null) {
      $xfer += $output->writeFieldBegin('publicKeyFingerprint', TType::STRING, 3);
      $xfer += $output->writeString($this->publicKeyFingerprint);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->encryptedKey !== null) {
      $xfer += $output->writeFieldBegin('encryptedKey', TType::STRING, 4);
      $xfer += $output->writeString($this->encryptedKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->oaepHashingAlgorithm !== null) {
      $xfer += $output->writeFieldBegin('oaepHashingAlgorithm', TType::STRING, 5);
      $xfer += $output->writeString($this->oaepHashingAlgorithm);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->iv !== null) {
      $xfer += $output->writeFieldBegin('iv', TType::STRING, 6);
      $xfer += $output->writeString($this->iv);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->encryptedData !== null) {
      $xfer += $output->writeFieldBegin('encryptedData', TType::STRING, 7);
      $xfer += $output->writeString($this->encryptedData);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Specific data for digitalization for MasterCard cards. On server side will call Tokenize method of Digitization API
 */
class MasterCardDigitalizeForm {
  static $_TSPEC;

  /**
   * Identifies the Token Requestor.
   * 
   * @var string
   */
  public $tokenRequestorId = null;
  /**
   * Contains card information of the card to be tokenized.
   * MasterCardCardInfo object
   * 
   * @var \MasterCardCardInfo
   */
  public $cardInfo = null;
  /**
   * by default on server UA
   * 
   * @var string
   */
  public $consumerLanguage = null;
  /**
   * Identifier for this task as assigned by the Token Requestor, unique across a given Token Requestor Identifier. May be used in the Get Task Status API (see Section 2.2.11) to query the status of this task.
   * 
   * @var string
   */
  public $taskId = null;
  /**
   * The Tokenization Authentication Value (TAV) as cryptographically signed by the Issuer to authorize this digitization request.
   * 
   * @var string
   */
  public $tokenizationAuthenticationValue = null;
  /**
   * Contains data relevant to the decisioning process.
   * 
   * @var string
   */
  public $decisioningData = null;
  /**
   * 
   * 
   * @var \MasterCardEligibilityReceipt
   */
  public $masterCardEligibilityReceipt = null;
  /**
   * 
   * 
   * @var string
   */
  public $termsAndConditionsAssetId = null;
  /**
   *  Must be expressed in ISO 8601 extended format as one of the following:
   * <br> YYYY-MM-DDThh:mm:ss[.sss]Z
   * <br> YYYY-MM-DDThh:mm:ss[.sss]±hh:mm
   * <br> Where [.sss] is optional and can be 1 to 3 digits.
   * 
   * @var string
   */
  public $termsAndConditionsAcceptedTimestamp = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'tokenRequestorId',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'cardInfo',
          'type' => TType::STRUCT,
          'class' => '\MasterCardCardInfo',
          ),
        3 => array(
          'var' => 'consumerLanguage',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'taskId',
          'type' => TType::STRING,
          ),
        5 => array(
          'var' => 'tokenizationAuthenticationValue',
          'type' => TType::STRING,
          ),
        6 => array(
          'var' => 'decisioningData',
          'type' => TType::STRING,
          ),
        7 => array(
          'var' => 'masterCardEligibilityReceipt',
          'type' => TType::STRUCT,
          'class' => '\MasterCardEligibilityReceipt',
          ),
        8 => array(
          'var' => 'termsAndConditionsAssetId',
          'type' => TType::STRING,
          ),
        9 => array(
          'var' => 'termsAndConditionsAcceptedTimestamp',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['tokenRequestorId'])) {
        $this->tokenRequestorId = $vals['tokenRequestorId'];
      }
      if (isset($vals['cardInfo'])) {
        $this->cardInfo = $vals['cardInfo'];
      }
      if (isset($vals['consumerLanguage'])) {
        $this->consumerLanguage = $vals['consumerLanguage'];
      }
      if (isset($vals['taskId'])) {
        $this->taskId = $vals['taskId'];
      }
      if (isset($vals['tokenizationAuthenticationValue'])) {
        $this->tokenizationAuthenticationValue = $vals['tokenizationAuthenticationValue'];
      }
      if (isset($vals['decisioningData'])) {
        $this->decisioningData = $vals['decisioningData'];
      }
      if (isset($vals['masterCardEligibilityReceipt'])) {
        $this->masterCardEligibilityReceipt = $vals['masterCardEligibilityReceipt'];
      }
      if (isset($vals['termsAndConditionsAssetId'])) {
        $this->termsAndConditionsAssetId = $vals['termsAndConditionsAssetId'];
      }
      if (isset($vals['termsAndConditionsAcceptedTimestamp'])) {
        $this->termsAndConditionsAcceptedTimestamp = $vals['termsAndConditionsAcceptedTimestamp'];
      }
    }
  }

  public function getName() {
    return 'MasterCardDigitalizeForm';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenRequestorId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->cardInfo = new \MasterCardCardInfo();
            $xfer += $this->cardInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->consumerLanguage);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->taskId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->tokenizationAuthenticationValue);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->decisioningData);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->masterCardEligibilityReceipt = new \MasterCardEligibilityReceipt();
            $xfer += $this->masterCardEligibilityReceipt->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->termsAndConditionsAssetId);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->termsAndConditionsAcceptedTimestamp);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('MasterCardDigitalizeForm');
    if ($this->tokenRequestorId !== null) {
      $xfer += $output->writeFieldBegin('tokenRequestorId', TType::STRING, 1);
      $xfer += $output->writeString($this->tokenRequestorId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->cardInfo !== null) {
      if (!is_object($this->cardInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('cardInfo', TType::STRUCT, 2);
      $xfer += $this->cardInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->consumerLanguage !== null) {
      $xfer += $output->writeFieldBegin('consumerLanguage', TType::STRING, 3);
      $xfer += $output->writeString($this->consumerLanguage);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->taskId !== null) {
      $xfer += $output->writeFieldBegin('taskId', TType::STRING, 4);
      $xfer += $output->writeString($this->taskId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->tokenizationAuthenticationValue !== null) {
      $xfer += $output->writeFieldBegin('tokenizationAuthenticationValue', TType::STRING, 5);
      $xfer += $output->writeString($this->tokenizationAuthenticationValue);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->decisioningData !== null) {
      $xfer += $output->writeFieldBegin('decisioningData', TType::STRING, 6);
      $xfer += $output->writeString($this->decisioningData);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->masterCardEligibilityReceipt !== null) {
      if (!is_object($this->masterCardEligibilityReceipt)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('masterCardEligibilityReceipt', TType::STRUCT, 7);
      $xfer += $this->masterCardEligibilityReceipt->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->termsAndConditionsAssetId !== null) {
      $xfer += $output->writeFieldBegin('termsAndConditionsAssetId', TType::STRING, 8);
      $xfer += $output->writeString($this->termsAndConditionsAssetId);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->termsAndConditionsAcceptedTimestamp !== null) {
      $xfer += $output->writeFieldBegin('termsAndConditionsAcceptedTimestamp', TType::STRING, 9);
      $xfer += $output->writeString($this->termsAndConditionsAcceptedTimestamp);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Specific data for digitalization for MasterCard cards. On server side will call Tokenize method of Digitization API
 */
class VisaDigitalizeForm {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'VisaDigitalizeForm';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('VisaDigitalizeForm');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * 
 */
class DigitalizeCardForm {
  static $_TSPEC;

  /**
   * 
   * 
   * @var int
   */
  public $cardPaymentSystem = null;
  /**
   * 
   * 
   * @var \ContractReference
   */
  public $subjectContract = null;
  /**
   * 
   * 
   * @var string
   */
  public $subjectCardReference = null;
  /**
   * 
   * 
   * @var \MasterCardDigitalizeForm
   */
  public $masterCardDigitalizeForm = null;
  /**
   * 
   * 
   * @var \VisaDigitalizeForm
   */
  public $visaDigitalizeForm = null;
  /**
   * 
   * 
   * @var \DeviceInfo
   */
  public $deviceInfo = null;
  /**
   * 
   * 
   * @var \Attributes
   */
  public $attributes = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'cardPaymentSystem',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'subjectContract',
          'type' => TType::STRUCT,
          'class' => '\ContractReference',
          ),
        3 => array(
          'var' => 'subjectCardReference',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'masterCardDigitalizeForm',
          'type' => TType::STRUCT,
          'class' => '\MasterCardDigitalizeForm',
          ),
        5 => array(
          'var' => 'visaDigitalizeForm',
          'type' => TType::STRUCT,
          'class' => '\VisaDigitalizeForm',
          ),
        6 => array(
          'var' => 'deviceInfo',
          'type' => TType::STRUCT,
          'class' => '\DeviceInfo',
          ),
        99 => array(
          'var' => 'attributes',
          'type' => TType::STRUCT,
          'class' => '\Attributes',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['cardPaymentSystem'])) {
        $this->cardPaymentSystem = $vals['cardPaymentSystem'];
      }
      if (isset($vals['subjectContract'])) {
        $this->subjectContract = $vals['subjectContract'];
      }
      if (isset($vals['subjectCardReference'])) {
        $this->subjectCardReference = $vals['subjectCardReference'];
      }
      if (isset($vals['masterCardDigitalizeForm'])) {
        $this->masterCardDigitalizeForm = $vals['masterCardDigitalizeForm'];
      }
      if (isset($vals['visaDigitalizeForm'])) {
        $this->visaDigitalizeForm = $vals['visaDigitalizeForm'];
      }
      if (isset($vals['deviceInfo'])) {
        $this->deviceInfo = $vals['deviceInfo'];
      }
      if (isset($vals['attributes'])) {
        $this->attributes = $vals['attributes'];
      }
    }
  }

  public function getName() {
    return 'DigitalizeCardForm';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->cardPaymentSystem);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->subjectContract = new \ContractReference();
            $xfer += $this->subjectContract->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->subjectCardReference);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->masterCardDigitalizeForm = new \MasterCardDigitalizeForm();
            $xfer += $this->masterCardDigitalizeForm->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->visaDigitalizeForm = new \VisaDigitalizeForm();
            $xfer += $this->visaDigitalizeForm->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::STRUCT) {
            $this->deviceInfo = new \DeviceInfo();
            $xfer += $this->deviceInfo->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 99:
          if ($ftype == TType::STRUCT) {
            $this->attributes = new \Attributes();
            $xfer += $this->attributes->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DigitalizeCardForm');
    if ($this->cardPaymentSystem !== null) {
      $xfer += $output->writeFieldBegin('cardPaymentSystem', TType::I32, 1);
      $xfer += $output->writeI32($this->cardPaymentSystem);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectContract !== null) {
      if (!is_object($this->subjectContract)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('subjectContract', TType::STRUCT, 2);
      $xfer += $this->subjectContract->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->subjectCardReference !== null) {
      $xfer += $output->writeFieldBegin('subjectCardReference', TType::STRING, 3);
      $xfer += $output->writeString($this->subjectCardReference);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->masterCardDigitalizeForm !== null) {
      if (!is_object($this->masterCardDigitalizeForm)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('masterCardDigitalizeForm', TType::STRUCT, 4);
      $xfer += $this->masterCardDigitalizeForm->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->visaDigitalizeForm !== null) {
      if (!is_object($this->visaDigitalizeForm)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('visaDigitalizeForm', TType::STRUCT, 5);
      $xfer += $this->visaDigitalizeForm->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->deviceInfo !== null) {
      if (!is_object($this->deviceInfo)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('deviceInfo', TType::STRUCT, 6);
      $xfer += $this->deviceInfo->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->attributes !== null) {
      if (!is_object($this->attributes)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('attributes', TType::STRUCT, 99);
      $xfer += $this->attributes->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ValidationException
 * Exception during registr process of device
 */
class RegisterDeviceException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorMessage = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorMessage',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorMessage'])) {
        $this->errorMessage = $vals['errorMessage'];
      }
    }
  }

  public function getName() {
    return 'RegisterDeviceException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessage);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('RegisterDeviceException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorMessage !== null) {
      $xfer += $output->writeFieldBegin('errorMessage', TType::STRING, 2);
      $xfer += $output->writeString($this->errorMessage);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 *  @Deprecated , use ValidationException
 * Exception during digitalize process of card
 */
class DigitalizeCardException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorMessage = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorMessage',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorMessage'])) {
        $this->errorMessage = $vals['errorMessage'];
      }
    }
  }

  public function getName() {
    return 'DigitalizeCardException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessage);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DigitalizeCardException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorMessage !== null) {
      $xfer += $output->writeFieldBegin('errorMessage', TType::STRING, 2);
      $xfer += $output->writeString($this->errorMessage);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Общая ошибка сервера, которая используется тогда, когда нет специализированного типа ошибки для данной ситуации.
 * Как правило, используется для технических, коммуникационных ошибок. Для ошибок целостности данных (например при поиске по ID сущность не найдена) используются специализированные ошибки.
 */
class IbankServerException extends TException {
  static $_TSPEC;

  /**
   * @Deprecated: use errorMessageKey
   * 
   * @var int
   */
  public $errorCode = null;
  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorMessage = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorCode',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'errorMessage',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorCode'])) {
        $this->errorCode = $vals['errorCode'];
      }
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorMessage'])) {
        $this->errorMessage = $vals['errorMessage'];
      }
    }
  }

  public function getName() {
    return 'IbankServerException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->errorCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessage);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('IbankServerException');
    if ($this->errorCode !== null) {
      $xfer += $output->writeFieldBegin('errorCode', TType::I32, 1);
      $xfer += $output->writeI32($this->errorCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 2);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorMessage !== null) {
      $xfer += $output->writeFieldBegin('errorMessage', TType::STRING, 3);
      $xfer += $output->writeString($this->errorMessage);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Ошибка интеграционного слоя, которая используется при ошибках ввода вывода интеграционного слоя и ситуация когда произошла неизвестных ошибках.
 * Как правило, используется для технических, коммуникационных ошибок.
 */
class IbankIntegrationLayerException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorMessage = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorMessage',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorMessage'])) {
        $this->errorMessage = $vals['errorMessage'];
      }
    }
  }

  public function getName() {
    return 'IbankIntegrationLayerException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessage);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('IbankIntegrationLayerException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorMessage !== null) {
      $xfer += $output->writeFieldBegin('errorMessage', TType::STRING, 2);
      $xfer += $output->writeString($this->errorMessage);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Depreceted , use ValidationExcetion
 * Ошибка валидации (не техническая!) интеграционного слоя, работающего с бэк-энд системами компании (банка).
 * Если в работе интеграционного слоя будут срабатывать специфические бизнес-ошибки (например BillerNotFoundException)
 * (а не "техническо-коммуникационные" ошибки, например IOException),
 * то этот набор специализированных ошибок будет обвернут в этот тип ошибки, а ключ errorMessageKey
 * будет четко соответствовать одному из возможных Exception, определенный в API интеграционного слоя (например biller_not_found)
 * 
 */
class BackendValidationException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'BackendValidationException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BackendValidationException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class AuthException extends TException {
  static $_TSPEC;

  /**
   * @var int
   */
  public $type = null;
  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'AuthException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('AuthException');
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 1);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 2);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 3);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ExtendedAuthenticationRequired extends TException {
  static $_TSPEC;

  /**
   * @var int
   */
  public $extendedAuthScope = null;
  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'extendedAuthScope',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['extendedAuthScope'])) {
        $this->extendedAuthScope = $vals['extendedAuthScope'];
      }
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'ExtendedAuthenticationRequired';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->extendedAuthScope);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ExtendedAuthenticationRequired');
    if ($this->extendedAuthScope !== null) {
      $xfer += $output->writeFieldBegin('extendedAuthScope', TType::I32, 1);
      $xfer += $output->writeI32($this->extendedAuthScope);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 2);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 3);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ValidationException
 */
class PreconditionException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'PreconditionException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PreconditionException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * Thats main exception which used whenever any of given parameters not appropriate for requested operation
 */
class ValidationException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'ValidationException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ValidationException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ValidationException
 */
class PeriodIsLargeException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'PeriodIsLargeException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('PeriodIsLargeException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OperationDeniedException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'OperationDeniedException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OperationDeniedException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class WrongSessionException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'WrongSessionException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WrongSessionException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ValidationException
 */
class ContragentIsActivatedTException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'ContragentIsActivatedTException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ContragentIsActivatedTException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ... will be soon
 */
class ExecuteTemplateException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'ExecuteTemplateException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ExecuteTemplateException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ValidationException
 */
class UnsupportedCurrencyException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'UnsupportedCurrencyException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UnsupportedCurrencyException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ValidationException
 */
class UnsupportedCurrencyProviderException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'UnsupportedCurrencyProviderException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('UnsupportedCurrencyProviderException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ValidationException
 */
class CurrencyRateDoesNotExistsException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'CurrencyRateDoesNotExistsException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CurrencyRateDoesNotExistsException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ValidationException
 */
class ProductDoesNotSupportedException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'ProductDoesNotSupportedException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ProductDoesNotSupportedException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ValidationException
 */
class WrongContractIdException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'WrongContractIdException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('WrongContractIdException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ValidationException
 */
class BankNotFoundException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'BankNotFoundException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BankNotFoundException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

/**
 * @Deprecated , use ValidationException
 */
class DeviceNotEligibleException extends TException {
  static $_TSPEC;

  /**
   * @var string
   */
  public $errorMessageKey = null;
  /**
   * @var string
   */
  public $errorDescription = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorMessageKey',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'errorDescription',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorMessageKey'])) {
        $this->errorMessageKey = $vals['errorMessageKey'];
      }
      if (isset($vals['errorDescription'])) {
        $this->errorDescription = $vals['errorDescription'];
      }
    }
  }

  public function getName() {
    return 'DeviceNotEligibleException';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorMessageKey);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->errorDescription);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('DeviceNotEligibleException');
    if ($this->errorMessageKey !== null) {
      $xfer += $output->writeFieldBegin('errorMessageKey', TType::STRING, 1);
      $xfer += $output->writeString($this->errorMessageKey);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->errorDescription !== null) {
      $xfer += $output->writeFieldBegin('errorDescription', TType::STRING, 2);
      $xfer += $output->writeString($this->errorDescription);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

final class Constant extends \Thrift\Type\TConstant {
  static protected $MIME_HTML;
  static protected $MIME_PDF;
  static protected $MIME_PNG;
  static protected $MIME_IMG;
  static protected $MIME_TXT;

  static protected function init_MIME_HTML() {
    return     /**
     * Set of MIME constants for easy determine most popular binary data types (see contentType of Base64BinaryData)
     */
"text/html";
  }

  static protected function init_MIME_PDF() {
    return "application/pdf";
  }

  static protected function init_MIME_PNG() {
    return "image/png";
  }

  static protected function init_MIME_IMG() {
    return "image/png";
  }

  static protected function init_MIME_TXT() {
    return "text/csv";
  }
}


